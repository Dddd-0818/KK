<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>手机桌面</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.2.0/remixicon.min.css" rel="stylesheet">
   <script src="https://unpkg.com/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>
   <script src="https://unpkg.com/idb@7/build/umd.js"></script>
    <style>
        :root {
            --background-color: #000000;
            --text-color: #FFFFFF;
            --frosted-glass-bg: rgba(70, 70, 70, 0.5);
            --frosted-glass-border: 1px solid rgba(255, 255, 255, 0.1);
            --input-bg-color: rgba(50, 50, 50, 0.5);
            --button-bg-color: rgba(80, 80, 80, 0.7);
            --widget-border-radius: 25px;
            --icon-border-radius: 15px;
            --dock-border-radius: 30px;
            --blur-intensity: 15px;
          
            --user-secret-card-bg: rgba(90, 85, 105, 0.6);
        }

        body.light-mode {
            --background-color: #EFEFF4;
            --text-color: #000000;
            --frosted-glass-bg: rgba(255, 255, 255, 0.6);
            --frosted-glass-border: 1px solid rgba(0, 0, 0, 0.1);
            --input-bg-color: rgba(220, 220, 220, 0.7);
            --button-bg-color: rgba(255, 255, 255, 0.8);
            -user-secret-card-bg: rgba(245, 245, 240, 0.7);
        }

        body,
        html {
            height: 100dvh;
            width: 100vw;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            transition: background-color 0.4s ease, color 0.4s ease;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .screen { display: flex; flex-direction: column; height: 100%; width: 100%; box-sizing: border-box; }
        .status-bar { flex-shrink: 0; height: 40px; padding: 20px 30px 0 30px; display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; font-weight: 600; z-index: 30; /* BUG修复：提升z-index */ position: relative; }
        #theme-toggle { width: 32px; height: 32px; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; background-color: rgba(128, 128, 128, 0.2); font-size: 20px; user-select: none; }
        #clock { padding-left: 10px; }
        .main-desktop { flex-grow: 1; display: flex; flex-direction: column; padding: 0 20px 20px 20px; box-sizing: border-box; min-height: 0; margin-top: -60px; /* 补偿status-bar的高度 */ padding-top: 60px; }
        .swipe-area { flex-grow: 1; width: 100%; overflow: hidden; min-height: 0; }
        .page-container { display: flex; width: 200%; height: 100%; transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .page { width: 50%; height: 100%; box-sizing: border-box; display: flex; flex-direction: column; overflow-y: auto; }
        .page::-webkit-scrollbar { width: 4px; }
        .page::-webkit-scrollbar-track { background: transparent; }
        .page::-webkit-scrollbar-thumb { background-color: rgba(128, 128, 128, 0.5); border-radius: 20px; }
        .page-content { display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(4, auto); gap: 15px; padding: 10px 4px 10px 0; box-sizing: border-box; }
        .pagination { flex-shrink: 0; display: flex; justify-content: center; align-items: center; gap: 8px; height: 20px; margin-bottom: 5px; }
        .pagination .dot { width: 7px; height: 7px; border-radius: 50%; background-color: var(--frosted-glass-bg); transition: transform 0.3s ease, background-color 0.4s ease; }
        .pagination .dot.active { transform: scale(1.3); background-color: var(--text-color); }
        .dock { flex-shrink: 0; min-height: 90px; width: 100%; border-radius: var(--dock-border-radius); display: flex; justify-content: space-around; align-items: center; padding: 0 20px; box-sizing: border-box; z-index: 10; }
        .frosted-module { background: var(--frosted-glass-bg); backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity)); border-radius: var(--widget-border-radius); border: var(--frosted-glass-border); transition: background 0.4s ease, border 0.4s ease, transform 0.2s ease; }
        .upload-widget { cursor: pointer; background-size: cover; background-position: center; background-repeat: no-repeat; }
        .upload-widget:hover { transform: scale(1.02); }
        .upload-widget:not(.has-bg-image):hover { border-color: rgba(255, 255, 255, 0.5); }
        .icon-with-text { display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 6px; font-size: 12px; font-weight: 500; }
        .icon-with-text i { font-size: 28px; transition: opacity 0.2s; }
        .app-icon { background: var(--frosted-glass-bg); backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity)); border-radius: var(--icon-border-radius); border: var(--frosted-glass-border); aspect-ratio: 1 / 1; transition: background 0.4s ease, border 0.4s ease; background-size: cover; background-position: center; }
        .dock-icon { width: 60px; height: 60px; background: var(--frosted-glass-bg); backdrop-filter: blur(var(--blur-intensity)); -webkit-backdrop-filter: blur(var(--blur-intensity)); border-radius: var(--icon-border-radius); border: var(--frosted-glass-border); transition: background 0.4s ease, border 0.4s ease; background-size: cover; background-position: center; }
        .dock .icon-with-text i { font-size: 24px; }
        .dock .icon-with-text span { font-size: 11px; }
        .widget-large-horizontal { grid-column: 1 / 3; min-height: 160px; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-around; }
        .widget-square-top-left { grid-column: 1 / 2; grid-row: 2 / 3; aspect-ratio: 1 / 1; }
        .app-grid { grid-column: 1 / 2; grid-row: 3 / 5; display: grid; grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr); gap: 20px; }
        .widget-small-vertical { grid-column: 2 / 3; grid-row: 3 / 5; min-height: 180px; }
        .p2-app-grid { grid-column: 2 / 3; grid-row: 3 / 5; }
        .app-navigator, .settings-navigator { position: fixed; top: 0; left: 0; width: 100vw; height: 100dvh; z-index: 15; pointer-events: none; overflow: hidden; }
        .app-navigator.active, .settings-navigator.active { pointer-events: auto; }
        .app-page, .settings-page { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--frosted-glass-bg); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); box-sizing: border-box; display: flex; flex-direction: column; gap: 15px; }
        .app-navigator.active .app-page.active, .settings-navigator.active .settings-page.active { transform: translateX(0); }
        .app-page, .settings-page { padding-top: 60px; padding-left: 25px; padding-right: 25px; padding-bottom: 25px; }
        .page-header { display: flex; align-items: center; position: relative; justify-content: center; flex-shrink: 0; padding: 10px 0; }
        .page-header .back-button, .page-header .left-icon { position: absolute; left: 10px; font-size: 28px; cursor: pointer; z-index: 10; }
        .page-header .right-icon { position: absolute; right: 10px; font-size: 28px; cursor: pointer; z-index: 10; }
        .page-header h2 { margin: 0; font-weight: 600; text-align: center; }
        .settings-grid { display: grid; grid-template-columns: 1fr; gap: 15px; overflow-y: auto; padding-bottom: 20px; }
        .settings-item { display: flex; align-items: center; gap: 15px; background: var(--button-bg-color); padding: 15px; border-radius: var(--icon-border-radius); cursor: pointer; transition: transform 0.2s ease; }
        .settings-item:hover { transform: scale(1.03); }
        .settings-item i { font-size: 24px; }
        .settings-item span { font-size: 16px; font-weight: 500; flex-grow: 1; }
        .form-group { display: flex; flex-direction: column; gap: 8px; }
        .form-group label { font-size: 14px; opacity: 0.8; }
        .form-group input, .form-group select { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid transparent; background-color: var(--input-bg-color); color: var(--text-color); box-sizing: border-box; font-size: 16px; }
        .preset-manager { display: grid; grid-template-columns: 1fr auto auto; gap: 10px; align-items: center; }
        .model-fetch-group { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
        .action-buttons { display: flex; gap: 10px; justify-content: center; }
        .api-buttons { margin-top: auto; display: flex; gap: 10px; justify-content: center; }
        .action-buttons button, .api-buttons button, .preset-manager button, .model-fetch-group button, .modal-content button { padding: 12px; border: none; border-radius: 8px; background-color: var(--button-bg-color); color: var(--text-color); font-weight: 500; cursor: pointer; transition: background-color 0.2s; white-space: nowrap; }
        .action-buttons button:hover, .api-buttons button:hover, .preset-manager button:hover, .model-fetch-group button:hover, .modal-content button:hover { background-color: var(--text-color); color: var(--background-color); }
        .model-fetch-group button:disabled { opacity: 0.5; cursor: not-allowed; }
        .font-size-control { display: flex; align-items: center; gap: 15px; }
        .font-size-control input[type="range"] { flex-grow: 1; }
        .font-size-control span { min-width: 30px; text-align: right; }
        .music-player-info { display: flex; align-items: center; gap: 12px; min-width: 0; padding: 0 5px; }
        #player-avatar { width: 48px; height: 48px; border-radius: 50%; background-color: rgba(0, 0, 0, 0.3); cursor: pointer; background-size: cover; background-position: center; flex-shrink: 0; transition: transform 0.2s ease; }
        #player-avatar:hover { transform: scale(1.05); }
        .music-text-details { display: flex; flex-direction: column; justify-content: center; min-width: 0; }
        #player-custom-text, #player-song-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; }
        #player-custom-text:focus, #player-song-title:focus { outline: none; text-decoration: underline; text-decoration-thickness: 1px; }
        #player-custom-text { font-size: 16px; font-weight: 600; }
        #player-song-title { font-size: 13px; opacity: 0.7; }
        #player-progress-container { width: 100%; display: flex; align-items: center; gap: 10px; padding: 0 5px; box-sizing: border-box; }
        #player-progress-container span { font-size: 11px; opacity: 0.8; min-width: 35px; text-align: center; }
        #progress-bar { flex-grow: 1; height: 4px; background-color: rgba(255, 255, 255, 0.2); border-radius: 2px; cursor: pointer; overflow: hidden; }
        #progress-fill { height: 100%; width: 0%; background-color: var(--text-color); border-radius: 2px; }
        .music-player-controls { display: flex; justify-content: space-around; align-items: center; width: 100%; }
        .music-player-controls i { cursor: pointer; transition: transform 0.2s ease, opacity 0.2s ease; font-size: 22px; }
        .music-player-controls i:hover { transform: scale(1.1); opacity: 0.8; }
        #play-pause-btn { font-size: 36px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); z-index: 100; display: none; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s ease; }
        .modal-overlay.visible { display: flex; opacity: 1; }
        .modal-content { background: var(--frosted-glass-bg); border: var(--frosted-glass-border); padding: 25px; border-radius: var(--widget-border-radius); width: 90%; max-width: 400px; display: flex; flex-direction: column; gap: 20px; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; }
        .modal-header h3 { margin: 0; }
        #close-modal-btn { font-size: 24px; cursor: pointer; }
        .add-song-group { display: flex; gap: 10px; }
        .add-song-group input { flex-grow: 1; }
        #playlist-container { max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; padding-right: 5px; }
        #playlist-container::-webkit-scrollbar { width: 4px; }
        #playlist-container::-webkit-scrollbar-track { background: transparent; }
        #playlist-container::-webkit-scrollbar-thumb { background-color: rgba(128, 128, 128, 0.5); border-radius: 20px; }
        .playlist-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: var(--input-bg-color); border-radius: 8px; font-size: 14px; }
        .playlist-item span { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; }
        .playlist-item i { cursor: pointer; color: #ff6b6b; flex-shrink: 0; }
        #icon-settings-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 20px; overflow-y: auto; padding: 5px; }
        .icon-setting-item { display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; }
        .icon-preview { width: 60px; height: 60px; border-radius: var(--icon-border-radius); background-color: var(--button-bg-color); display: flex; justify-content: center; align-items: center; background-size: cover; background-position: center; }
        .icon-preview i { font-size: 28px; }
        .icon-setting-item span { font-size: 12px; text-align: center; }
        #calendar-todo-widget { grid-column: 1 / 3; grid-row: 1 / 3; min-height: 280px; padding: 15px; box-sizing: border-box; display: flex; gap: 15px; }
        .calendar-container { flex: 1.2; display: flex; flex-direction: column; }
        .calendar-header { display: flex; justify-content: space-between; align-items: center; padding: 0 5px; margin-bottom: 10px; }
        .calendar-header h3 { margin: 0; font-weight: 600; font-size: 1.1em; }
        .calendar-nav i { cursor: pointer; font-size: 1.5em; transition: transform 0.2s; }
        .calendar-nav i:hover { transform: scale(1.1); }
        .calendar-grid { flex-grow: 1; display: flex; flex-direction: column; }
        .calendar-weekdays, .calendar-dates { display: grid; grid-template-columns: repeat(7, 1fr); text-align: center; }
        .calendar-weekdays span { font-weight: 500; font-size: 0.8em; opacity: 0.7; padding: 5px 0; }
        .calendar-dates { flex-grow: 1; }
        .calendar-date { display: flex; justify-content: center; align-items: center; font-size: 0.9em; cursor: pointer; border-radius: 50%; transition: background-color 0.2s; }
        .calendar-date:not(.empty):hover { background-color: var(--button-bg-color); }
        .calendar-date.empty { opacity: 0.3; pointer-events: none; }
        .calendar-date.today { background-color: var(--text-color); color: var(--background-color); font-weight: 700; }
        .todo-container { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        .todo-container h3 { margin: 0; padding-bottom: 5px; font-weight: 600; font-size: 1.1em; border-bottom: 1px solid var(--frosted-glass-border); }
        #todo-list { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; padding-right: 5px; }
        #todo-list::-webkit-scrollbar { width: 4px; }
        #todo-list::-webkit-scrollbar-track { background: transparent; }
        #todo-list::-webkit-scrollbar-thumb { background-color: rgba(128, 128, 128, 0.5); border-radius: 20px; }
        .todo-item { display: flex; align-items: center; gap: 10px; padding: 8px 5px; font-size: 14px; }
        .todo-item.completed span { text-decoration: line-through; opacity: 0.5; }
        .todo-item input[type="checkbox"] { cursor: pointer; }
        .todo-item span { flex-grow: 1; }
        .delete-todo-btn { cursor: pointer; color: #ff6b6b; font-size: 1.1em; opacity: 0; transition: opacity 0.2s; }
        .todo-item:hover .delete-todo-btn { opacity: 1; }
        .todo-add-form { display: flex; gap: 10px; }
        .todo-add-form input { flex-grow: 1; }
        .todo-add-form button { padding: 10px; border-radius: 8px; border: none; background-color: var(--button-bg-color); color: var(--text-color); cursor: pointer; }
        .has-bg-image, .has-bg-image:hover { border: none !important; }
        .app-icon.has-bg-image i, .app-icon.has-bg-image span, .dock-icon.has-bg-image i, .dock-icon.has-bg-image span { opacity: 0 !important; }
        #music-player-widget.has-bg-image, #calendar-todo-widget.has-bg-image { color: #FFFFFF !important; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); }
        #music-player-widget.has-bg-image *:not(input):not(button), #calendar-todo-widget.has-bg-image *:not(input):not(button) { color: inherit; }
        #archive-app .app-page { background: rgba(0,0,0,0.3); }
        #archive-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 20px; padding: 20px 10px; overflow-y: auto; flex-grow: 1; justify-content: center; }
        .dossier-folder { position: relative; aspect-ratio: 4 / 5; background: var(--button-bg-color); border: var(--frosted-glass-border); border-radius: var(--icon-border-radius); padding: 15px; box-sizing: border-box; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; gap: 12px; }
        .dossier-folder:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .dossier-avatar-preview { width: 70px; height: 70px; border-radius: 50%; background-color: var(--input-bg-color); border: 2px solid var(--frosted-glass-border); background-size: cover; background-position: center; box-shadow: 0 4px 10px rgba(0,0,0,0.3); position: absolute; top: 40px; left: 50%; transform: translateX(-50%); }
        .corner-icon { position: absolute; top: 15px; right: 15px; font-size: 24px; opacity: 0.7; }
        .dossier-folder span { font-weight: 500; text-align: center; font-size: 14px; padding-bottom: 5px; }
        #creation-page .content { flex-grow: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 30px; }
        .persona-editor { background: var(--frosted-glass-bg); border-radius: var(--widget-border-radius); padding: 20px; display: flex; flex-direction: column; gap: 20px; }
        .persona-editor h3 { margin: 0 0 10px 0; border-bottom: 1px solid var(--frosted-glass-border); padding-bottom: 10px; }
        .form-row { display: flex; gap: 20px; align-items: flex-start; }
        .avatar-uploader { width: 100px; height: 100px; border-radius: var(--icon-border-radius); background: var(--input-bg-color); cursor: pointer; display: flex; justify-content: center; align-items: center; flex-shrink: 0; overflow: hidden; background-size: cover; background-position: center; }
        .avatar-uploader i { font-size: 32px; }
        .fields-column { display: flex; flex-direction: column; gap: 15px; flex-grow: 1; }
        .fields-column input, .fields-column textarea { width: 100%; padding: 12px; border-radius: 8px; border: none; background-color: var(--input-bg-color); color: var(--text-color); box-sizing: border-box; font-size: 16px; font-family: inherit; }
        .fields-column textarea { min-height: 100px; resize: vertical; }
        #creation-page .action-buttons { justify-content: center; padding: 20px 0; flex-shrink: 0; display: flex; gap: 15px; }
        #creation-page .action-buttons button:disabled { opacity: 0.6; cursor: not-allowed; }
        #dossier-modal-content { background: var(--frosted-glass-bg); border: var(--frosted-glass-border); border-radius: var(--widget-border-radius); width: 90%; max-width: 420px; max-height: 90vh; display: flex; flex-direction: column; font-family: "仿宋", "KaiTi", "BiauKai", "楷体", serif; }
        .dossier-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--frosted-glass-border); }
        .dossier-header span { font-weight: bold; font-size: 1.1em; }
        .dossier-header i { cursor: pointer; font-size: 24px; font-family: -apple-system, sans-serif; }
        .dossier-body { padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; }
        .dossier-top-section { display: flex; gap: 20px; align-items: flex-start; }
        .dossier-avatar { flex: 1; aspect-ratio: 1 / 1; background-color: var(--input-bg-color); border: 1px solid var(--frosted-glass-border); border-radius: var(--icon-border-radius); background-size: cover; background-position: center; }
        .dossier-main-info { flex: 1.5; display: flex; flex-direction: column; gap: 15px;}
        .dossier-field { border-bottom: 1px solid var(--frosted-glass-border); padding-bottom: 8px; }
        .dossier-field label { display: block; font-size: 0.9em; opacity: 0.7; margin-bottom: 5px; }
        .dossier-field span, .dossier-field p { font-size: 1.1em; font-weight: bold; margin: 0; }
        .dossier-details-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px 20px; }
        .dossier-quote { font-style: italic; padding: 10px 15px; margin: 5px 0 0 0; border-left: 3px solid var(--text-color); opacity: 0.9; font-size: 1.05em; }
        .dossier-background { line-height: 1.7; font-size: 1.05em; padding-top: 5px; font-weight: normal;}
        .dossier-fingerprints { text-align: center; }
        .dossier-fingerprints h4 { margin: 15px 0 10px 0; font-weight: normal; letter-spacing: 1px; }
        .fingerprint-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; }
        .fingerprint-placeholder { background: var(--input-bg-color); aspect-ratio: 3/4; border-radius: 4px; display: flex; justify-content: center; align-items: center; }
        .fingerprint-placeholder i { font-size: 24px; opacity: 0.5; font-family: -apple-system, sans-serif; }
        .dossier-footer { display: flex; gap: 15px; justify-content: flex-end; padding: 15px 20px; border-top: 1px solid var(--frosted-glass-border); }
        .toast-notification { position: fixed; top: 70px; left: 50%; transform: translateX(-50%); background-color: var(--frosted-glass-bg); color: var(--text-color); padding: 12px 25px; border-radius: var(--dock-border-radius); z-index: 200; font-size: 14px; font-weight: 500; opacity: 0; transition: opacity 0.4s ease, top 0.4s ease; pointer-events: none; }
        .chat-main-content { flex-grow: 1; overflow: hidden; position: relative; padding-bottom: 70px; }
        .content-pane { position: absolute; width: 100%; height: 100%; overflow-y: auto; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .content-pane.active { opacity: 1; pointer-events: auto; }
        #chat-list { list-style: none; margin: 0; padding: 15px 20px; display: flex; flex-direction: column; gap: 12px; }
        .chat-list-item { display: flex; align-items: center; gap: 15px; padding: 15px; background-color: var(--button-bg-color); border-radius: var(--icon-border-radius); border: var(--frosted-glass-border); cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; }
        .chat-list-item:hover { transform: translateY(-3px); box-shadow: 0 8px 15px rgba(0,0,0,0.2); }
        .chat-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: var(--input-bg-color); flex-shrink: 0; background-size: cover; background-position: center; }
        .chat-details { flex-grow: 1; min-width: 0; }
        .chat-name { font-weight: 600; font-size: 16px; }
        .chat-last-message { font-size: 14px; opacity: 0.7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 4px; }
        .chat-meta { text-align: right; flex-shrink: 0; }
        .chat-time { font-size: 12px; opacity: 0.6; }
        .unread-badge { display: inline-block; background-color: #ff3b30; color: white; font-size: 11px; font-weight: 600; padding: 2px 6px; border-radius: 10px; margin-top: 6px; }
        .chat-tab-bar { position: absolute; bottom: 0; left: 0; right: 0; display: flex; justify-content: space-around; padding: 10px 0; background: var(--frosted-glass-bg); backdrop-filter: blur(var(--blur-intensity)); border-top: var(--frosted-glass-border); }
        .tab-item { display: flex; flex-direction: column; align-items: center; gap: 4px; color: var(--text-color); opacity: 0.6; cursor: pointer; transition: opacity 0.2s, transform 0.2s; font-size: 11px; }
        .tab-item i { font-size: 24px; }
        .tab-item.active { opacity: 1; transform: scale(1.1); }
        .coming-soon-placeholder { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; gap: 15px; opacity: 0.5; }
        .coming-soon-placeholder i { font-size: 48px; }
        #character-select-list { display: flex; flex-direction: column; gap: 12px; padding: 5px; }
        #character-select-list .character-select-item { display: flex; align-items: center; gap: 15px; padding: 15px; background-color: var(--button-bg-color); border: var(--frosted-glass-border); cursor: pointer; border-radius: var(--icon-border-radius); transition: transform 0.2s ease, box-shadow 0.2s ease; }
        #character-select-list .character-select-item:hover { transform: translateY(-3px); box-shadow: 0 8px 15px rgba(0,0,0,0.2); }
        #character-select-list .character-select-item .chat-avatar { width: 45px; height: 45px; }
        
       /* 对话页面的整体布局 (此规则保持不变) */
#chat-dialogue-page {
    padding: 0; 
    gap: 0; 
}

/* 覆盖对话页面的页头 (修改下面这一段) */
#chat-dialogue-page .page-header {
    position: absolute; 
    top: 0; /* 关键修复：改回 0，使其从屏幕最顶端开始 */
    left: 0;
    right: 0;
    z-index: 10;
    padding: 60px 25px 10px 25px; /* 关键修复：使用 padding-top 代替 top 来为状态栏留出空间 */
    background: rgba(0,0,0,0.1); 
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border-bottom: 1px solid var(--frosted-glass-border);
    height: auto; /* 确保高度自适应 */
    box-sizing: border-box; /* 确保 padding 不会撑大元素 */
}
#chat-messages-container {
    flex-grow: 1;
    overflow-y: auto;
    /* 关键修复：计算新的顶部内边距。原头部高度约50px + 新的top值60px = 110px */
    padding: 110px 15px 15px 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px;
}
        /* 底部输入栏 */
        .chat-input-bar {
            flex-shrink: 0;
            padding: 8px;
            /* 关键修改：使用半透明背景并添加模糊滤镜 */
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-top: var(--frosted-glass-border);
            display: flex;
            align-items: flex-end;
            gap: 4px;
        }

        /* 输入框样式 */
        #chat-input-textarea {
            flex-grow: 1;
            padding: 10px 18px; 
            /* 关键修复：分别定义四个角的圆角 */
            /* 顺序：左上 右上 右下 左下 */
            border-radius: 8px 8px 8px 8px; 
            border: none;
            background-color: var(--input-bg-color);
            color: var(--text-color);
            font-size: 16px;
            line-height: 1.4;
            resize: none;
            height: 44px; /* 关键修复：使用固定的 height 代替 min/max-height */
            overflow-y: auto; /* 当内容超出44px时，自动显示滚动条 */
            box-sizing: border-box; /* 确保padding不会影响最终高度 */
        }
        #chat-input-textarea:focus { outline: none; }
        .chat-input-bar .icon-btn { background: transparent; border: none; color: var(--text-color); font-size: 28px; cursor: pointer; padding: 5px; opacity: 0.7; transition: opacity 0.2s, transform 0.2s; }
        .chat-input-bar .icon-btn:hover { opacity: 1; transform: scale(1.1); }
        .chat-input-bar .icon-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .chat-message { display: flex; gap: 10px; max-width: 80%; align-items: flex-start; }
        .chat-message .avatar { width: 36px; height: 36px; border-radius: 50%; background-color: var(--input-bg-color); flex-shrink: 0; background-size: cover; background-position: center; }
        .chat-message .avatar-placeholder { width: 36px; height: 36px; flex-shrink: 0; } /* 新增：用于占位 */
        /* 气泡的通用样式 (您修改的重点) */
        .chat-message .bubble {
            padding: 10px 15px;
            border-radius: 18px; /* 保持所有角都是圆的 */
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
            /* 新增：毛玻璃效果 */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .chat-message.user { align-self: flex-end; flex-direction: row-reverse; }
        /* 用户气泡的颜色和特殊圆角 */
        .chat-message.user .bubble {
            /* 修改：背景改为半透明浅灰色 */
            background-color: rgba(229, 229, 234, 0.8); 
            /* 修改：文字颜色改为黑色以保证可读性 */
            color: #000000;
        }
        .chat-message.character { align-self: flex-start; }
        /* 角色气泡的颜色和特殊圆角 */
        .chat-message.character .bubble {
            background-color: var(--button-bg-color);
        }
        .chat-message.system { align-self: center; font-size: 12px; color: var(--text-color); opacity: 0.6; background-color: rgba(128,128,128,0.2); padding: 5px 12px; border-radius: 12px; }
        .typing-bubble { display: flex; align-items: center; gap: 4px; }
        .typing-bubble .dot { width: 8px; height: 8px; background-color: currentColor; border-radius: 50%; opacity: 0.5; animation: typing-blink 1.4s infinite both; }
        .typing-bubble .dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-bubble .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing-blink { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .translation-text {
    display: block;
    opacity: 0.7;
    font-size: 0.9em;
    margin-top: 5px;
}

    /* 全局通知横幅样式 */
    #global-notification-banner {
        position: fixed;
        top: 0;
        left: 50%;
        transform: translate(-50%, -150%); /* 初始状态，完全隐藏在屏幕上方 */
        width: 95%;
        max-width: 450px;
        margin-top: 10px;
        padding: 12px 15px;
        z-index: 250; /* 确保它在最顶层 */
        
        display: flex;
        align-items: center;
        gap: 12px;
        
        background: var(--frosted-glass-bg);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: var(--frosted-glass-border);
        border-radius: var(--widget-border-radius);
        box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        
        cursor: pointer;
        transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1); /* 平滑的弹出动画 */
    }
    #global-notification-banner.visible {
        transform: translate(-50%, 0); /* 可见状态，滑入屏幕 */
    }
    .notification-content {
        display: flex;
        flex-direction: column;
        gap: 2px;
        color: var(--text-color);
        min-width: 0;
    }
    #notification-title {
        font-weight: 600;
        font-size: 15px;
    }
    #notification-message {
        font-size: 13px;
        opacity: 0.8;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

#memory-rounds-modal .modal-content {
    max-width: 380px; /* 调整浮窗宽度 */
}
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    background: var(--input-bg-color);
    border-radius: 5px;
    outline: none;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: var(--text-color);
    cursor: pointer;
    border-radius: 50%;
}

    /* 滑动开关样式 */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 28px;
        margin-left: auto; /* 关键：让开关自动靠右 */
    }
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--input-bg-color);
        transition: .4s;
        border-radius: 34px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    input:checked + .slider {
        background-color: #799181; /* 激活时的绿色 */
    }
    input:checked + .slider:before {
        transform: translateX(22px);
    }

/* 置顶聊天项的高亮样式 */
    .chat-list-item.pinned {
        /* 你可以选择任何你喜欢的颜色，这里用一个淡淡的、有区别的背景色 */
        background-color: rgba(128, 128, 128, 0.2); 
    }

 /* 危险操作区域的容器样式 */
#danger-zone-container {
    margin-top: 80px;
    padding-bottom: 20px;
    /* vvv 新增以下三行 vvv */
    display: flex;
    flex-direction: column;
    gap: 15px;
}
    .danger-button {
        width: 100%;
        padding: 15px;
        border: none;
        border-radius: var(--icon-border-radius);
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        color: #FFFFFF;
        background-color: #ff3b30; /* 危险操作的红色 */
        transition: background-color 0.2s, transform 0.2s;
    }
    .danger-button:hover {
        background-color: #c70000; /* 鼠标悬停时颜色变深 */
        transform: scale(1.02);
    }

/* 气泡长按弹出菜单 (Popover) 样式 */
#bubble-popover-menu {
            position: fixed;
            display: flex;
            align-items: center;
            background-color: #2C2C2E;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            z-index: 300;
            overflow: hidden;
            
            /* 【核心修正】默认隐藏时，尺寸不变(没有scale)，只改变透明度和垂直位置 */
            opacity: 0;
            transform: translateY(10px); /* 从下方轻微上浮 */
            pointer-events: none;
            transition: opacity 0.15s ease-out, transform 0.15s ease-out;
        }

        #bubble-popover-menu.visible {
            opacity: 1;
            transform: translateY(0); /* 恢复到最终位置 */
            pointer-events: auto;
        }

        .popover-item {
            padding: 12px 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            font-size: 15px;
            color: rgba(255, 255, 255, 0.95);
            white-space: nowrap;
        }
        
        .popover-item:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .popover-divider {
            width: 1px;
            height: 18px;
            background-color: rgba(255, 255, 255, 0.2);
        }

/* 双向引用功能所需的所有CSS样式 (美化版)  */

        /* --- 样式1：用户引用预览 (输入框上方) --- */
        #reply-preview-container {
            flex-shrink: 0;
            margin: 0 12px 8px 12px;
            padding: 10px 15px;
            background: rgba(70, 70, 70, 0.5);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 12px;
            border-top: var(--frosted-glass-border);
            border-left: 3px solid rgba(255, 255, 255, 0.5);
            display: none;
            align-items: center;
            gap: 10px;
            box-sizing: border-box;
        }
        #reply-preview-container.visible { display: flex; }
        .reply-content { flex-grow: 1; display: flex; flex-direction: column; gap: 2px; min-width: 0; }
        #reply-author { font-size: 13px; font-weight: 600; color: var(--text-color); }
        #reply-text { font-size: 14px; color: var(--text-color); opacity: 0.85; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #close-reply-btn { font-size: 22px; cursor: pointer; opacity: 0.8; transition: opacity 0.2s; }
        #close-reply-btn:hover { opacity: 1; }

        /* --- 样式2：聊天记录中的引用气泡 --- */
        .bubble-wrapper {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .chat-message.character .bubble-wrapper {
            align-items: flex-start; /* 让wrapper内的元素左对齐 */
        }
        .chat-message.user .bubble-wrapper {
            align-items: flex-end; /* 让wrapper内的元素右对齐 */
        }

        .quoted-preview {
            padding: 6px 10px;
            box-sizing: border-box;
            background-color: rgba(128, 128, 128, 0.4);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-radius: 10px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            
            /* 【核心修正】允许文本自动换行 */
            white-space: normal;
            word-break: break-word; /* 确保长单词也能被正确断开 */
            
            max-width: 100%; /* 让它能和父容器一样宽 */
        }
        
        .chat-message.character .quoted-preview {
            align-self: flex-start;
        }
        .chat-message.user .quoted-preview {
            align-self: flex-end;
        }
/* 
     * ===============================================
     * ===   新增：“多选模式”相关的CSS样式         ===
     * ===============================================
    */

    /* 多选模式下，给父容器添加一个标识类 */
    #chat-dialogue-page.multi-select-mode .chat-input-bar,
    #chat-dialogue-page.multi-select-mode #reply-preview-container {
        display: none; /* 隐藏常规的输入栏和引用预览 */
    }

    /* 批量操作的底部栏 */
    #multi-select-toolbar {
        flex-shrink: 0;
        padding: 10px 20px;
        background: var(--frosted-glass-bg);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border-top: var(--fro-sted-glass-border);
        display: none; /* 默认隐藏 */
        justify-content: space-between;
        align-items: center;
    }
    #chat-dialogue-page.multi-select-mode #multi-select-toolbar {
        display: flex; /* 在多选模式下显示 */
    }
    #multi-select-toolbar button {
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 28px;
        cursor: pointer;
        opacity: 0.5; /* 默认禁用状态 */
        pointer-events: none;
        transition: opacity 0.2s;
    }
    #multi-select-toolbar button.active {
        opacity: 1; /* 激活时（有选中项时） */
        pointer-events: auto;
    }

    /* 复选框的容器 */
    .message-checkbox-container {
        width: 24px;
        height: 24px;
        flex-shrink: 0;
        margin-right: 10px;
        display: none; /* 默认隐藏 */
        align-items: center;
        justify-content: center;
        transition: transform 0.2s;
    }
    #chat-dialogue-page.multi-select-mode .message-checkbox-container {
        display: flex; /* 在多选模式下显示 */
    }

    /* 自定义复选框样式 */
    .message-checkbox {
        width: 22px;
        height: 22px;
        border: 2px solid var(--text-color);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background-color 0.2s, border-color 0.2s;
        opacity: 0.7;
    }
    .message-checkbox i {
        font-size: 18px;
        color: var(--background-color);
        transform: scale(0);
        transition: transform 0.2s ease-in-out;
    }
    .message-checkbox.checked {
        background-color: var(--text-color);
        border-color: var(--text-color);
        opacity: 1;
    }
    .message-checkbox.checked i {
        transform: scale(1);
    }
    
    /* 选中消息的视觉反馈 */
    #chat-dialogue-page.multi-select-mode .chat-message.selected {
        background-color: rgba(128, 128, 128, 0.2);
        border-radius: 10px;
    }

/* 让撤回提示条在鼠标悬停时有反馈，并显示为可点击的手型 */
.withdrawn-notice {
    cursor: pointer;
    transition: background-color 0.2s;
}
.withdrawn-notice:hover {
    background-color: rgba(128,128,128,0.4);
}

/* 
 * ===============================================
 * ===   新增：“图书馆”应用相关的CSS样式       ===
 * ===============================================
*/

/* 图书馆主列表的容器 */
#library-list-container {
    padding: 20px 10px; /* 给列表一些呼吸空间 */
    
    /* vvv  新增以下三行核心布局代码 vvv */
    display: flex;           /* 使用 Flex 布局 */
    flex-direction: column;  /* 让卡片垂直排列 */
    gap: 15px;               /* 保持卡片之间的间距 */
}

/* 区分全局/专属的指示器图标 */
#library-list-container .settings-item i {
    font-size: 20px;
    margin-right: -5px; /* 让图标和文字更紧凑 */
}

/* 图书馆创建页面的特殊布局 */
#library-creation-page .content,
#book-edit-modal .content {
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    padding: 10px;
}

/* 让创建/编辑页面的文本域能填满剩余空间 */
#library-creation-page .form-group textarea,
#book-edit-modal .form-group textarea {
    width: 100%;
    min-height: 150px;
    resize: vertical;
    padding: 12px;
    border-radius: 8px;
    border: none;
    background-color: var(--input-bg-color);
    color: var(--text-color);
    font-size: 16px;
    font-family: inherit;
    box-sizing: border-box; /* 确保 padding 不会撑大元素 */
    flex-grow: 1; /* 【核心】让它填满父容器的剩余空间 */
}

/* 编辑浮窗的特殊样式调整 */
#book-edit-modal .modal-content {
    /* 允许内容在垂直方向上溢出时滚动 */
    overflow-y: hidden; 
}
#book-edit-modal .content {
    /* 限制内容区的最大高度，防止撑爆浮窗 */
    max-height: 60vh;
}

/* (在 <style> 标签内，替换掉之前所有“动态”相关的CSS) */

/* 
 * ===============================================
 * ===   “动态”功能 CSS (V3 最终版)           ===
 * ===============================================
*/

/* 动态页面的主内容容器 */
.moments-content {
    width: 100%;
    display: flex;
    flex-direction: column;
}

/* 顶部的快拍容器 */
.stories-container {
    flex-shrink: 0;
    display: flex;
    align-items: flex-start;
    gap: 15px;
    padding: 15px 20px;
    overflow-x: auto;
    scrollbar-width: none; /* Firefox */
}
.stories-container::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}

/* 单个快拍项目 (头像+名字) */
.story-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    width: 70px;
    transition: opacity 0.2s ease; /* 新增：让状态变化更平滑 */
}
.story-item span {
    font-size: 12px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
}

/* 快拍头像样式 */
.story-avatar {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background-color: var(--button-bg-color);
    background-size: cover;
    background-position: center;
    flex-shrink: 0;
    padding: 3px;
    background-clip: content-box;
    border: 2px solid transparent; 
    transition: transform 0.2s ease, border-color 0.3s ease, box-shadow 0.3s ease; /* 新增：让边框颜色变化也带动画 */
}
.story-item:not(.no-story):hover .story-avatar {
    transform: scale(1.05);
}

/* 【修正】有新快拍的高亮样式 (您选择的方案) */
.story-item.has-unread .story-avatar { /* <--- 核心修改在这里 */
    border-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}
.story-item.has-unread {
    opacity: 1;
}
/* vvv 【新增】浅色模式下，快拍高亮的特殊颜色 (使用 Water Moss) vvv */
body.light-mode .story-item.has-unread .story-avatar {
    /* 核心修改：使用您挑选的 #8F9E8D 作为边框颜色 */
    border-color: #8F9E8D; 
    
    /* 匹配的发光效果：使用同色系的半透明颜色作为光晕 */
    box-shadow: 0 0 10px rgba(143, 158, 141, 0.6); 
}

/* 【修正】没有快拍的禁用样式 (语义更清晰) */
.story-item.no-story {
    cursor: default;
    opacity: 0.6;
}
.story-item.no-story .story-avatar {
    border-color: rgba(128, 128, 128, 0.4);
}
.story-item.no-story:hover .story-avatar {
    transform: none;
}

/* “你的快拍”占位符的特殊样式 */
.story-item.placeholder .story-avatar {
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 28px;
    background-color: var(--input-bg-color);
}

/* 分隔线 */
.moments-divider {
    border: none;
    border-top: 1px solid var(--frosted-glass-border);
    margin: 0 20px;
}

/* 下方的日常 (Posts) 容器 */
.posts-container {
    flex-grow: 1;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 25px;
}

/* 【新增】日常卡片样式 */
.post-card {
    /* 【核心修改】应用和您其他模块一样的毛玻璃背景和边框 */
    background: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: var(--frosted-glass-border);
    
    border-radius: var(--icon-border-radius); /* 保持圆角统一 */
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.post-header { display: flex; align-items: center; gap: 12px; }
.post-avatar { width: 40px; height: 40px; border-radius: 50%; background-color: var(--input-bg-color); background-size: cover; background-position: center; flex-shrink: 0; }
.post-author-info { display: flex; flex-direction: column; gap: 2px; }
.post-author-name { font-weight: 600; font-size: 15px; }
.post-timestamp { font-size: 12px; opacity: 0.6; }
.post-content p { margin: 0; line-height: 1.6; white-space: pre-wrap; word-break: break-word; }
.post-image {
    width: 100%;
    aspect-ratio: 16 / 10;
    border-radius: 10px;
    background-size: cover;
    background-position: center;
    margin-top: 10px;
}
/* 【新增】图片描述/标题的样式 */
.post-image-caption {
    font-size: 13px;
    opacity: 0.7;
    margin: 8px 0 0 0;
    padding-left: 10px;
    border-left: 2px solid rgba(255, 255, 255, 0.3);
    font-style: italic;
}
.post-actions { display: flex; gap: 20px; font-size: 22px; opacity: 0.7; padding-top: 5px; }
.post-actions i { cursor: pointer; }
/* vvv 【新增】评论区相关的 CSS 样式 vvv */
.post-comments-container {
    /* 保留布局属性 */
    display: flex;
    flex-direction: column;
    gap: 12px;
    /* 移除所有边框和边距 */
}
/* vvv 【最终修复】“有评论时”的条件样式 (已修正语法) vvv */
.post-comments-container.has-comments {
    padding-top: 15px;
    margin-top: 15px;
    /* 核心修正：只使用变量，不再重复写 1px solid */
    border-top: var(--frosted-glass-border);
}

.comment-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

/* vvv 【新增】为评论项之间添加分割线 vvv */
.comment-item:not(:last-child) {
    padding-bottom: 12px; /* 让分割线和下面的文字拉开距离 */
    border-bottom: var(--frosted-glass-border);
}

/* vvv 【新增】评论区头部（名字+时间）和时间戳的样式 vvv */
.comment-header {
    display: flex;
    justify-content: space-between; /* 让名字靠左，时间戳靠右 */
    align-items: center;
    margin-bottom: 4px; /* 头部和评论内容之间留出一点空隙 */
}

.comment-timestamp {
    font-size: 12px;
    opacity: 0.6; /* 让时间戳的视觉重量轻一些 */
    flex-shrink: 0; /* 防止被挤压 */
    margin-left: 10px; /* 和名字之间保持最小间距 */
}

.comment-author-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: var(--input-bg-color);
    background-size: cover;
    background-position: center;
    flex-shrink: 0;
}

.comment-content {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.comment-author-name {
    font-weight: 600;
    font-size: 14px;
}

.comment-text {
    font-size: 14px;
    line-height: 1.5;
    opacity: 0.9;
    white-space: pre-wrap;
    word-break: break-word;
}

.post-comments-container .comment-item.is-reply {
    margin-left: 42px; /* 关键：向右缩进 (头像宽度40px + 间距10px - 自身边距8px) */
    background-color: var(--input-bg-color); /* 给回复一个淡淡的背景以区分 */
    padding: 8px 12px;
    border-radius: 8px;
    margin-top: 8px; /* 和上面的用户评论拉开一点距离 */
}

/* 
 * ===============================================
 * ===   新增：“快拍查看器”相关的CSS样式      ===
 * ===============================================
*/

/* 全屏浮层总容器 */
.story-viewer-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100dvh;
    background-color: #1C1C1E; /* 一个深邃的背景色 */
    z-index: 200;
    display: flex;
    flex-direction: column;
    
    /* 默认隐藏，通过 transform 和 opacity 实现流畅的弹出效果 */
    opacity: 0;
    transform: scale(1.1);
    pointer-events: none;
    transition: opacity 0.3s ease, transform 0.3s ease;
}
.story-viewer-overlay.visible {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}

/* 顶部信息栏 */
.story-viewer-header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 15px; /* 左右保留内边距 */
    /* 【核心修改】移除 padding-top，让它从屏幕最顶端开始 */
    z-index: 2;
    background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
}
.story-progress-bars {
    display: flex;
    gap: 4px;
    height: 2px;
    margin-bottom: 12px;
}
.progress-bar-segment {
    flex-grow: 1;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 2px;
    overflow: hidden;
}
.progress-bar-fill {
    height: 100%;
    width: 0;
    background-color: #FFFFFF;
    /* vvv 【核心修正】在这里添加动画效果 vvv */
    /* 当 width 变化时，用 10 秒的时间完成动画，linear 表示匀速 */
    transition: width 10s linear; 
}

.story-author-info { 
    display: flex; 
    align-items: center; 
    gap: 10px; 
    /* 【核心修改】只给作者信息部分增加上边距，以避开状态栏 */
    margin-top: 40px; 
}
.story-avatar-small { width: 36px; height: 36px; border-radius: 50%; background-size: cover; background-position: center; }
.story-author-details { display: flex; flex-direction: column; color: #FFFFFF; }
.story-author-name { font-weight: 600; }
.story-timestamp { font-size: 13px; opacity: 0.8; }
.story-header-actions { position: absolute; right: 15px; top: 60px; display: flex; gap: 20px; font-size: 24px; color: #FFFFFF; }
.story-header-actions i { cursor: pointer; }

/* 中间内容区域 */
.story-content-area {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    background-size: cover;
    background-position: center;
}
.story-text-content {
    font-size: 24px;
    font-weight: 600;
    color: #FFFFFF;
    text-align: center;
    line-height: 1.5;
    text-shadow: 1px 1px 5px rgba(0,0,0,0.5);
}

/* 左右切换导航 */
.story-nav-left, .story-nav-right {
    position: absolute;
    top: 60px; /* 从头部下方开始 */
    bottom: 80px; /* 在底部栏上方结束 */
    width: 30%; /* 占据屏幕30%的宽度 */
    z-index: 1;
}
.story-nav-left { left: 0; }
.story-nav-right { right: 0; }

/* 底部交互栏 */
.story-viewer-footer {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 15px 20px 30px 20px; /* 底部留出更多安全空间 */
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 2;
    color: #FFFFFF;
}
#story-comment-input {
    flex-grow: 1;
    background: transparent;
    border: 1.5px solid rgba(255, 255, 255, 0.8);
    border-radius: 25px;
    padding: 12px 20px;
    color: #FFFFFF;
    font-size: 15px;
}
#story-comment-input::placeholder { color: rgba(255, 255, 255, 0.8); }
.story-viewer-footer i { font-size: 28px; cursor: pointer; }
/* 【新增】发送按钮的样式 */
.story-send-btn {
    font-size: 28px;
    cursor: pointer;
    /* 默认隐藏，通过 opacity 和 transform 实现优雅的显现动画 */
    opacity: 0;
    transform: scale(0.8);
    transition: opacity 0.2s ease, transform 0.2s ease;
    /* 确保它不占用空间 */
    width: 0;
    overflow: hidden;
}

/* 【新增】当输入框被激活时，发送按钮的样式 */
.story-viewer-footer.input-active .story-send-btn {
    opacity: 1;
    transform: scale(1);
    width: auto; /* 恢复正常宽度 */
    margin-right: 15px; /* 和输入框之间留出一点距离 */
}
/* vvv 【新增】快拍评论区相关的 CSS 样式 vvv */

/* 评论浮动区的容器 */
.story-comments-container {
    position: absolute;
    bottom: 90px; /* 位于底部交互栏的上方 */
    left: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* 评论都靠左显示 */
    gap: 10px;
    max-height: 30%; /* 评论区最多占据30%的屏幕高度 */
    overflow-y: auto;
    -webkit-mask-image: linear-gradient(to top, transparent, black 20px);
    mask-image: linear-gradient(to top, transparent, black 20px);
    scrollbar-width: none;
     /* 【核心修正】在底部增加 20px 的内边距，防止最后一条评论被遮挡 */
    padding-bottom: 20px;
    box-sizing: border-box; /* 确保 padding 不会增加容器的总高度 */
}

/* 【核心修改】单条评论气泡 -> 现在是“无气泡”项 */
.story-comment-bubble {
    display: flex;
    align-items: center;
    gap: 8px;
    /* 移除所有背景相关的属性 */
    background-color: transparent; /* <--- 核心修改 */
    padding: 0;                   /* <--- 核心修改 */
    border-radius: 0;               /* <--- 核心修改 */
    backdrop-filter: none;          /* <--- 核心修改 */
    
    /* 冒泡动画 (保持不变) */
    opacity: 0;
    transform: translateY(20px);
    animation: bubble-fade-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
}

/* 动画 keyframes (保持不变) */
@keyframes bubble-fade-in {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* 评论者的迷你头像 (增加阴影) */
.story-comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    flex-shrink: 0;
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

/* 评论的文字部分 (增加阴影) */
.story-comment-text {
    color: #FFFFFF;
    font-size: 14px;
    word-break: break-word;
    text-shadow: 0 1px 3px rgba(0,0,0,0.6);
}
.story-comment-text strong {
    font-weight: 600;
    margin-right: 6px;
}
/* 
 * ===============================================
 * ===   新增：“点赞”功能相关的CSS样式        ===
 * ===============================================
*/
.post-actions .like-btn,
.story-viewer-footer .like-btn {
    transition: color 0.2s ease, transform 0.2s ease;
}

.post-actions .like-btn.liked,
.story-viewer-footer .like-btn.liked {
    color: #ff3b30; /* 点赞后的红色 */
    transform: scale(1.1); /* 点赞时有一个轻微的放大动画 */
}

/* vvv 【新增】评论区“回复”按钮的样式 vvv */
.comment-actions {
    font-size: 12px;
    opacity: 0.6;
    cursor: pointer;
    margin-left: auto; /* 核心：让按钮自动靠到最右边 */
    padding-left: 10px;
}
.comment-actions:hover {
    opacity: 1;
    color: #799181; /* 一个高亮色 */
}

/* vvv 【新增】动态交互项的容器 vvv */
.action-item {
    display: flex;
    align-items: center;
    gap: 6px; /* 控制图标和数字之间的间距 */
    cursor: pointer;
}

/* vvv 【新增】交互计数的数字样式 vvv */
.action-count {
    font-size: 15px; /* 设置一个合适的字号 */
    font-weight: 500;
    color: var(--text-color);
    opacity: 0.7; /* 和图标的透明度保持一致 */
}

/* vvv 【新增】动态删除按钮的样式 vvv */
.delete-moment-btn {
    font-size: 20px; /* 设置一个合适的大小 */
    cursor: pointer;
    opacity: 0.5; /* 默认状态下稍微透明，不那么显眼 */
    transition: opacity 0.2s ease, transform 0.2s ease; /* 添加平滑过渡动画 */
}

.delete-moment-btn:hover {
    opacity: 1; /* 鼠标悬浮时完全显示 */
    transform: scale(1.1); /* 轻微放大，提供交互反馈 */
    color: #ff6b6b; /* 可以给一个危险操作的提示色 */
}

/* vvv 【新增】用于包裹作者信息的容器 vvv */
.post-author-group {
    display: flex;
    align-items: center;
    gap: 12px;
}

/* vvv 【核心修正】让 post-header 内部元素两端对齐 vvv */
.post-header {
    display: flex;
    align-items: center;
    /* 移除固定的 gap，改为两端对齐 */
    justify-content: space-between; 
}

/* vvv 【新增】聊天气泡时间戳的样式 vvv */
.message-timestamp {
    display: flex;         /* 【核心】使用 Flex 布局 */
    align-items: center;   /* 垂直居中对齐 */
    gap: 6px;              /* 在时间和状态之间增加一点间距 */
    font-size: 12px;
    color: var(--text-color);
    opacity: 0.6;
    margin-top: 5px;
    padding: 0 8px;
}

/* vvv 【新增】专门为用户的气泡设置反向排列 vvv */
.chat-message.user .message-timestamp {
    flex-direction: row-reverse; /* 【核心】反转内部元素的顺序 */
}

/* vvv 【新增】“送达/已读”状态的文字样式 vvv */
.message-status {
    /* 这个类暂时不需要特殊样式，它会继承父级的字体大小和颜色 */
    /* 我们先把它定义出来，方便未来做扩展，比如给“已读”加个特殊颜色 */
}

/* 
 * ===============================================
 * ===   新增：“表情包”功能 (轨道二) CSS       ===
 * ===============================================
*/

/* --- 表情包选择面板 --- */
#sticker-panel {
    flex-shrink: 0;
    
    /* vvv 【核心修改】应用和其他模块一致的毛玻璃效果 vvv */
    background: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    /* ^^^ 修改结束 ^^^ */

    border-top: var(--frosted-glass-border);
    height: 250px;
    display: none;
    flex-direction: column;
    transition: height 0.3s ease;
}

#sticker-panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    border-bottom: var(--frosted-glass-border);
    flex-shrink: 0;
}
#sticker-panel-header h3 {
    margin: 0;
    font-size: 14px;
    font-weight: 500;
    opacity: 0.8;
}

#sticker-grid-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    display: grid;
    /* 核心：自适应网格布局 */
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 15px;
}
#sticker-grid-container img {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: contain; /* 保证表情不变形 */
    cursor: pointer;
    transition: transform 0.2s ease;
    border-radius: 8px;
}
#sticker-grid-container img:hover {
    transform: scale(1.1);
}

/* 面板为空时的占位符 */
#sticker-grid-container .empty-placeholder {
    grid-column: 1 / -1; /* 占满整行 */
    text-align: center;
    opacity: 0.6;
    font-size: 14px;
    align-self: center; /* 垂直居中 */
}


/* --- 表情包管理弹窗 --- */
#sticker-manager-modal .modal-content,
#sticker-import-modal .modal-content {
    max-height: 80vh; /* 限制最大高度 */
    display: flex;
    flex-direction: column;
}

.sticker-manager-actions {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}

#sticker-manager-grid {
    flex-grow: 1;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 10px;
    background: var(--input-bg-color);
    padding: 10px;
    border-radius: 8px;
}

.sticker-manager-item {
    position: relative;
    aspect-ratio: 1 / 1;
}
.sticker-manager-item img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    border-radius: 4px;
}
.delete-sticker-btn {
    position: absolute;
    top: -5px;
    right: -5px;
    width: 20px;
    height: 20px;
    background-color: #ff3b30;
    color: white;
    border-radius: 50%;
    border: none;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 16px;
    line-height: 1;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

/* 批量导入文本域 */
#sticker-import-textarea {
    width: 100%;
    min-height: 200px;
    resize: vertical;
    padding: 10px;
    border-radius: 8px;
    border: none;
    background-color: var(--input-bg-color);
    color: var(--text-color);
    font-size: 14px;
    font-family: inherit;
    box-sizing: border-box;
}

/* 
 * ===============================================
 * ===   新增：“+”号功能面板 (轨道三) CSS       ===
 * ===============================================
*/

/* --- 功能面板容器 --- */
#chat-function-panel {
    flex-shrink: 0;
    
    /* 核心：复用和其他模块一致的毛玻璃效果 */
    background: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));

    border-top: var(--frosted-glass-border);
    height: 200px; /* 比表情包面板稍矮一些 */
    display: none; /* 默认隐藏 */
    
    /* 让内部的网格垂直居中 */
    flex-direction: column;
    justify-content: center;
    
    transition: height 0.3s ease;
}

/* --- 功能图标网格 --- */
.function-grid {
    width: 100%;
    padding: 20px;
    box-sizing: border-box;
    display: grid;
    /* 核心：创建一个最多4列的自适应网格 */
    grid-template-columns: repeat(4, 1fr);
    gap: 20px 15px; /* 行间距20px，列间距15px */
}

/* --- 单个功能项 (图标+文字) --- */
.function-item {
    display: flex;
    flex-direction: column; /* 图标在上，文字在下 */
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

/* --- 功能图标的背景方块 --- */
.function-icon-bg {
    width: 60px;
    height: 60px;
    background-color: var(--input-bg-color);
    border-radius: var(--icon-border-radius); /* 保持圆角统一 */
    
    /* 让图标在背景块中居中 */
    display: flex;
    justify-content: center;
    align-items: center;
    
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 鼠标悬浮时的放大和阴影效果 */
.function-item:hover .function-icon-bg {
    transform: scale(1.05);
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

/* --- 图标本身的大小 --- */
.function-item i {
    font-size: 32px;
}

/* --- 功能文字的样式 --- */
.function-item span {
    font-size: 12px;
    opacity: 0.8;
}

/* 
 * ===============================================
 * ===   新增：“模拟视频通话”功能 CSS         ===
 * ===============================================
*/

/* --- 视频通话浮层总容器 --- */
#video-call-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100dvh;
    z-index: 210; /* 比快拍查看器更高一级 */
    
    background-color: #1a1a1a;
    background-size: cover;
    background-position: center;
    
    display: none; /* 默认隐藏 */
    flex-direction: column;
    color: #FFFFFF;
    
    opacity: 0;
    transform: translateY(30px);
    transition: opacity 0.4s ease, transform 0.4s ease;
}

#video-call-overlay.visible {
    display: flex;
    opacity: 1;
    transform: translateY(0);
}

/* 背景上的模糊遮罩层 */
#video-call-overlay::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}
/* --- 左上角通话信息 --- */
.video-call-header {
    position: absolute;
    top: 60px; /* 避开状态栏 */
    left: 20px;
    z-index: 1;
    display: flex;
    align-items: center;
    gap: 10px;
    
    /* 默认隐藏，连接成功后显示 */
    opacity: 0;
    transition: opacity 0.3s ease;
}
#video-call-overlay:not(.connecting) .video-call-header {
    opacity: 1;
}

#video-call-character-avatar-small {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
    border: 1px solid rgba(255, 255, 255, 0.5);
}

.video-call-time-info {
    display: flex;
    flex-direction: column;
    color: #FFFFFF;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

#video-call-timer-label {
    font-size: 15px;
    font-weight: 500;
}

#video-call-timer {
    font-size: 13px;
    opacity: 0.8;
}
/* --- 右上角用户小窗 --- */
.video-call-user-view {
    position: absolute;
    top: 50px; /* 避开状态栏 */
    right: 20px;
    width: 100px;
    height: 150px;
    background: var(--input-bg-color);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    overflow: hidden;
    z-index: 1;
}
#video-call-user-avatar {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* --- 字幕与提示区域 --- */
.video-call-subtitles-container {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* 让内容从底部开始往上堆叠 */
    padding: 20px;
    padding-bottom: 90px; /* 为底部控制栏留出空间 */
    position: relative;
    z-index: 1;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
}
#video-call-status-text, #video-call-typing-indicator {
    text-align: center;
    font-size: 16px;
    opacity: 0.8;
    margin-bottom: 15px;
    display: none; /* 默认都隐藏 */
}

#video-call-script-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: flex-start; /* 改为靠左对齐 */
    text-align: left;        /* 改为文字左对齐 */
    overflow-y: auto;        /* 当内容过多时允许滚动 */
    padding-right: 10px;     /* 为滚动条留出空间 */
}
/* 为滚动条添加样式 */
#video-call-script-container::-webkit-scrollbar { width: 4px; }
#video-call-script-container::-webkit-scrollbar-thumb { background-color: rgba(255, 255, 255, 0.4); border-radius: 4px; }

/* 剧本内容的样式 (将在JS中动态添加) */
.script-line { line-height: 1.6; }
.script-line.action { opacity: 0.7; font-size: 15px; }
.script-line.thought { font-style: italic; font-size: 15px; }
.script-line.dialogue { font-weight: 500; font-size: 18px; }

/* --- 底部控制栏 --- */
.video-call-controls {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1;
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px 20px 30px 20px; /* 底部留出安全区 */
    background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
}
#video-call-input {
    flex-grow: 1;
    padding: 12px 18px;
    border: 1.5px solid rgba(255, 255, 255, 0.5);
    border-radius: 25px;
    background-color: rgba(255, 255, 255, 0.1);
    color: #FFFFFF;
    font-size: 15px;
    transition: all 0.2s ease;
}
#video-call-input::placeholder { color: rgba(255, 255, 255, 0.6); }
#video-call-input:disabled {
    opacity: 0.5;
    background-color: rgba(0, 0, 0, 0.2);
    border-color: rgba(255, 255, 255, 0.2);
}
#video-call-send-btn {
    flex-shrink: 0;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    color: var(--text-color);
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.2s ease;
    
    /* --- 【升级版】毛玻璃效果核心 --- */
    background: rgba(255, 255, 255, 0.2); /* 浅灰色透明背景 */
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: 1px solid rgba(255, 255, 255, 0.2); /* 匹配的边框 */
    
    /* 默认隐藏，在连接成功后显示 */
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
}
#video-call-overlay:not(.connecting) #video-call-send-btn {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
}
#video-call-action-btn {
    flex-shrink: 0;
    width: 70px;
    height: 48px;
    border-radius: 25px;
    color: white;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;

    /* --- 【升级版】毛玻璃效果核心 --- */
    background-color: rgba(255, 59, 48, 0.5); /* 更透明的浅红色 */
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: 1px solid rgba(255, 59, 48, 0.3); /* 匹配的更透明的边框 */
}
#video-call-action-btn:hover { background-color: #c70000; }

/* --- 连接中状态的特殊样式 --- */
#video-call-overlay.connecting #video-call-status-text {
    display: block; /* 只在连接中显示“连接中...” */
}

/* --- 【新增】字幕框样式 --- */
.subtitles-box {
    width: 100%;
    max-height: 40vh; /* 字幕区最大高度不超过屏幕的40% */
    overflow-y: auto; /* 内容超出时自动显示滚动条 */
    padding: 15px;
    box-sizing: border-box;
    
    background: rgba(0, 0, 0, 0.4); /* 半透明黑色背景 */
    border-radius: 12px; /* 圆角 */
    
    /* 让内部的 script-container 继承 flex 布局 */
    display: flex;
    flex-direction: column;
}

/* 调整 script-container 的样式以适应新布局 */
#video-call-script-container {
    width: 100%; /* 宽度撑满字幕框 */
    max-height: none; /* 解除之前的高度限制 */
    overflow-y: visible; /* 不再需要自己滚动，由父级 subtitles-box 负责 */
}

/* 滚动条美化 (复用之前的样式) */
.subtitles-box::-webkit-scrollbar { width: 4px; }
.subtitles-box::-webkit-scrollbar-thumb { background-color: rgba(255, 255, 255, 0.4); border-radius: 4px; }

/* 调整“连接中”和“说话中”提示的样式 */
#video-call-status-text {
    padding: 20px 0;
    margin-bottom: 0;
}
#video-call-typing-indicator {
    /* 让它在字幕框下方显示，并增加一点间距 */
    margin-top: 10px; 
    text-align: left; /* 与字幕框内的文字对齐 */
    padding-left: 15px; /* 增加一点左内边距，看起来更协调 */
}

/* (在视频通话CSS部分的末尾添加) */

/* --- 【新增】说话人名字样式 --- */
.script-line .speaker-name {
    font-weight: 600; /* 让名字加粗，更突出 */
    margin-right: 8px; /* 名字和对话内容之间留出一点空隙 */
}

/* 角色名字的颜色 */
.script-line .speaker-name.character {
    color: #A19EAD; /* 占位符颜色：柔和的蓝色，您可以替换它 */
}

/* 用户名字("我")的颜色 */
.script-line .speaker-name.user {
    color: #DDCFDC; /* 占位符颜色：清新的薄荷绿，您可以替换它 */
}

/* --- 【新增】对话回合分割线样式 --- */
.script-divider {
    width: 80%; /* 分割线宽度为字幕框的80% */
    margin: 15px auto; /* 上下留出15px间距，并水平居中 */
    border: none; /* 移除默认边框 */
    height: 1px; /* 分割线高度 */
    
    /* 使用渐变来创建中间实、两边淡出的效果 */
    background: linear-gradient(to right, 
        transparent, 
        rgba(255, 255, 255, 0.3) 50%, 
        transparent
    );
}

/* 
 * ===============================================
 * ===   新增：“视频来电横幅” CSS             ===
 * ===============================================
*/

#incoming-call-banner {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translate(-50%, -150%);
    width: 95%;
    max-width: 450px;
    z-index: 250;
    
    /* --- 【核心升级】毛玻璃背景 --- */
    background: var(--frosted-glass-bg); /* 复用您全局的毛玻璃背景变量 */
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: var(--frosted-glass-border);
    /* --- 升级结束 --- */

    border-radius: var(--widget-border-radius);
    box-shadow: 0 8px 30px rgba(0,0,0,0.3);
    
    transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1);
}

#incoming-call-banner.visible {
    transform: translate(-50%, 0); /* 可见状态，滑入屏幕 */
}

.call-banner-content {
    padding: 18px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* --- 左侧信息区 --- */
.caller-info {
    display: flex;
    align-items: center;
    gap: 12px;
    color: #FFFFFF;
}
#caller-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
}
.caller-details {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
#caller-name {
    font-size: 18px;
    font-weight: 600;
}
#call-type {
    font-size: 14px;
    opacity: 0.6;
}

/* --- 右侧按钮区 --- */
.call-actions {
    display: flex;
    align-items: center;
    gap: 20px;
}
.call-action-btn {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    color: #FFFFFF;
    font-size: 28px;
    display: flex;
    justify-content: center;
    align-items: center;
    
    /* 毛玻璃效果核心 */
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    
    transition: transform 0.2s ease, background-color 0.2s ease;
}
.call-action-btn:hover {
    transform: scale(1.05);
}

/* 拒绝按钮 (红色) */
.call-action-btn.decline {
    background-color: rgba(255, 59, 48, 0.6); /* 半透明红色 */
    border: 1px solid rgba(255, 59, 48, 0.4);
}
.call-action-btn.decline i {
    transform: rotate(135deg); /* 让电话图标变成挂断的样子 */
}

/* 接听按钮 (绿色) */
.call-action-btn.accept {
    background-color: rgba(52, 199, 89, 0.6); /* 半透明绿色 */
    border: 1px solid rgba(52, 199, 89, 0.4);
}

/* 
 * ===============================================
 * ===   新增：“模拟语音条”功能 CSS           ===
 * ===============================================
*/

/* --- 语音消息气泡的特殊样式 --- */
/* 我们复用 .bubble 的基础样式，只在这里添加或覆盖特定样式 */
.bubble.voice-bubble {
    padding: 8px 12px; /* 减小内边距 */
    display: flex;
    align-items: center;
    gap: 8px; /* 减小元素间距 */
    cursor: pointer;
    min-width: 100px; /* 减小最小宽度 */
}

/* 播放图标 */
.voice-bubble .play-icon {
    font-size: 20px; /* 减小图标尺寸 */
    flex-shrink: 0;
}

/* 声波图容器 */
.sound-wave {
    flex-grow: 1;
    display: flex;
    align-items: center;
    gap: 2px;
    height: 24px; /* 减小声波图整体高度 */
}

/* 声波图的每一根“条” */
.sound-wave .bar {
    background-color: currentColor;
    width: 2.5px; /* 可以适当加粗一点点，质感更好 */
    border-radius: 2px;
    opacity: 0.8;
}

/* 语音时长文本 (位于气泡内部时) */
.voice-bubble .duration-text {
    font-size: 13px; /* 减小字号 */
    opacity: 0.8;
    flex-shrink: 0;
    margin-left: auto;
    padding-left: 8px; /* 减小左侧间距 */
}

/* --- 转写的文字区域 --- */
.transcription-text {
    font-size: 14px; /* 减小字号以匹配整体风格 */
    line-height: 1.5;
    padding: 8px 12px; /* 减小内边距 */
    margin-top: 5px;
    border-radius: 10px; /* 减小圆角 */
    background-color: var(--input-bg-color);
    display: none; 
}
    
    /* 默认隐藏，通过 JS 控制显示 */
    display: none; 
}

/* 
 * ===============================================
 * ===   “模拟转账”功能 CSS (V2 最终版)       ===
 * ===============================================
*/

/* --- 转账卡片容器 (它自己就是一个 bubble-wrapper) --- */
.transfer-card-wrapper {
    display: flex;
    flex-direction: column;
    gap: 3px;
    align-items: flex-start; /* 角色发的靠左 */
}
.chat-message.user .transfer-card-wrapper {
    align-items: flex-end; /* 用户发的靠右 */
}

/* --- 转账卡片本身 --- */
.transfer-card {
    /* 核心：应用您全局的毛玻璃样式 */
    background: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: var(--frosted-glass-border);

    border-radius: var(--widget-border-radius);
    padding: 15px;
    width: 280px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 12px;
    transition: opacity 0.3s ease, background 0.3s ease; /* 增加 background 过渡 */
}
.chat-message.character .transfer-card {
    color: var(--text-color);
}
.chat-message.user .transfer-card {
    /* 核心：复用和用户聊天气泡一致的浅色背景，并添加毛玻璃效果 */
    background: rgba(229, 229, 234, 0.8);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border-color: transparent; /* 浅色背景下，边框可以更柔和 */
    color: #000000;
}

/* 上半部分 */
.transfer-top { display: flex; justify-content: space-between; align-items: center; }
.transfer-info { display: flex; align-items: center; gap: 12px; }
.transfer-info i { font-size: 32px; opacity: 0.8; }
.transfer-title { font-size: 16px; font-weight: 500; }
.transfer-amount { font-size: 28px; font-weight: 600; text-align: right; }
.transfer-amount .currency { font-size: 16px; font-weight: 500; margin-left: 4px; opacity: 0.8; }

/* 中间虚线 */
.transfer-divider {
    width: 100%;
    height: 0;
    border: none;
    border-top: 2px dashed rgba(255, 255, 255, 0.3);
    margin: 0;
    padding: 0;
}
/* 用户发送的卡片的虚线颜色 */
.chat-message.user .transfer-divider {
    border-top-color: rgba(0, 0, 0, 0.3);
}
/* 【新增】浅色模式下，角色发送的卡片的虚线颜色 */
body.light-mode .chat-message.character .transfer-divider {
    border-top-color: rgba(0, 0, 0, 0.2);
}

/* 下半部分 (留言) */
.transfer-memo { font-size: 14px; opacity: 0.8; }

/* 【新增】底部状态文本的样式 */
.transfer-status-text {
    font-size: 13px;
    font-weight: 500;
    opacity: 0.8;
    margin-top: -5px;
}

/* --- 交互状态 --- */
/* 待处理状态 (双方通用) */
.transfer-card.status-pending {
    cursor: default; /* 默认不可点击 */
}
/* 只有角色发的待处理卡片，用户才能点 */
.chat-message.character .transfer-card.status-pending {
    cursor: pointer;
}

/* 已收款状态 */
.transfer-card.status-accepted {
    opacity: 0.7;
    cursor: default;
}

/* 已退回状态 */
.transfer-card.status-declined {
    cursor: default;
    background: rgba(128, 128, 128, 0.4); /* 灰色背景表示已失效 */
}
.chat-message.user .transfer-card.status-declined {
    background: rgba(200, 200, 200, 0.6);
}

/* 
 * ===============================================
 * ===   “钱包”功能CSS (V2 - 浮窗+筛选版)       ===
 * ===============================================
*/

/* --- 钱包浮窗的特殊尺寸 --- */
#wallet-modal-content {
    width: 95%;
    max-width: 420px; /* 比普通弹窗稍宽 */
    max-height: 85vh; /* 允许更高的高度 */
    display: flex;
    flex-direction: column;
}

/* --- 钱包主内容容器 --- */
#wallet-content-container {
    padding: 15px 5px; /* 调整内边距 */
    display: flex;
    flex-direction: column;
    gap: 20px;
    /* 【核心】让内容区可以滚动 */
    overflow-y: auto;
    flex-grow: 1;
    min-height: 0;
}

/* --- 总资产卡片 (移除渐变，改为统一风格) --- */
#total-assets-card {
    flex-shrink: 0;
    padding: 20px;
    border-radius: var(--icon-border-radius);
    background: var(--button-bg-color); /* 复用全局背景 */
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.assets-header { font-size: 14px; opacity: 0.7; }
.assets-balance { font-size: 32px; font-weight: 600; }

/* --- 交易明细 --- */
#transaction-history-section {
    flex-grow: 1; display: flex; flex-direction: column; min-height: 0;
}

/* --- 【新增】筛选标签样式 --- */
#transaction-filter-tabs {
    display: flex;
    background: var(--input-bg-color);
    border-radius: 10px;
    padding: 4px;
    margin-bottom: 20px;
    flex-shrink: 0;
}
.filter-tab {
    flex: 1;
    padding: 8px;
    border: none;
    background: transparent;
    color: var(--text-color);
    opacity: 0.6;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
}
.filter-tab.active {
    background: var(--button-bg-color);
    opacity: 1;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

#transaction-list {
    list-style: none; padding: 0; margin: 0;
    overflow-y: auto; display: flex; flex-direction: column; gap: 10px;
}
#transaction-list .empty-placeholder { text-align: center; padding: 40px 20px; opacity: 0.6; }

.transaction-item {
    display: flex; align-items: center; padding: 12px;
    background: var(--input-bg-color); /* 调整背景色以突出 */
    border-radius: var(--icon-border-radius); gap: 15px;
}

.transaction-icon {
    width: 38px; height: 38px; border-radius: 50%;
    flex-shrink: 0; display: flex; justify-content: center; align-items: center; font-size: 20px;
}
.transaction-item.income .transaction-icon { background: rgba(46, 204, 113, 0.2); color: #2ecc71; }
.transaction-item.expense .transaction-icon { background: rgba(231, 76, 60, 0.2); color: #e74c3c; }

.transaction-details { flex-grow: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0; }
.transaction-details .counterparty { font-size: 15px; font-weight: 500; }
.transaction-details .timestamp { font-size: 12px; opacity: 0.6; }

.transaction-amount { font-size: 15px; font-weight: 600; white-space: nowrap; }
.transaction-item.income .transaction-amount { color: #2ecc71; }
.transaction-item.expense .transaction-amount { color: #e74c3c; }

/* 
 * =======================================================
 * ===   “星座运势”功能CSS (V5 - 最终布局修复版)       ===
 * =======================================================
*/

/* --- 浮窗和包裹容器的样式 (保持不变) --- */
#horoscope-modal-content { max-width: 380px; gap: 15px; }
#horoscope-preview-container { min-height: 150px; display: flex; justify-content: center; align-items: center; color: var(--text-color); opacity: 0.5; }
.horoscope-card-wrapper { display: flex; flex-direction: column; gap: 3px; }
.chat-message.user .horoscope-card-wrapper { align-items: flex-end; }

/* --- 【核心修正】运势卡片本身的样式 --- */
.horoscope-card {
    width: 320px;
    padding: 20px;
    box-sizing: border-box;
    border-radius: var(--widget-border-radius);
    background: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: var(--frosted-glass-border);
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    gap: 18px; /* <-- 修改：增大整体垂直间距 */
    box-shadow: 0 5px 20px rgba(0,0,0,0.1);
}

/* --- 【核心修正】卡片内部所有元素的样式，恢复布局和间距 --- */
.horoscope-card .horoscope-header {
    display: flex; justify-content: space-between; align-items: center;
    padding-bottom: 12px; /* 增加头部下方的间距 */
    border-bottom: 1px solid var(--frosted-glass-border);
}
.horoscope-card .horoscope-title { font-size: 16px; font-weight: 600; }
.horoscope-card .horoscope-zodiac { opacity: 0.8; }

.horoscope-card .horoscope-rating { font-size: 18px; letter-spacing: 2px; }
.horoscope-card .horoscope-rating .filled { color: #FFD700; } /* 金色星星 */

/* 【关键】恢复分类运势的Flex布局 */
.horoscope-card .horoscope-details {
    display: flex;
    flex-direction: column;
    gap: 12px; /* 设置每行之间的垂直间距 */
}
.horoscope-card .fortune-item {
    display: flex; /* 让标签和描述在同一行显示 */
    align-items: flex-start;
    gap: 8px; /* 设置标签和描述之间的水平间距 */
    font-size: 14px;
    line-height: 1.5; /* 增加行高，防止文字太挤 */
}
.horoscope-card .fortune-item .label {
    font-weight: 500;
    opacity: 0.7;
    flex-shrink: 0; /* 防止标签被压缩 */
}

.horoscope-card .horoscope-charm {
    font-size: 14px;
    text-align: center;
    padding: 10px; /* 增加内边距 */
    background: var(--input-bg-color);
    border-radius: 8px;
}

.horoscope-card .horoscope-quote {
    font-size: 14px;
    font-style: italic;
    line-height: 1.6;
    padding-top: 15px; /* 增加寄语上方的间距 */
    margin-top: 5px;
    opacity: 0.9;
    border-top: 1px dashed var(--frosted-glass-border);
}

/* 
 * ===============================================
 * ===   “心事”功能专属CSS (V2 - 精装版)       ===
 * ===============================================
*/

/* --- 写心事页面的整体布局微调 --- */
#secrets-creation-page .action-buttons {
    padding: 20px 15px !important; /* 增大按钮区域的上下边距 */
}

/* --- 【核心】“信笺卡片”容器样式 --- */
.secret-writing-card {
    flex-grow: 1; /* 让卡片填满中间的可用空间 */
    min-height: 0; /* flex布局中的重要修复 */
    
    /* 核心：应用您全局的毛玻璃效果！ */
    background: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: var(--frosted-glass-border);
    
    border-radius: var(--widget-border-radius); /* 保持圆角统一 */
    box-shadow: 0 8px 30px rgba(0,0,0,0.2);
    
    padding: 20px;
    display: flex;
    flex-direction: column; /* 内部元素垂直排列 */
    gap: 15px; /* 元素之间的间距 */
}

/* --- 标题输入框样式 --- */
#secret-title-input {
    background: transparent;
    border: none;
    border-bottom: 1px solid var(--frosted-glass-border); /* 只有一条下划线 */
    color: var(--text-color);
    font-size: 20px; /* 更大的字号 */
    font-weight: 600;
    padding: 10px 5px;
    flex-shrink: 0; /* 防止被压缩 */
}
#secret-title-input:focus {
    outline: none;
    border-bottom-color: var(--text-color);
}
#secret-title-input::placeholder {
    color: var(--text-color);
    opacity: 0.5;
}

/* --- 分隔线样式 (修正版) --- */
.secret-divider {
    border: none;
    /* 核心修正：直接定义边框颜色，不再使用变量 */
    border-top: 1px solid rgba(255, 255, 255, 0.1); 
    margin: -5px 0;
    flex-shrink: 0;
}

/* 【新增】为浅色模式下的分割线也定义一个颜色 */
body.light-mode .secret-divider {
    border-top-color: rgba(0, 0, 0, 0.1);
}

/* --- 内容输入框样式 (保留书写感) --- */
#secret-content-input {
    flex-grow: 1; /* 填满剩余空间 */
    background: transparent;
    border: none;
    resize: none;
    color: var(--text-color);
    font-size: 16px;
    line-height: 1.7;
    font-family: "仿宋", "KaiTi", "BiauKai", "楷体", serif;
}
#secret-content-input:focus {
    outline: none;
}
#secret-content-input::placeholder {
    color: var(--text-color);
    opacity: 0.5;
}

/* --- 【新增】情感印记/心情选择器样式 --- */
.mood-selector {
    display: flex;
    justify-content: space-around;
    padding-top: 15px;
    border-top: 1px solid var(--frosted-glass-border);
    flex-shrink: 0;
}
.mood-item {
    font-size: 28px;
    cursor: pointer;
    opacity: 0.4;
    transition: opacity 0.2s, transform 0.2s;
}
.mood-item:hover {
    opacity: 0.7;
    transform: scale(1.1);
}
.mood-item.active {
    opacity: 1;
    transform: scale(1.2);
    color: #799181; /* 激活时使用高亮色 */
}

/* --- 【核心修正】发布按钮样式 --- */
#publish-secret-btn {
    width: 100%;
    padding: 15px;
    border-radius: 12px;
    font-size: 16px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    
    /* 关键：使用您全局的按钮背景色变量！ */
    background-color: var(--button-bg-color);
    color: var(--text-color);
    
    transition: transform 0.2s;
}
#publish-secret-btn:hover {
    transform: scale(1.02);
}

/* 
 * =======================================================
 * ===   “心事卡片”CSS (V2 - 左右布局版)              ===
 * =======================================================
*/

/* --- 单张心事卡片的容器样式 --- */
.secret-card {
    /* 不再使用全局毛玻璃，而是自定义背景 */
    border-radius: var(--icon-border-radius);
    padding: 15px 20px;
    
    display: flex;
    flex-direction: column;
    gap: 12px;
    
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    
    max-width: 100%; /* 卡片最大宽度为屏幕的85% */
    align-self: center;
    margin-bottom: 15px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}
.secret-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.15);
}

/* --- 【核心】区分用户和角色的样式 (V3 - 专属颜色版) --- */

/* 用户发布的卡片 (靠右，使用全新的专属颜色) */
.secret-card.user {
    
    /* 关键：使用我们新定义的专属颜色变量！ */
    background-color: var(--user-secret-card-bg); 
    
    /* 为了保证在两种背景下文字都清晰，我们固定文字颜色 */
    color: var(--text-color); /* 在深色模式下是白色，浅色模式下是黑色，完美适配 */
    
    /* 边框也跟随文字颜色变化 */
    border: 1px solid rgba(var(--text-color-rgb, 255, 255, 255), 0.1);
}
/* 我们需要为 --text-color 创建一个RGB版本，方便设置透明度 */
:root { --text-color-rgb: 255, 255, 255; }
body.light-mode { --text-color-rgb: 0, 0, 0; }

.secret-card.user .secret-card-header,
.secret-card.user .secret-card-footer {
    border-color: rgba(var(--text-color-rgb), 0.15); /* 分割线颜色也动态变化 */
}

/* 角色发布的卡片 (靠左，完全复用系统现有的毛玻璃样式) */
.secret-card.character {
    
    /* 关键：使用您系统全局的毛玻璃背景变量 */
    background-color: var(--frosted-glass-bg); 
    color: var(--text-color);
    border: var(--frosted-glass-border);
}

.secret-card.character .secret-card-header,
.secret-card.character .secret-card-footer {
    border-color: var(--frosted-glass-border);
}

/* --- 卡片内部结构 (保持不变，但颜色会根据父级变化) --- */
.secret-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid; /* 颜色由父级决定 */
    padding-bottom: 10px;
}
.secret-card-title { font-weight: 600; font-size: 16px; }
.secret-card-header i { font-size: 22px; opacity: 0.8; }
.secret-card-preview {
    margin: 0; font-size: 14px; line-height: 1.6; opacity: 0.9;
    display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;  
    overflow: hidden;
}
.secret-card-footer {
    padding-top: 10px; text-align: right; font-size: 12px; opacity: 0.7;
    /* 【新增】给底部也加上分割线，更有包裹感 */
    border-top: 1px solid; 
}

/* 
 * =======================================================
 * ===   新增：“心事详情页浮窗” 的专属CSS样式         ===
 * =======================================================
*/

/* --- 原始心事内容的容器样式 --- */
#original-secret-container {
    background: var(--input-bg-color); /* 使用一个柔和的背景色 */
    border-radius: var(--icon-border-radius);
    padding: 15px 20px;
    /* 这里可以复用 .secret-card 的一些内部样式 */
    display: flex;
    flex-direction: column;
    gap: 12px;
}
/* 我们会用JS把之前设计的卡片内容直接放进来 */


/* --- 互动评论区的容器 --- */
#secret-comments-container {
    display: flex;
    flex-direction: column;
    gap: 20px; /* 增大每条回应之间的间距，更有呼吸感 */
}

/* --- 【核心】单条回应/批注的样式 --- */
.secret-comment-item {
    display: flex;
    flex-direction: column; /* 头部和内容垂直排列 */
    gap: 8px;
    
    /* 用左侧的装饰性边框来区分作者，而非左右布局 */
    padding-left: 15px;
    border-left: 3px solid; /* 颜色将在下面定义 */
}

/* --- 区分用户和角色的边框颜色 --- */
/* 用户的回应，使用您喜欢的 Water Moss 色 */
.secret-comment-item.user {
    border-left-color: #799181;
}
/* 角色的回应，使用一个柔和的、中性的颜色 */
.secret-comment-item.character {
    border-left-color: rgba(var(--text-color-rgb), 0.4);
}

/* --- 回应的头部：作者 + 时间 --- */
.secret-comment-header {
    display: flex;
    justify-content: space-between; /* 名字靠左，时间靠右 */
    align-items: center;
}
.secret-comment-author {
    font-weight: 600;
    font-size: 15px;
}
.secret-comment-timestamp {
    font-size: 12px;
    opacity: 0.6;
}

/* --- 回应的文本内容 --- */
.secret-comment-text {
    font-size: 15px;
    line-height: 1.7; /* 保持和书写时一致的舒适行距 */
    opacity: 0.9;
    /* 【灵魂】同样使用书写感的字体 */
    font-family: "仿宋", "KaiTi", "BiauKai", "楷体", serif;
}

/* --- 底部输入栏的容器样式 --- */
#secret-details-modal .chat-input-bar {
    flex-shrink: 0;
    padding: 20px;
    
    /* --- 【最终、决定性修正】--- */
    /* 使用 !important 强制将背景设置为透明，覆盖任何通用规则！*/
    background: transparent !important; 
    
    /* 我们也顺便强化一下 backdrop-filter，确保它不被通用规则干扰 */
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    
    display: flex;
    align-items: center;
    gap: 12px;
    border-radius: 0 0 var(--widget-border-radius) var(--widget-border-radius);
    
    /* 【新增】确保顶部的边框也被移除 */
    border-top: none !important;
}

/* --- 输入框本身的样式 --- */
#secret-details-modal #secret-comment-input {
    flex-grow: 1;
    border: none;
    resize: none;
    font-size: 15px;
    line-height: 1.4;
    
    /* 核心修正2: 将高度从固定的 48px 改为自适应，由内边距决定 */
    height: auto; 
    padding: 14px 18px; /* 这是决定最终高度的关键 */

    border-radius: 12px;
    
    background-color: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    
    border: 1.5px solid var(--frosted-glass-border); 
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);

    color: var(--text-color);
}
#secret-details-modal #secret-comment-input:focus {
    outline: none;
    border-color: rgba(var(--text-color-rgb), 0.3);
}

/* --- 发送按钮的样式 (保持不变，已经很完美了) --- */
#secret-details-modal #send-secret-comment-btn {
    font-size: 28px; /* 轻微减小图标尺寸，让它在圆形背景里更协调 */
    color: var(--text-color);
    opacity: 0.9;
    
    /* --- 【核心修正】从实色背景改为透明毛玻璃 --- */
    background: transparent; /* 移除旧的实色背景 */
    
    width: 48px;
    height: 48px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    
    transition: transform 0.2s, background 0.2s; /* 增加 background 过渡 */
    
    /* 我们不再需要 flex-shrink: 0，因为按钮现在是 button 元素 */
}

/* 【新增】为按钮添加鼠标悬浮时的背景高亮效果 */
#secret-details-modal #send-secret-comment-btn:hover {
    opacity: 1;
    transform: scale(1.05);
    /* 鼠标悬浮时，出现一个淡淡的毛玻璃背景作为反馈 */
    background: var(--button-bg-color); 
}

/* 
 * =======================================================
 * ===   新增：“心事卡片删除按钮” 的专属CSS样式      ===
 * =======================================================
*/

/* --- 让卡片本身变成一个相对定位的容器 --- */
.secret-card {
    position: relative; /* 这是让内部绝对定位生效的关键 */
    padding-bottom: 40px; /* 为底部的删除按钮和时间戳留出更多空间 */
}

/* --- 删除按钮的样式 --- */
.delete-secret-btn {
    position: absolute; /* 绝对定位，相对于 .secret-card */
    bottom: 15px;       /* 距离卡片底部15px */
    left: 20px;         /* 距离卡片左侧20px */
    
    font-size: 20px;
    color: var(--text-color);
    opacity: 0.5; /* 默认状态下稍微透明，不那么抢眼 */
    cursor: pointer;
    
    transition: opacity 0.2s ease, transform 0.2s ease, color 0.2s ease;
}

/* 鼠标悬浮时，图标变清晰、变大、变红 */
.delete-secret-btn:hover {
    opacity: 1;
    transform: scale(1.1);
    color: #ff6b6b; /* 危险操作的红色 */
}

/* 
 * =======================================================
 * ===   “双向批注”功能CSS (V1)                       ===
 * =======================================================
*/

/* --- 回应头部的右侧操作区 --- */
.secret-comment-header .comment-actions {
    display: flex;
    align-items: center;
    gap: 12px; /* 让回复按钮和时间戳之间有间距 */
    margin-left: auto; /* 【关键】让整个操作区自动靠右 */
}

/* --- 回复按钮的样式 --- */
.reply-to-comment-btn {
    font-size: 18px;
    opacity: 0.5;
    cursor: pointer;
    transition: opacity 0.2s, color 0.2s;
}
.reply-to-comment-btn:hover {
    opacity: 1;
    color: #799181; /* 使用您喜欢的 Water Moss 作为高亮色 */
}

/* --- 【核心】用户回应的专属右边框样式 --- */
.secret-comment-item.user {
    /* 移除左边框 */
    border-left: none; 
    
    /* 增加右边框 */
    padding-left: 0; /* 移除左内边距 */
    padding-right: 15px;
    border-right: 3px solid #799181; /* 使用 Water Moss 色 */
}

/* 
 * ===============================================
 * ===   新增：“主题切换浮窗” 的专属CSS样式     ===
 * ===============================================
*/
.theme-popover {
    position: absolute;
    top: 65px; /* 定位在状态栏下方 */
    right: 25px; /* 右侧对齐 */
    z-index: 200; /* 确保在顶层 */
    
    /* 复用您全局的毛玻璃样式 */
    background: var(--frosted-glass-bg);
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border: var(--frosted-glass-border);
    border-radius: 12px; /* 小一点的圆角更精致 */
    
    padding: 8px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    
    display: flex;
    flex-direction: column;
    gap: 5px;
    
    /* 核心：默认隐藏，并通过动画实现平滑过渡 */
    opacity: 0;
    transform: scale(0.95) translateY(-10px);
    pointer-events: none;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
}

.theme-popover.visible {
    opacity: 1;
    transform: scale(1) translateY(0);
    pointer-events: auto;
}

.theme-popover .popover-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 15px;
    cursor: pointer;
    border-radius: 8px;
    transition: background-color 0.2s;
    color: var(--text-color);
}
.theme-popover .popover-item:hover {
    background-color: var(--button-bg-color);
}

/* 
 * =======================================================
 * ===   “回忆”板块专属UI CSS (V3 - 宝丽来相册版)      ===
 * =======================================================
*/

/* --- 引入一款优雅的手写体字体 (可选，但强烈推荐) --- */
@import url('https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&display=swap');

/* --- 1. 角色选择页：宝丽来照片墙 --- */
#memory-polaroid-grid {
    display: grid;
    /* 核心：创建一个自适应的两列网格布局 */
    grid-template-columns: repeat(2, 1fr);
    gap: 25px 20px; /* 行间距 和 列间距 */
    padding: 25px;
}

.polaroid-card {
    background-color: #f0e9e4; /* 一种温暖的、做旧的米白色 */
    border: 1px solid rgba(0,0,0,0.1);
    padding: 12px 12px 20px 12px; /* 底部留白更多，是宝丽来的精髓 */
    box-shadow: 3px 3px 12px rgba(0,0,0,0.15);
    cursor: pointer;
    
    display: flex;
    flex-direction: column;
    gap: 12px;
    
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 【灵魂】为照片添加随机、自然的倾斜角度 */
.polaroid-card:nth-child(4n+1) { transform: rotate(-4deg); }
.polaroid-card:nth-child(4n+2) { transform: rotate(3deg); }
.polaroid-card:nth-child(4n+3) { transform: rotate(5deg); }
.polaroid-card:nth-child(4n) { transform: rotate(-2deg); }

/* 鼠标悬浮时，照片“浮起”并摆正，方便点击 */
.polaroid-card:hover {
    transform: scale(1.08) rotate(0deg) !important; /* !important 强制覆盖倾斜 */
    box-shadow: 0 15px 30px rgba(0,0,0,0.2);
    z-index: 10;
}

.polaroid-image {
    background-color: #333;
    background-size: cover;
    background-position: center;
    width: 100%;
    aspect-ratio: 1 / 1;
    /* 给照片内容增加一点内阴影，更有质感 */
    box-shadow: inset 0 0 8px rgba(0,0,0,0.3);
}

.polaroid-caption {
    font-family: 'Kalam', cursive; /* 使用我们引入的手写体 */
    color: #444;
    text-align: center;
    font-size: 16px;
    font-weight: 700;
}

/* --- 2. 回忆详情页：剪贴簿风格 --- */
/* 【灵魂】为详情页的背景添加一种纸张的质感 */
#memory-details-page {
    background-color: #dcd8d0; /* 一种牛皮纸或剪贴簿的颜色 */
}

/* 【最终修正】使用统一的新 ID 作为容器选择器 */
#memory-scrapbook-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

/* 回忆卡片，现在看起来像被贴上去的便签 */
.memory-card {
    /* 不再使用毛玻璃，而是用纯色和阴影模拟纸片 */
    background: #f5f2ed; /* 比宝丽来更白一些的纸张颜色 */
    border-radius: 8px;
    padding: 15px 20px;
    box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
    
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.memory-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 8px;
    /* 用虚线代替实线，更有手作感 */
    border-bottom: 1px dashed rgba(0,0,0,0.2);
}
.memory-card-title {
    font-size: 16px;
    font-weight: 600;
    font-family: 'Kalam', cursive; /* 标题也用手写体 */
    color: #333;
}
.memory-card-header i {
    font-size: 18px;
    color: #888;
}
.memory-card-timestamp {
    font-size: 12px;
    color: #777;
}
.memory-card-summary {
    font-size: 14px;
    line-height: 1.7;
    color: #555;
    white-space: pre-wrap;
    word-break: break-word;
}

/* vvv 【新增】回忆卡片删除按钮的样式 vvv */
.delete-memory-btn {
    font-size: 20px; /* 稍微增大图标，方便点击 */
    color: #999;     /* 使用一个更柔和的灰色 */
    cursor: pointer;
    transition: color 0.2s ease, transform 0.2s ease; /* 平滑过渡动画 */
}

.delete-memory-btn:hover {
    color: #ff6b6b; /* 鼠标悬浮时变为危险的红色 */
    transform: scale(1.1); /* 轻微放大，提供交互反馈 */
}

/* 
 * =======================================================
 * ===   “电影模式”专属UI CSS (V2 - 文本样式增强版)    ===
 * =======================================================
*/

/* --- 1. “选角大厅” (角色海报墙) 的样式 (保持不变) --- */
#movie-poster-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 25px 20px;
    padding: 25px;
    overflow-y: auto;
}

/* --- 优化后的新代码 --- */

.movie-poster-card {
    background-color: #2c2c2e;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    cursor: pointer;
    overflow: hidden;

    /* [核心] 1. 将容器设为相对定位，作为标题定位的“锚点” */
    position: relative; 
    
    /* [核心] 2. 将高宽比从图片移到卡片本身，确保整个卡片形状正确 */
    aspect-ratio: 2 / 3; 

    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.poster-image {
    /* [核心] 3. 让图片填满整个卡片容器 */
    width: 100%;
    height: 100%; 
    background-size: cover;
    background-position: center;
}

.poster-title {
    color: #FFFFFF;
    text-align: center;
    font-size: 16px;
    font-weight: 600;
    
    /* [核心] 4. 使用绝对定位，将标题“钉”在卡片底部 */
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;

    /* [核心] 5. 使用渐变背景，让文字更易读，过渡更自然 */
    background: linear-gradient(to top, rgba(0, 0, 0, 0.85) 20%, transparent);

    /* [核心] 6. 调整内边距，让文字在渐变区域内更美观 */
    padding: 25px 10px 15px 10px;
    box-sizing: border-box; /* 确保内边距不会撑开宽度 */

    /* [核心] 7. 加上文字阴影，增强在复杂图片背景下的可读性 */
    text-shadow: 0 2px 4px rgba(0,0,0,0.6);
}

/* --- 2. “放映室” (故事主页面) 的样式 --- */

/* 页头布局 (保持不变) */
#movie-story-page .page-header {
    position: absolute; top: 0; left: 0; right: 0; z-index: 10;
    padding-top: 60px; padding-bottom: 10px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);
    border-bottom: none;
}

/* 【核心新增】为放映室页面添加一个用于承载背景的伪元素 */
#movie-story-page::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; /* 将背景层置于内容之下 */
    background-image: var(--movie-bg-image, none);
    background-size: cover;
    background-position: center;
    
    /* 【灵魂】在这里应用你想要的模糊效果！ */
    filter: blur(8px);
    
    /* 为了防止边缘模糊不全，稍微放大一点 */
    transform: scale(1.05);
    
    /* 背景图片切换时有一个平滑的过渡效果 */
    transition: background-image 0.4s ease-in-out;
}

/* 主屏幕容器，现在只负责居中和滚动 */
#movie-screen-container {
    flex-grow: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 25px; /* 【核心修改】增大卡片之间的固定间距，替代分隔符 */
    padding: 120px 10px 20px 10px;
}

/* “分镜卡”基础样式 */
.story-card {
    width: 90%;
    max-width: 500px;
    background: var(--button-bg-color);
    border: var(--frosted-glass-border);
    border-radius: 18px;
    padding: 15px 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* 卡片头部 */
.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-color);
    opacity: 0.6;
    padding-bottom: 12px; /* 增大底部内边距，给虚线留出空间 */
    
    /* 【核心修改】在这里添加你想要的虚线分割线 */
    border-bottom: 1px dashed rgba(var(--text-color-rgb), 0.3);
}
.header-info { display: flex; align-items: center; gap: 8px; }
.header-actions { display: flex; align-items: center; gap: 15px; }
.header-actions i { font-size: 18px; cursor: pointer; transition: color 0.2s, transform 0.2s; }
.header-actions i:hover { color: var(--text-color); transform: scale(1.1); }

/* 卡片主体 (文本区域) */
.card-body {
    line-height: 1.8;
    font-size: 16px;
    color: var(--movie-color-normal, var(--text-color)); /* <-- 修改 */
    white-space: pre-wrap;
    word-break: break-word;
}
/* 文本内部的样式 - 更新颜色为变量 */
.card-body .dialogue { 
    color: var(--movie-color-dialogue, #B0B0B0); /* <-- 修改 */
}
body.light-mode .card-body .dialogue { 
    color: var(--movie-color-dialogue, #555555); /* <-- 修改 */
}
.card-body .thought { 
    color: var(--movie-color-thought, #EAE0C8); /* <-- 修改 */
    font-style: italic; 
}
body.light-mode .card-body .thought { 
    color: var(--movie-color-thought, #7d6b55); /* <-- 修改 */
}
/* ^^^ 修改结束 1/3 ^^^ */


/* --- 3. 参考图2风格的输入栏 --- */

/* vvv 【【【 核心修改区域 2/3 】】】 vvv */
/* 输入栏 - 更新背景颜色为变量 */
#movie-input-bar {
    flex-shrink: 0;
    padding: 10px 15px 20px 15px;
    /* --- 核心升级开始 --- */
    /* 1. 背景色现在由一个 RGB 变量和一个固定的透明度构成 */
    background: rgba(var(--movie-bg-input-bar-rgb, 70, 70, 70), 0.5); 
    /* 2. 其他毛玻璃效果保持不变 */
    backdrop-filter: blur(var(--blur-intensity));
    -webkit-backdrop-filter: blur(var(--blur-intensity));
    border-top: var(--frosted-glass-border);
    /* --- 核心升级结束 --- */
    display: flex;
    flex-direction: column;
    gap: 10px;
}
/* ^^^ 修改结束 2/3 ^^^ */

/* 输入框本身，现在看起来像一个卡片 */
.input-card {
    /* --- 核心修改开始 --- */
    background: var(--input-bg-color); /* <-- 改为使用输入框的半透明背景 */
    /* --- 核心修改结束 --- */
    border: var(--frosted-glass-border);
    border-radius: 18px;
    padding: 15px 20px;
}

/* vvv 【【【 全新：“呼吸灯”效果的 CSS 】】】 vvv */

/* 1. 定义一个名为 "breathing-glow" 的动画 */
@keyframes breathing-glow {
  from {
    /* 动画开始时：边框和阴影是比较收敛的状态 */
    border-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.15);
  }
  to {
    /* 动画结束时：边框和阴影变得更亮、范围更广，形成“辉光” */
    border-color: rgba(255, 255, 255, 0.6);
    box-shadow: 0 0 25px rgba(255, 255, 255, 0.5);
  }
}

/* 2. 创建一个触发器类，当它被添加到输入框卡片上时，就播放动画 */
.input-card.waiting-for-reply {
    animation-name: breathing-glow;      /* 动画名称 */
    animation-duration: 2s;              /* 一次呼吸持续2秒 */
    animation-timing-function: ease-in-out; /* 缓入缓出，效果更自然 */
    animation-iteration-count: infinite; /* 无限循环 */
    animation-direction: alternate;      /* 动画来回播放，形成呼吸感 */
}

/* vvv 【【【 核心修改区域 3/3 】】】 vvv */
/* 输入框本身 - 更新文字颜色为变量 */
#movie-input {
    width: 100%;
    background: transparent;
    border: none;
    resize: none;
    color: var(--movie-color-user-input, var(--text-color)); /* <-- 修改 */
    font-size: 16px;
    line-height: 1.6;
    font-family: inherit;
    max-height: 150px;
    overflow-y: auto;
}
#movie-input:focus { outline: none; }
#movie-input::placeholder { 
    color: var(--movie-color-user-input, var(--text-color)); /* <-- 修改 */
    opacity: 0.5; 
}

/* 底部操作栏 */
.input-actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.action-icons { display: flex; gap: 18px; font-size: 22px; color: var(--text-color); opacity: 0.6; }
.action-icons i { cursor: pointer; }

/* 全新的发送按钮 - 更新颜色为变量 */
#movie-send-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: none;
    background-color: var(--movie-bg-send-btn, var(--text-color)); /* <-- 修改 */
    color: var(--movie-color-send-btn, var(--background-color)); /* <-- 修改 */
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: transform 0.2s;
}
/* ^^^ 修改结束 3/3 ^^^ */
#movie-send-btn:hover {
    transform: scale(1.03);
}

/* --- 新增：电影模式-书籍选择UI优化 --- */
#movie-library-select-container {
    /* 移除旧的背景和内边距，让它成为一个纯粹的flex容器 */
    background: none;
    padding: 0;
    
    /* 核心：使用flex布局，并允许换行 */
    display: flex;
    flex-wrap: wrap;
    gap: 10px; /* 控制书籍标签之间的间距 */
}

.book-chip {
    padding: 8px 15px;
    border-radius: 20px; /* 圆润的胶囊形状 */
    background-color: var(--input-bg-color);
    border: 1.5px solid transparent; /* 预留边框位置 */
    color: var(--text-color);
    opacity: 0.7;
    font-size: 14px;
    cursor: pointer;
    
    /* 让图标和文字垂直居中 */
    display: flex;
    align-items: center;
    gap: 6px;

    transition: all 0.2s ease;
}

.book-chip:hover {
    opacity: 1;
    background-color: var(--button-bg-color);
}

.book-chip.selected {
    opacity: 1;
    background-color: #799181; /* 使用一个雅致的绿色作为高亮色 */
    color: #FFFFFF; /* 选中时文字变白，更清晰 */
    border-color: rgba(255, 255, 255, 0.5);
}

/* 选中时，在文字前显示一个小小的对勾图标 */
.book-chip .selection-icon {
    font-size: 18px;
    display: none; /* 默认不显示 */
}
.book-chip.selected .selection-icon {
    display: inline-block; /* 选中时显示 */
}
    </style>
</head>

<body>

    <!-- ======================================================= -->
    <!-- ==== 图层一：核心桌面 UI (应用的“地基”)            ==== -->
    <!-- ======================================================= -->
    <!-- 这是应用的骨架，永远显示在最底层 -->
    <div class="screen">
        <div class="status-bar">
            <span id="clock"></span>
            <div id="theme-toggle"><i id="theme-icon" class="ri-heart-line"></i></div>
        </div>

        <div class="main-desktop">
            <div class="swipe-area">
                <div class="page-container">
                    <!-- 桌面第一页 -->
                    <div class="page">
                        <div class="page-content">
                            <div id="music-player-widget" class="frosted-module widget-large-horizontal upload-widget">
                                <div class="music-player-info">
                                    <div id="player-avatar"></div>
                                    <div class="music-text-details">
                                        <span id="player-custom-text" contenteditable="true">carpe diem</span>
                                        <span id="player-song-title" contenteditable="true">--</span>
                                    </div>
                                </div>
                                <div id="player-progress-container">
                                    <span id="current-time">0:00</span>
                                    <div id="progress-bar"><div id="progress-fill"></div></div>
                                    <span id="total-time">0:00</span>
                                </div>
                                <div class="music-player-controls">
                                    <i id="shuffle-btn" class="ri-shuffle-line" title="随机播放"></i>
                                    <i id="prev-btn" class="ri-skip-back-fill"></i>
                                    <i id="play-pause-btn" class="ri-play-fill"></i>
                                    <i id="next-btn" class="ri-skip-forward-fill"></i>
                                    <i id="loop-btn" class="ri-repeat-2-line" title="列表循环"></i>
                                    <i id="add-music-btn" class="ri-add-line" title="添加音乐"></i>
                                </div>
                            </div>
                            <div id="upload-p1-square" class="frosted-module widget-square-top-left upload-widget"></div>
                            <div class="app-grid">
                                <div id="icon-settings" class="app-icon icon-with-text customizable-icon" style="cursor: pointer;"><i class="ri-settings-3-line"></i><span>设置</span></div>
                                <div id="icon-chat" class="app-icon icon-with-text customizable-icon"><i class="ri-chat-3-line"></i><span>聊天</span></div>
                                <div id="icon-story" class="app-icon icon-with-text customizable-icon"><i class="ri-book-open-line"></i><span>电影</span></div>
                                <div id="icon-archive" class="app-icon icon-with-text customizable-icon" style="cursor: pointer;"><i class="ri-contacts-book-line"></i><span>档案</span></div>
                            </div>
                            <div id="upload-p1-vertical" class="frosted-module widget-small-vertical upload-widget"></div>
                        </div>
                    </div>
                    <!-- 桌面第二页 -->
                    <div class="page">
                        <div class="page-content">
                            <div id="calendar-todo-widget" class="frosted-module upload-widget">
                                <div class="calendar-container">
                                    <div class="calendar-header">
                                        <h3 id="calendar-month-year"></h3>
                                        <div class="calendar-nav">
                                            <i id="prev-month-btn" class="ri-arrow-left-s-line"></i>
                                            <i id="next-month-btn" class="ri-arrow-right-s-line"></i>
                                        </div>
                                    </div>
                                    <div class="calendar-grid">
                                        <div class="calendar-weekdays"><span>日</span><span>一</span><span>二</span><span>三</span><span>四</span><span>五</span><span>六</span></div>
                                        <div class="calendar-dates" id="calendar-dates-grid"></div>
                                    </div>
                                </div>
                                <div class="todo-container">
                                    <h3>待办事项</h3>
                                    <ul id="todo-list"></ul>
                                    <form class="todo-add-form" id="todo-add-form">
                                        <input type="text" id="todo-input" placeholder="添加新任务..." autocomplete="off">
                                        <button type="submit"><i class="ri-add-line"></i></button>
                                    </form>
                                </div>
                            </div>
                            <div class="app-grid p2-app-grid">
                                <div id="icon-p2-1" class="app-icon customizable-icon"></div>
                                <div id="icon-p2-2" class="app-icon customizable-icon"></div>
                                <div id="icon-p2-3" class="app-icon customizable-icon"></div>
                                <div id="icon-p2-4" class="app-icon customizable-icon"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pagination">
                <div class="dot active"></div>
                <div class="dot"></div>
            </div>

            <div class="frosted-module dock">
                <div id="dock-forum" class="dock-icon icon-with-text customizable-icon"><i class="ri-discuss-line"></i><span>论坛</span></div>
                <div id="soul-echo-settings" class="dock-icon icon-with-text customizable-icon"><i class="ri-heart-pulse-line"></i><span>灵魂回响</span></div>
                <div id="open-library-app" class="dock-icon icon-with-text customizable-icon"><i class="ri-global-line"></i><span>图书馆</span></div>
            </div>
        </div>
    </div>


    <!-- ======================================================= -->
    <!-- ==== 图层二：全屏应用容器 (App Navigators)         ==== -->
    <!-- ======================================================= -->
    <!-- 所有全屏应用都作为<body>的直接子元素平级放置，避免嵌套问题 -->

    <!-- 设置应用 -->
    <div id="settings-navigator" class="settings-navigator">
        <!-- 设置主页 -->
        <div id="settings-main-page" class="settings-page">
            <div class="page-header"><i class="ri-arrow-left-s-line back-button" data-target="desktop"></i><h2>设置</h2></div>
            <div class="settings-grid">
                <div id="goto-api-settings" class="settings-item"><i class="ri-cloud-line"></i><span>API 设置</span></div>
                <div id="goto-appearance-settings" class="settings-item"><i class="ri-palette-line"></i><span>外观设置</span></div>
                <div class="settings-item"><i class="ri-user-line"></i><span>账号设置 (待开发)</span></div>
            </div>
        </div>
        <!-- API设置页 -->
        <div id="api-settings-page" class="settings-page">
            <div class="page-header"><i class="ri-arrow-left-s-line back-button" data-target="settings-main-page"></i><h2>API 设置</h2></div>
            <div class="settings-grid">
                <div class="form-group preset-manager"><select id="api-preset-select"><option value="">-- 选择配置 --</option></select><button id="load-preset-button">加载</button><button id="delete-preset-button">删除</button></div>
                <div class="form-group"><label for="api-name">配置名称</label><input type="text" id="api-name" placeholder="例如：我的中转API"></div>
                <div class="form-group"><label for="api-url">API URL</label><input type="text" id="api-url" placeholder="api.openai.com"></div>
                <div class="form-group"><label for="api-key">API Key</label><input type="password" id="api-key" placeholder="sk-..."></div>
                <div class="form-group"><label for="api-model-select">模型 (Model)</label><div class="model-fetch-group"><select id="api-model-select"><option value="">-- 先拉取模型 --</option></select><button id="fetch-models-button">拉取</button></div></div>
            </div>
            <div class="api-buttons">
                <button id="set-active-api-button">设为当前</button>
                <button id="save-settings-button">保存</button>
            </div>
        </div>
        <!-- 外观设置页 -->
        <div id="appearance-settings-page" class="settings-page">
            <div class="page-header"><i class="ri-arrow-left-s-line back-button" data-target="settings-main-page"></i><h2>外观设置</h2></div>
            <div class="settings-grid">
                <div id="set-wallpaper-item" class="settings-item"><i class="ri-image-line"></i><span>设置壁纸</span></div>
                <div id="goto-icon-settings" class="settings-item"><i class="ri-grid-line"></i><span>图标设置</span></div>
                <div id="goto-font-settings" class="settings-item"><i class="ri-font-size"></i><span>字体设置</span></div>
            </div>
        </div>
        <!-- 图标设置页 -->
        <div id="icon-settings-page" class="settings-page">
            <div class="page-header"><i class="ri-arrow-left-s-line back-button" data-target="appearance-settings-page"></i><h2>图标设置</h2></div>
            <div id="icon-settings-grid"></div>
        </div>
        <!-- 字体设置页 -->
        <div id="font-settings-page" class="settings-page">
            <div class="page-header"><i class="ri-arrow-left-s-line back-button" data-target="appearance-settings-page"></i><h2>字体设置</h2></div>
            <div class="settings-grid">
                <div class="form-group preset-manager">
                    <select id="font-preset-select"><option value="">-- 选择已保存的字体 --</option></select>
                    <button id="load-font-button">加载</button>
                    <button id="delete-font-button">删除</button>
                </div>
                <div class="form-group"><label for="font-name-input">字体名称</label><input type="text" id="font-name-input" placeholder="为这个字体起个名字"></div>
                <div class="form-group"><label for="font-url-input">字体 URL</label><input type="url" id="font-url-input" placeholder="https://.../font.woff2"></div>
                <div class="action-buttons"><button id="apply-font-button">应用并保存</button><button id="clear-font-button">清除字体</button></div>
                <hr style="border: none; border-top: 1px solid var(--frosted-glass-border); width: 100%; margin: 10px 0;">
                <div class="form-group">
                    <label for="font-size-slider">全局字体大小</label>
                    <div class="font-size-control">
                        <input type="range" id="font-size-slider" min="10" max="18" step="0.5" value="13">
                        <span id="font-size-value">13px</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 档案应用 -->
    <div id="archive-app" class="app-navigator">
        <!-- 档案主页 -->
        <div id="main-archive-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="desktop"></i>
                <h2>档案</h2>
                <i class="ri-add-line right-icon" id="add-dossier-btn"></i>
            </div>
            <div id="archive-list"></div>
        </div>
        <!-- 档案创建/编辑页 -->
        <div id="creation-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="main-archive-page"></i>
                <h2>建立新档案</h2>
            </div>
            <div class="content">
                <div class="persona-editor">
                    <h3>角色 (CHARACTER)</h3>
                    <div class="form-row">
                        <div id="character-avatar-upload-area" class="avatar-uploader"><i class="ri-image-add-line"></i></div>
                        <div class="fields-column">
                            <input type="text" id="character-name-input" placeholder="姓名">
                            <textarea id="character-background-input" placeholder="人设背景..."></textarea>
                        </div>
                    </div>
                </div>
                <div class="persona-editor">
                    <h3>用户 (USER)</h3>
                    <div class="form-row">
                        <div id="user-avatar-upload-area" class="avatar-uploader"><i class="ri-user-add-line"></i></div>
                        <div class="fields-column">
                            <input type="text" id="user-name-input" placeholder="姓名">
                            <textarea id="user-background-input" placeholder="你的设定..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <div class="action-buttons">
                <button id="save-dossier-btn">保存并生成</button>
                <button id="delete-dossier-btn" style="background-color: #ff6b6b; display: none;">删除</button>
            </div>
        </div>
    </div>

    <!-- 聊天应用 -->
    <div id="app-chat" class="app-navigator">
        <!-- 聊天列表主页 -->
        <div id="chat-main-page" class="app-page active">
            <div class="page-header" style="padding: 15px 25px;">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="desktop"></i>
                <h2 id="chat-header-title">对话</h2>
                <i class="ri-add-line right-icon" id="new-chat-btn" title="发起新聊天"></i>
            </div>
            <div class="chat-main-content">
                <div id="dialogue-pane" class="content-pane active">
                    <ul id="chat-list"></ul>
                </div>
                <div id="moments-pane" class="content-pane">
                    <div class="moments-content">
                        <div class="stories-container">
                            <div class="story-item placeholder">
                                <div class="story-avatar"><i class="ri-add-line"></i></div>
                                <span>你的快拍</span>
                            </div>
                        </div>
                        <hr class="moments-divider">
                        <div id="posts-container" class="posts-container">
                            <p style="text-align:center; opacity:0.7; padding: 50px 20px;">还没有任何动态，和你的角色聊聊天，看看会发生什么吧。</p>
                        </div>
                    </div>
                </div>
                <div id="memories-pane" class="content-pane" style="overflow-y: auto;">
                    <div id="memory-polaroid-grid"></div>
                </div>
                <div id="secrets-pane" class="content-pane">
                    <div id="secrets-list-container">
                        <p style="text-align:center; opacity:0.7; padding: 50px 20px;">
                            你的秘密花园里还没有任何心事...<br>点击右上角的“+”号，写下第一条吧。
                        </p>
                    </div>
                </div>
            </div>
            <nav class="chat-tab-bar">
                <div class="tab-item active" data-target="dialogue-pane" data-title="对话"><i class="ri-message-3-line"></i><span>对话</span></div>
                <div class="tab-item" data-target="moments-pane" data-title="动态"><i class="ri-stack-line"></i><span>动态</span></div>
                <div class="tab-item" data-target="memories-pane" data-title="回忆"><i class="ri-time-line"></i><span>回忆</span></div>
                <div class="tab-item" data-target="secrets-pane" data-title="心事">
                    <i class="ri-lock-line"></i>
                    <span>心事</span>
                </div>
            </nav>
        </div>
        <!-- 聊天对话页 -->
        <div id="chat-dialogue-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="chat-main-page"></i>
                <h2 id="chat-dialogue-header-title"></h2>
                <i class="ri-more-fill right-icon" id="chat-more-btn"></i>
            </div>
            <div id="chat-messages-container"></div>
            <div id="reply-preview-container">
                <div class="reply-content">
                    <span id="reply-author"></span>
                    <span id="reply-text"></span>
                </div>
                <i id="close-reply-btn" class="ri-close-line"></i>
            </div>
            <div id="multi-select-toolbar">
                <span id="multi-select-counter" style="font-size: 14px; opacity: 0.8;"></span>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <button id="delete-selected-btn"><i class="ri-delete-bin-line"></i></button>
                    <button id="exit-multi-select-btn" class="active"><i class="ri-close-line"></i></button>
                </div>
            </div>
            <div id="sticker-panel">
                <div id="sticker-panel-header">
                    <h3>我的表情包</h3>
                    <button id="manage-stickers-btn" class="icon-btn"><i class="ri-settings-3-line"></i></button>
                </div>
                <div id="sticker-grid-container">
                    <p class="empty-placeholder">你还没有收藏表情包，快去“管理”页面添加吧！</p>
                </div>
            </div>
            <div id="chat-function-panel">
                <div class="function-grid">
                    <div id="func-send-image" class="function-item">
                        <div class="function-icon-bg"><i class="ri-image-line"></i></div>
                        <span>图片</span>
                    </div>
                    <div id="func-send-video" class="function-item">
                        <div class="function-icon-bg"><i class="ri-vidicon-line"></i></div>
                        <span>视频</span>
                    </div>
                    <div id="func-voice-input" class="function-item">
                        <div class="function-icon-bg"><i class="ri-mic-line"></i></div>
                        <span>语音</span>
                    </div>
                    <div id="func-transfer" class="function-item">
                        <div class="function-icon-bg"><i class="ri-exchange-cny-line"></i></div>
                        <span>转账</span>
                    </div>
                    <div id="func-wallet" class="function-item">
                        <div class="function-icon-bg"><i class="ri-wallet-3-line"></i></div>
                        <span>钱包</span>
                    </div>
                    <div id="func-horoscope" class="function-item">
                        <div class="function-icon-bg"><i class="ri-planet-line"></i></div>
                        <span>星座</span>
                    </div>
                </div>
            </div>
            <div class="chat-input-bar">
                <button class="icon-btn" id="chat-function-btn"><i class="ri-add-line"></i></button>
                <button class="icon-btn" id="emoji-btn"><i class="ri-emotion-happy-line"></i></button>
                <textarea id="chat-input-textarea" placeholder="输入消息..." rows="1"></textarea>
                <button class="icon-btn" id="send-buffer-btn"><i class="ri-quill-pen-line"></i></button>
                <button class="icon-btn" id="send-final-btn"><i class="ri-snowflake-line"></i></button>
            </div>
        </div>
        <!-- 聊天详情页 -->
        <div id="chat-details-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="chat-dialogue-page"></i>
                <h2>聊天详情</h2>
            </div>
            <div class="settings-grid" style="padding-top: 15px;">
                <div id="set-chat-wallpaper-item" class="settings-item">
                    <i class="ri-image-line"></i>
                    <span>设置聊天壁纸</span>
                </div>
                <div id="set-memory-rounds-item" class="settings-item">
                    <i class="ri-history-line"></i>
                    <span>记忆轮数</span>
                </div>
                <div id="manage-exclusive-books-item" class="settings-item">
                    <i class="ri-book-read-line"></i>
                    <span>管理专属书</span>
                    <span id="linked-books-count" style="opacity: 0.6; font-size: 14px; margin-left: auto;">未设置</span>
                </div>
                <div id="toggle-time-perception-item" class="settings-item">
                    <i class="ri-time-line"></i>
                    <span>时间感知</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="time-perception-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div id="toggle-pin-chat-item" class="settings-item">
                    <i class="ri-pushpin-2-line"></i>
                    <span>置顶聊天</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="pin-chat-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            <div id="danger-zone-container">
                <button id="clear-history-btn" class="danger-button">清空聊天记录</button>
                <button id="delete-conversation-btn" class="danger-button">删除此对话</button>
            </div>
        </div>
        <!-- 写心事页面 -->
        <div id="secrets-creation-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="chat-main-page"></i>
                <h2>写下心事</h2>
            </div>
            <div class="secret-writing-card">
                <input type="text" id="secret-title-input" placeholder="给这件心事起个标题吧 (可选)">
                <hr class="secret-divider">
                <textarea id="secret-content-input" placeholder="在这里写下你的心事..."></textarea>
                <div class="mood-selector">
                    <div class="mood-item" data-mood="happy"><i class="ri-emotion-happy-line"></i></div>
                    <div class="mood-item" data-mood="sad"><i class="ri-emotion-unhappy-line"></i></div>
                    <div class="mood-item" data-mood="love"><i class="ri-heart-add-line"></i></div>
                    <div class="mood-item" data-mood="thoughtful"><i class="ri-question-line"></i></div>
                    <div class="mood-item" data-mood="normal"><i class="ri-emotion-normal-line"></i></div>
                </div>
            </div>
            <div class="action-buttons" style="padding: 10px 0; flex-shrink: 0;">
                <button id="publish-secret-btn" style="width: 100%; padding: 15px; border-radius: 12px; font-size: 16px;">发布</button>
            </div>
        </div>
        <!-- 回忆详情页 -->
        <div id="memory-details-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="chat-main-page"></i>
                <h2 id="memory-details-header-title"></h2>
                <i class="ri-add-line right-icon" id="add-memory-btn"></i>
            </div>
            <div id="memory-scrapbook-container" class="content" style="overflow-y: auto; padding: 20px;">
                <p style="text-align:center; opacity:0.7; padding: 50px 20px;">这里还没有任何与TA的回忆...</p>
            </div>
        </div>
    </div>

    <!-- 图书馆应用 -->
    <div id="library-app" class="app-navigator">
        <div id="library-main-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="desktop"></i>
                <h2>图书馆</h2>
                <i class="ri-add-line right-icon" id="add-book-btn"></i>
            </div>
            <div id="library-list-container" style="overflow-y: auto; flex-grow: 1;"></div>
        </div>
        <div id="library-creation-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="library-main-page"></i>
                <h2>创建新书</h2>
            </div>
            <div class="content" style="gap: 20px; overflow-y: auto; padding: 10px;">
                <div class="form-group">
                    <label for="create-book-title">书名</label>
                    <input type="text" id="create-book-title" placeholder="为这本书起个名字">
                </div>
                <div class="settings-item" style="padding: 10px 15px; cursor: default;">
                    <span>设为全局</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="create-book-is-global">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group">
                    <label for="create-book-category">分类</label>
                    <select id="create-book-category">
                        <option value="behavior_core">AI行为标准</option>
                        <option value="worldview">世界观</option>
                        <option value="writing_style">文风</option>
                        <option value="sticker_pack">表情包</option>
                        <option value="html_module">HTML模块</option>
                    </select>
                </div>
                <div class="form-group" style="flex-grow: 1; display: flex; flex-direction: column;">
                    <label for="create-book-content">内容</label>
                    <textarea id="create-book-content" placeholder="输入这本书的具体内容或指令..." style="flex-grow: 1; resize: none;"></textarea>
                </div>
                <div class="action-buttons">
                    <button id="save-new-book-btn">保存</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 灵魂回响/日记应用 -->
    <div id="diary-app" class="app-navigator">
        <div id="diary-main-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="desktop"></i>
                <h2>灵魂回响</h2>
                <i class="ri-add-line right-icon" id="add-user-diary-btn"></i>
            </div>
            <div id="diary-list-container" style="overflow-y: auto; flex-grow: 1; padding: 20px 10px; display: flex; flex-direction: column; gap: 15px;"></div>
        </div>
    </div>

    <!-- 电影模式应用 -->
    <div id="movie-app" class="app-navigator">
        <div id="movie-character-select-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="desktop"></i>
                <h2>电影 - 选择主角</h2>
            </div>
            <div id="movie-poster-grid"></div>
        </div>
        <div id="movie-story-page" class="app-page" style="padding: 0; gap: 0;">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="movie-character-select-page"></i>
                <h2 id="movie-character-name"></h2>
                <i class="ri-settings-3-line right-icon" id="movie-settings-btn"></i>
            </div>
            <div id="movie-screen-container"></div>
            <div id="movie-input-bar">
                <div class="input-card">
                    <textarea id="movie-input" placeholder="输入你的行动或对话..." rows="1"></textarea>
                </div>
                <div class="input-actions">
                    <div class="action-icons">
                        <i class="ri-attachment-line"></i>
                        <i class="ri-image-add-line"></i>
                        <i class="ri-sparkles-line"></i>
                    </div>
                    <button id="movie-send-btn">
                        <span>发送</span>
                        <i class="ri-arrow-up-s-line"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- 动态发布应用 -->
    <div id="moment-creator-app" class="app-navigator">
        <div id="moment-creation-page" class="app-page">
            <div class="page-header">
                <i class="ri-arrow-left-s-line left-icon back-button" data-target="chat-main-page"></i>
                <h2>发布新动态</h2>
            </div>
            <div class="content" style="display: flex; flex-direction: column; gap: 20px; padding: 10px; overflow-y: auto;">
                <div class="user-profile-bar" style="display: flex; align-items: center; gap: 15px; background: var(--input-bg-color); padding: 10px; border-radius: 12px;">
                    <div id="user-moment-avatar-uploader" class="avatar-uploader" style="width: 50px; height: 50px; border-radius: 50%; cursor: pointer; background-size: cover; background-position: center;">
                        <i class="ri-user-add-line" style="font-size: 24px;"></i>
                    </div>
                    <span style="font-weight: 600; font-size: 16px;">我</span>
                </div>
                <div class="moment-type-selector" style="display: flex; background: var(--input-bg-color); border-radius: 10px; padding: 4px;">
                    <button class="type-btn active" data-type="post" style="flex: 1; padding: 8px; border: none; background: var(--button-bg-color); color: var(--text-color); border-radius: 8px; font-weight: 500; cursor: pointer;">日常</button>
                    <button class="type-btn" data-type="story" style="flex: 1; padding: 8px; border: none; background: transparent; color: var(--text-color); border-radius: 8px; font-weight: 500; cursor: pointer; opacity: 0.7;">快拍</button>
                </div>
                <textarea id="moment-content-input" placeholder="分享新鲜事..." style="width: 100%; min-height: 120px; resize: vertical; padding: 12px; border-radius: 8px; border: none; background-color: var(--input-bg-color); color: var(--text-color); font-size: 16px; font-family: inherit;"></textarea>
                <div id="moment-image-uploader-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <div id="moment-image-uploader" class="avatar-uploader" style="width: 100px; height: 100px; border-radius: 12px; display: flex; align-items: center; justify-content: center; background-size: cover; background-position: center;">
                        <i class="ri-image-add-line" style="font-size: 32px;"></i>
                    </div>
                </div>
            </div>
            <div class="action-buttons" style="padding: 10px 0; flex-shrink: 0;">
                <button id="publish-moment-btn" style="width: 100%; padding: 15px; border-radius: 12px; font-size: 16px;">发布</button>
            </div>
        </div>
    </div>


    <!-- ======================================================= -->
    <!-- ==== 图层三：全局模态框 (Modal Overlays)           ==== -->
    <!-- ======================================================= -->
    <!-- 所有弹出的、覆盖性的模态窗口都放在这里 -->

    <!-- 添加音乐弹窗 -->
    <div id="add-music-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h3>音乐库</h3><i id="close-modal-btn" class="ri-close-line"></i></div>
            <div class="form-group"><label for="song-url-input">从 URL 添加</label><div class="add-song-group"><input type="text" id="song-url-input" placeholder="输入音乐网络链接"><button id="add-url-btn">添加</button></div></div>
            <div class="form-group"><label>从本地文件添加</label><button id="upload-local-file-btn">选择文件</button></div>
            <hr style="border: none; border-top: 1px solid var(--frosted-glass-border); width: 100%;">
            <div id="playlist-container"></div>
        </div>
    </div>

    <!-- 查看档案弹窗 -->
    <div id="dossier-modal-overlay" class="modal-overlay">
        <div id="dossier-modal-content">
            <div class="dossier-header"><span>角色档案</span><i class="ri-close-line" id="close-dossier-btn"></i></div>
            <div class="dossier-body">
                <div class="dossier-top-section">
                    <div id="modal-dossier-avatar" class="dossier-avatar"></div>
                    <div class="dossier-main-info">
                        <div class="dossier-field"><label>姓名</label><span id="modal-dossier-name"></span></div>
                    </div>
                </div>
                <div class="dossier-details-grid">
                    <div class="dossier-field"><label>性格</label><span id="modal-dossier-personality"></span></div>
                    <div class="dossier-field"><label>喜好</label><span id="modal-dossier-likes"></span></div>
                </div>
                <div class="dossier-field"><label>语录</label><p id="modal-dossier-quote" class="dossier-quote"></p></div>
                <div class="dossier-field"><label>人设背景</label><p id="modal-dossier-background" class="dossier-background"></p></div>
                <div class="dossier-fingerprints">
                    <h4>指纹记录</h4>
                    <div class="fingerprint-grid">
                        <div class="fingerprint-placeholder"><i class="ri-fingerprint-2-line"></i></div>
                        <div class="fingerprint-placeholder"><i class="ri-fingerprint-2-line"></i></div>
                        <div class="fingerprint-placeholder"><i class="ri-fingerprint-2-line"></i></div>
                        <div class="fingerprint-placeholder"><i class="ri-fingerprint-2-line"></i></div>
                        <div class="fingerprint-placeholder"><i class="ri-fingerprint-2-line"></i></div>
                    </div>
                </div>
            </div>
            <div class="dossier-footer">
                <div class="action-buttons"><button id="edit-dossier-btn">编辑</button></div>
            </div>
        </div>
    </div>

    <!-- 选择聊天角色弹窗 -->
    <div id="new-chat-modal" class="modal-overlay">
        <div class="modal-content" style="max-height: 70vh;">
            <div class="modal-header"><h3>选择聊天角色</h3><i class="ri-close-line" id="close-chat-modal-btn"></i></div>
            <ul id="character-select-list" style="flex-grow: 1; overflow-y: auto; list-style: none; margin: 0; padding: 0;"></ul>
        </div>
    </div>

    <!-- 记忆轮数设置弹窗 -->
    <div id="memory-rounds-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>记忆轮数</h3>
                <i id="close-memory-rounds-btn" class="ri-close-line"></i>
            </div>
            <p style="font-size: 14px; opacity: 0.7; margin: -10px 0 10px 0;">
                设定AI在对话中能记住的上下文轮数（1轮 = 你的1条消息 + AI的1条回复）。轮数越高，记忆越好，但API请求费用也会相应增加。
            </p>
            <div class="form-group" style="display: flex; flex-direction: column; gap: 15px;">
                <label for="memory-rounds-slider" style="display: flex; justify-content: space-between; align-items: center;">
                    当前轮数: <span id="memory-rounds-value" style="font-size: 1.2em; font-weight: 600;">20</span>
                </label>
                <input type="range" id="memory-rounds-slider" min="1" max="500" value="20" step="1">
            </div>
            <div class="action-buttons" style="margin-top: 15px;">
                <button id="save-memory-rounds-btn">保存</button>
            </div>
        </div>
    </div>

    <!-- 编辑消息弹窗 -->
    <div id="edit-message-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <h3>编辑消息</h3>
                <i id="close-edit-modal-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <textarea id="edit-message-textarea" style="width: 100%; min-height: 150px; resize: vertical; padding: 12px; border-radius: 8px; border: none; background-color: var(--input-bg-color); color: var(--text-color); font-size: 16px; font-family: inherit;"></textarea>
            </div>
            <div class="action-buttons" style="margin-top: 10px;">
                <button id="cancel-edit-btn">取消</button>
                <button id="save-edit-btn">保存修改</button>
            </div>
        </div>
    </div>

    <!-- 编辑书浮窗 -->
    <div id="book-edit-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh;">
            <div class="modal-header">
                <h3>编辑书</h3>
                <i id="close-book-edit-modal-btn" class="ri-close-line"></i>
            </div>
            <div class="content" style="gap: 20px; overflow-y: auto; padding: 5px; max-height: 60vh;">
                <div class="form-group">
                    <label for="edit-book-title">书名</label>
                    <input type="text" id="edit-book-title">
                </div>
                <div class="settings-item" style="padding: 10px 15px; cursor: default;">
                    <span>设为全局</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="edit-book-is-global">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="form-group">
                    <label for="edit-book-category">分类</label>
                    <select id="edit-book-category">
                        <option value="behavior_core">AI行为标准</option>
                        <option value="worldview">世界观</option>
                        <option value="writing_style">文风</option>
                        <option value="sticker_pack">表情包</option>
                        <option value="html_module">HTML模块</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="edit-book-content">内容</label>
                    <textarea id="edit-book-content" style="min-height: 200px; resize: vertical;"></textarea>
                </div>
            </div>
            <div class="action-buttons" style="justify-content: space-between;">
                <button id="delete-book-btn" style="background-color: #ff3b30;">删除</button>
                <button id="save-book-changes-btn">保存修改</button>
            </div>
        </div>
    </div>

    <!-- 链接专属书浮窗 -->
    <div id="book-link-modal" class="modal-overlay">
        <div class="modal-content" style="max-height: 70vh;">
            <div class="modal-header">
                <h3>为角色选择专属书</h3>
                <i id="close-book-link-modal-btn" class="ri-close-line"></i>
            </div>
            <ul id="book-link-list" style="flex-grow: 1; overflow-y: auto; list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 10px;"></ul>
            <div class="action-buttons" style="margin-top: 10px;">
                <button id="save-book-links-btn">保存选择</button>
            </div>
        </div>
    </div>
    
    <!-- 表情包管理弹窗 -->
    <div id="sticker-manager-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>管理我的表情包</h3>
                <i id="close-sticker-manager-btn" class="ri-close-line"></i>
            </div>
            <div class="sticker-manager-actions">
                <button id="batch-import-stickers-btn">批量导入</button>
                <button id="clear-all-stickers-btn" class="danger-button" style="background-color: #ff3b30;">清空全部</button>
            </div>
            <div id="sticker-manager-grid"></div>
            <div class="action-buttons" style="margin-top: auto;">
                <button id="save-sticker-changes-btn">完成</button>
            </div>
        </div>
    </div>
    <!-- 批量导入的二级弹窗 -->
    <div id="sticker-import-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>批量导入</h3>
            </div>
            <p style="font-size: 13px; opacity: 0.8; margin: -10px 0 10px;">请粘贴 "描述: 链接" 格式的文本，每行一个。</p>
            <textarea id="sticker-import-textarea" placeholder="例如：&#10;开心: https://.../happy.gif&#10;难过: https://.../sad.png"></textarea>
            <div class="action-buttons">
                <button id="cancel-sticker-import-btn">取消</button>
                <button id="confirm-sticker-import-btn">确认导入</button>
            </div>
        </div>
    </div>

    <!-- 发送语音消息弹窗 -->
    <div id="voice-message-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>发送语音消息</h3>
                <i id="close-voice-modal-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <label for="voice-text-input">请输入你想“说”的话：</label>
                <textarea id="voice-text-input" rows="5" placeholder="这里的文字将被转换成一条语音消息..."></textarea>
            </div>
            <div class="action-buttons">
                <button id="cancel-voice-message-btn">取消</button>
                <button id="send-voice-message-btn">发送</button>
            </div>
        </div>
    </div>

    <!-- 发起转账弹窗 -->
    <div id="transfer-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>发起转账</h3>
                <i id="close-transfer-modal-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <label for="transfer-amount-input">转账金额</label>
                <input type="number" id="transfer-amount-input" placeholder="0.00">
            </div>
            <div class="form-group">
                <label for="transfer-memo-input">留言 (可选)</label>
                <input type="text" id="transfer-memo-input" placeholder="说点什么吧...">
            </div>
            <div class="action-buttons">
                <button id="cancel-transfer-btn">取消</button>
                <button id="confirm-transfer-btn">确认转账</button>
            </div>
        </div>
    </div>
    
    <!-- 钱包浮窗 -->
    <div id="wallet-modal" class="modal-overlay">
        <div class="modal-content" id="wallet-modal-content">
            <div class="modal-header">
                <h3>我的钱包</h3>
                <i id="close-wallet-modal-btn" class="ri-close-line"></i>
            </div>
            <div id="wallet-content-container">
                <div id="total-assets-card">
                    <div class="assets-header">
                        <span>总资产 (信用点)</span>
                    </div>
                    <div id="wallet-balance" class="assets-balance">
                        ¥ 0.00
                    </div>
                </div>
                <div id="transaction-history-section">
                    <div id="transaction-filter-tabs">
                        <button class="filter-tab active" data-filter="all">全部</button>
                        <button class="filter-tab" data-filter="income">收入</button>
                        <button class="filter-tab" data-filter="expense">支出</button>
                    </div>
                    <ul id="transaction-list"></ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 星座运势弹窗 -->
    <div id="horoscope-modal" class="modal-overlay">
        <div class="modal-content" id="horoscope-modal-content">
            <div class="modal-header">
                <h3>今日星座运势</h3>
                <i id="close-horoscope-modal-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <label for="horoscope-select">请选择你的星座</label>
                <select id="horoscope-select">
                    <option value="白羊座">♈ 白羊座</option>
                    <option value="金牛座">♉ 金牛座</option>
                    <option value="双子座">♊ 双子座</option>
                    <option value="巨蟹座">♋ 巨蟹座</option>
                    <option value="狮子座">♌ 狮子座</option>
                    <option value="处女座">♍ 处女座</option>
                    <option value="天秤座">♎ 天秤座</option>
                    <option value="天蝎座">♏ 天蝎座</option>
                    <option value="射手座">♐ 射手座</option>
                    <option value="摩羯座">♑ 摩羯座</option>
                    <option value="水瓶座">♒ 水瓶座</option>
                    <option value="双鱼座">♓ 双鱼座</option>
                </select>
            </div>
            <button id="query-horoscope-btn" class="action-buttons" style="width:100%; justify-content:center;">查询运势</button>
            <div id="horoscope-preview-container"></div>
            <div class="action-buttons">
                <button id="cancel-horoscope-btn">取消</button>
                <button id="send-horoscope-card-btn" disabled>发送</button>
            </div>
        </div>
    </div>
    
    <!-- 心事详情浮窗 -->
    <div id="secret-details-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 420px; max-height: 85vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h3>心事详情</h3>
                <i id="close-secret-details-btn" class="ri-close-line"></i>
            </div>
            <div class="content" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
                <div id="original-secret-container"></div>
                <hr style="border: none; border-top: 1px solid var(--frosted-glass-border); margin: 20px 0;">
                <div id="secret-comments-container"></div>
            </div>
            <div class="chat-input-bar" style="border-radius: 0 0 var(--widget-border-radius) var(--widget-border-radius);">
                <textarea id="secret-comment-input" placeholder="输入你的回应..." rows="1" style="border-radius: 22px;"></textarea>
                <button id="send-secret-comment-btn" class="icon-btn"><i class="ri-mail-check-line"></i></button>
            </div>
        </div>
    </div>
    
    <!-- 添加回忆弹窗 -->
    <div id="add-memory-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>添加一段新回忆</h3>
                <i id="close-memory-modal-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <label for="memory-title-input">回忆标题</label>
                <input type="text" id="memory-title-input" placeholder="给这段回忆起个名字吧">
            </div>
            <div class="form-group">
                <label for="memory-summary-input">回忆纪要</label>
                <textarea id="memory-summary-input" rows="6" placeholder="在这里详细记录下你们之间发生的故事、对话或你的感触..."></textarea>
            </div>
            <div class="action-buttons">
                <button id="cancel-memory-btn">取消</button>
                <button id="save-memory-btn">珍藏回忆</button>
            </div>
        </div>
    </div>

    <!-- 写日记弹窗 -->
    <div id="diary-write-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>写下今日心情</h3>
                <i id="close-diary-write-modal-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <label for="diary-title-input">标题 (可选)</label>
                <input type="text" id="diary-title-input" placeholder="给今天起个名字吧">
            </div>
            <div class="form-group">
                <label for="diary-content-input">正文</label>
                <textarea id="diary-content-input" rows="8" placeholder="记录下你的所思所想..." style="resize: vertical;"></textarea>
            </div>
            <div class="mood-selector" id="diary-mood-selector" style="padding-top: 0; border-top: none;">
                <div class="mood-item" data-mood="happy" title="晴朗">☀️</div>
                <div class="mood-item" data-mood="thoughtful" title="多云">☁️</div>
                <div class="mood-item" data-mood="sad" title="下雨">🌧️</div>
                <div class="mood-item" data-mood="love" title="夜晚">🌙</div>
                <div class="mood-item active" data-mood="normal" title="普通">😊</div>
            </div>
            <div class="action-buttons">
                <button id="save-user-diary-btn">存入日记本</button>
            </div>
        </div>
    </div>

    <!-- 阅读日记弹窗 -->
    <div id="diary-read-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 420px; max-height: 85vh; display: flex; flex-direction: column; font-family: '仿宋', 'KaiTi', serif;">
            <div class="modal-header">
                <h3 id="read-diary-title"></h3>
                <i id="close-diary-read-modal-btn" class="ri-close-line"></i>
            </div>
            <div id="read-diary-content-container" style="flex-grow: 1; overflow-y: auto; padding: 15px;">
                <div id="read-diary-meta" style="display: flex; align-items: center; gap: 10px; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--frosted-glass-border);"></div>
                <p id="read-diary-content" style="line-height: 1.8; font-size: 16px; white-space: pre-wrap;"></p>
            </div>
        </div>
    </div>

    <!-- 电影模式设置弹窗 -->
    <div id="movie-settings-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>导演设置</h3>
                <i id="close-movie-settings-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <label for="movie-opening-prompt">开场白 (选填)</label>
                <textarea id="movie-opening-prompt" rows="5" placeholder="输入一段剧情的序幕，作为故事的开端..."></textarea>
            </div>
            <div class="form-group">
                <label for="movie-response-length">AI叙事篇幅 (建议50-500字)</label>
                <input type="number" id="movie-response-length" value="150" placeholder="例如：150">
            </div>
            <div class="form-group">
                <label>世界观设定 (图书馆)</label>
                <div id="movie-library-select-container" style="max-height: 150px; overflow-y: auto; background: var(--input-bg-color); padding: 10px; border-radius: 8px;"></div>
            </div>
            <div class="action-buttons" style="display: flex; justify-content: space-between; margin-top: 15px;">
                <button id="movie-clear-history-btn" class="danger-button" style="background-color: #ff3b30;">清空剧情</button>
                <button id="save-movie-settings-btn">保存并开始</button>
            </div>
        </div>
    </div>

<!-- vvv 【【【 全新：电影剧情编辑浮窗 】】】 vvv -->
    <div id="movie-edit-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 420px;">
            <div class="modal-header">
                <h3>编辑剧情</h3>
                <i id="close-movie-edit-btn" class="ri-close-line"></i>
            </div>
            <div class="form-group">
                <textarea id="movie-edit-textarea" style="width: 100%; min-height: 250px; resize: vertical; padding: 12px; border-radius: 8px; border: none; background-color: var(--input-bg-color); color: var(--text-color); font-size: 16px; font-family: inherit;"></textarea>
            </div>
            <div class="action-buttons" style="margin-top: 10px;">
                <button id="cancel-movie-edit-btn">取消</button>
                <button id="save-movie-edit-btn">保存修改</button>
            </div>
        </div>
    </div>
    <!-- ^^^ 新浮窗到此结束 ^^^ -->

<!-- vvv 【【【 在这里粘贴新的外观设置浮窗 】】】 vvv -->
    
    <div id="movie-style-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3>导演风格设置</h3>
                <i id="close-movie-style-btn" class="ri-close-line"></i>
            </div>
            <div id="movie-style-settings-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px 20px; padding: 15px 5px; overflow-y: auto;">
                <!-- 文本颜色 -->
                <div class="form-group"><label>旁白</label><input type="color" id="style-color-normal"></div>
                <div class="form-group"><label>内心独白</label><input type="color" id="style-color-thought"></div>
                <div class="form-group"><label>角色对话</label><input type="color" id="style-color-dialogue"></div>
                <div class="form-group"><label>我的输入文字</label><input type="color" id="style-color-user-input"></div>
                <!-- 底部栏颜色 -->
                <div class="form-group"><label>底部栏背景</label><input type="color" id="style-bg-inputbar"></div>
                <div class="form-group"><label>发送按钮背景</label><input type="color" id="style-bg-sendbtn"></div>
                <div class="form-group"><label>发送按钮文字</label><input type="color" id="style-color-sendbtn-text"></div>
            </div>
            <div class="action-buttons" style="margin-top: 10px; justify-content: space-between;">
                <button id="reset-movie-style-btn" style="background-color: var(--input-bg-color);">恢复默认</button>
                <div>
                    <button id="cancel-movie-style-btn">取消</button>
                    <button id="save-movie-style-btn">保存风格</button>
                </div>
            </div>
        </div>
    </div>
    <!-- ^^^ 新浮窗到此结束 ^^^ -->
    
    <!-- 查看撤回消息详情弹窗 -->
    <div id="withdrawn-details-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 380px;">
            <div class="modal-header">
                <h3 id="withdrawn-modal-title"></h3>
                <i id="close-withdrawn-modal-btn" class="ri-close-line"></i>
            </div>
            <div style="display: flex; flex-direction: column; gap: 20px; padding: 10px 0;">
                <div>
                    <label style="font-size: 13px; opacity: 0.6;">被撤回的消息</label>
                    <p id="withdrawn-original-text" style="background: var(--input-bg-color); padding: 10px; border-radius: 8px; margin-top: 5px;"></p>
                </div>
                <div>
                    <label style="font-size: 13px; opacity: 0.6;">角色的内心想法</label>
                    <p id="withdrawn-inner-thought" style="border-left: 3px solid #799181; padding-left: 15px; margin-top: 5px; font-style: italic; opacity: 0.9;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- ======================================================= -->
    <!-- ==== 图层四：特殊小浮层、横幅与全屏覆盖             ==== -->
    <!-- ======================================================= -->
    <!-- 这些元素的z-index通常最高 -->

    <!-- 视频通话全屏浮层 -->
    <div id="video-call-overlay">
        <div class="video-call-header">
            <img id="video-call-character-avatar-small" src="">
            <div class="video-call-time-info">
                <span id="video-call-timer-label">Call time</span>
                <span id="video-call-timer">00:00</span>
            </div>
        </div>
        <div class="video-call-user-view">
            <img id="video-call-user-avatar" src="">
        </div>
        <div class="video-call-subtitles-container">
            <div class="subtitles-box">
                <div id="video-call-status-text">视频连接中...</div>
                <div id="video-call-script-container"></div>
            </div>
            <div id="video-call-typing-indicator">对方正在说话...</div>
        </div>
        <div class="video-call-controls">
            <input type="text" id="video-call-input" placeholder="输入文字..." disabled>
            <button id="video-call-send-btn" class="icon-btn">
                <i class="ri-chat-forward-line"></i>
            </button>
            <button id="video-call-action-btn">
                <span>取消</span>
            </button>
        </div>
    </div>

    <!-- 快拍查看器全屏浮层 -->
    <div id="story-viewer-overlay" class="story-viewer-overlay">
        <div class="story-viewer-header">
            <div id="story-progress-bars" class="story-progress-bars"></div>
            <div class="story-author-info">
                <div id="story-author-avatar" class="story-avatar-small"></div>
                <div class="story-author-details">
                    <span id="story-author-name"></span>
                    <span id="story-timestamp"></span>
                </div>
            </div>
            <div class="story-header-actions">
                <i class="ri-more-fill"></i>
                <i id="close-story-viewer-btn" class="ri-close-line"></i>
            </div>
        </div>
        <div id="story-content-area" class="story-content-area">
            <span id="story-text-content" class="story-text-content"></span>
        </div>
        <div class="story-nav-left"></div>
        <div class="story-nav-right"></div>
        <div id="story-comments-container" class="story-comments-container"></div>
        <div class="story-viewer-footer">
            <i id="story-send-comment-btn" class="ri-chat-1-line story-send-btn"></i>
            <input type="text" id="story-comment-input" placeholder="发消息...">
            <i class="like-btn ri-heart-line"></i>
        </div>
    </div>
    
    <!-- 气泡长按菜单 -->
    <div id="bubble-popover-menu"></div>
    
    <!-- 主题切换小浮窗 -->
    <div id="theme-popover" class="theme-popover">
        <div class="popover-item" data-theme="light">
            <i class="ri-sun-line"></i>
            <span>Light</span>
        </div>
        <div class="popover-item" data-theme="dark">
            <i class="ri-moon-line"></i>
            <span>Dark</span>
        </div>
    </div>
    
    <!-- 全局通知横幅 -->
    <div id="global-notification-banner">
        <div id="notification-avatar" class="chat-avatar"></div>
        <div class="notification-content">
            <span id="notification-title"></span>
            <span id="notification-message"></span>
        </div>
    </div>

    <!-- 视频来电通知横幅 -->
    <div id="incoming-call-banner">
        <div class="call-banner-content">
            <div class="caller-info">
                <div id="caller-avatar" class="chat-avatar"></div>
                <div class="caller-details">
                    <span id="caller-name"></span>
                    <span id="call-type">视频通话</span>
                </div>
            </div>
            <div class="call-actions">
                <button id="decline-call-btn" class="call-action-btn decline">
                    <i class="ri-phone-fill"></i>
                </button>
                <button id="accept-call-btn" class="call-action-btn accept">
                    <i class="ri-vidicon-fill"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- ======================================================= -->
    <!-- ==== 图层五：功能性与隐藏元素 (Utilities)          ==== -->
    <!-- ======================================================= -->
    <!-- 所有非视觉、功能性的元素都集中放在这里 -->
    
    <audio id="audio-player"></audio>
    <input type="file" id="image-uploader" accept="image/jpeg, image/png, image/webp" style="display: none;">
    <input type="file" id="avatar-uploader" accept="image/jpeg, image/png, image/webp" style="display: none;">
    <input type="file" id="character-avatar-uploader" accept="image/jpeg, image/png, image/webp" style="display: none;">
    <input type="file" id="user-avatar-uploader" accept="image/jpeg, image/png, image/webp" style="display: none;">
    <input type="file" id="audio-file-uploader" style="display: none;">
    <input type="file" id="wallpaper-uploader" accept="image/jpeg, image/png, image/webp" style="display: none;">
    <input type="file" id="chat-wallpaper-uploader" accept="image/jpeg, image/png, image/webp" style="display: none;">
    <input type="file" id="global-user-avatar-input" accept="image/*" style="display: none;">
    <input type="file" id="moment-image-file-input" accept="image/*" style="display: none;">
    <input type="file" id="chat-image-uploader" accept="image/jpeg, image/png, image/webp" style="display: none;">
    <input type="file" id="movie-wallpaper-uploader" accept="image/jpeg, image/png, an d/webp" style="display: none;">
<script>
    document.addEventListener('DOMContentLoaded', async () => {

        // =======================================================
        // ========= 1. 全局常量、状态和DOM引用 =================
        // =======================================================

        const CONSTANTS = {
    DB_NAME: 'MyDesktopDB',
    DB_VERSION: 12, // <-- 【核心改动】版本号提升
       MESSAGES_PER_PAGE: 30,
    STORE_NAMES: {
        API_PRESETS: 'api_presets',
        ASSETS: 'assets',
        USER_SETTINGS: 'user_settings',
        PLAYLIST: 'playlist',
        PLAYER_STATE: 'player_state',
        DOSSIERS: 'dossiers',
        CHAT_SESSIONS: 'chatSessions',
        CHAT_HISTORY: 'chatHistory',
        LIBRARY_BOOKS: 'library_books',
        // vvv 【新增】动态功能相关的四张核心数据表 vvv
        MOMENTS: 'moments',               // 动态表 (存放快拍和日常)
        LIKES: 'likes',                   // 点赞表
        COMMENTS: 'comments',             // 评论表
        PENDING_ACTIONS: 'pending_actions',  // AI待办任务表
        WALLET_TRANSACTIONS: 'wallet_transactions', // <-- 新增这行
        SECRETS: 'secrets', // <-- 【新增】心事数据表
        MEMORIES: 'memories', // <-- 【新增】回忆数据表
        DIARIES: 'diaries', // <-- 【新增】日记数据表
              MOVIE_SESSIONS: 'movie_sessions', // <-- 【新增】电影剧情表
              MOVIE_HISTORY: 'movie_history',   // <-- 【新增】电影历史记录表
    },
    BOOK_CATEGORIES: {
        behavior_core: 'AI行为标准',
        worldview: '世界观',
        writing_style: '文风',
        sticker_pack: '表情包',
        html_module: 'HTML模块'
    },
    DEFAULT_FONT_FAMILY: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',

    MOMENT_IMAGE_POOL: {
        story: [
            'https://i.postimg.cc/7ZHgsgJZ/IMG-6888.jpg',
            'https://i.postimg.cc/Jzrb6bHG/IMG-6889.jpg',
            'https://i.postimg.cc/6pWdjd4d/IMG-6890.jpg',
            'https://i.postimg.cc/htD9y9Qr/IMG-6891.jpg'
        ],
        post: [
            'https://i.postimg.cc/JnV0gLd8/IMG-6892.jpg',
            'https://i.postimg.cc/QCSMHWNZ/IMG-6893.jpg',
            'https://i.postimg.cc/3xzx4hhH/IMG-6894.jpg',
            'https://i.postimg.cc/G2C3KjHd/IMG-6895.jpg'
        ]
    },

       STORY_BACKGROUND_COLORS: [
        '#2E4053', // 深邃蓝
        '#7D3C98', // 典雅紫
        '#AF601A', // 琥珀棕
        '#148F77', // 森林绿
        '#B7950B', // 暗金黄
        '#922B21', // 酒红色
    ],

       DEFAULT_MOVIE_STYLES: {
                normal: '#FFFFFF',
                thought: '#EAE0C8',
                dialogue: '#B0B0B0',
                userInput: '#FFFFFF',
                inputBarBg: '#1C1C1E',
                sendBtnBg: '#FFFFFF',
                sendBtnText: '#000000',
            }
};

        const appState = {
            desktopPageIndex: 0,
            playlist: [],
            originalPlaylist: [],
            currentTrackIndex: 0,
            isShuffle: false,
            loopMode: 'none',
            calendarDate: new Date(),
            todos: [],
            apiPresets: [],
            activeApiPreset: null,
            loadedPresetModel: null,
            dossiers: [],
            currentEditingDossierId: null,
            currentCharacterAvatarAssetId: null,
            currentUserAvatarAssetId: null,
            currentWidgetUploadTarget: null,
            currentIconUploadTargetId: null,
            chatSessions: [],
            currentChatHistory: [],
            currentChattingDossierId: null,
longPressedBubble: null, 
quotedMessage: null, // <-- 新增这一行
isMultiSelectMode: false, // <-- 新增：标记是否处于多选模式
selectedMessageIds: new Set(), // <-- 新增：用Set来存储被选中的消息ID，高效且无重复
currentEditingMessageId: null, // 用来存储正在被编辑的消息的ID
isFetchingMoreMessages: false, // <-- 新增这一行
currentEditingBookId: null, // <-- 新增这一行
 // vvv 【新增】快拍查看器相关的状态 vvv
currentViewingStories: [],
currentStoryIndex: 0,
storyTimerId: null,
userLikedMomentIds: new Set(),
    // ^^^ 新增属性到此结束 ^^^
storyStartTime: null,
storyPauseTimestamp: null,
storyTimeRemaining: null,
callTimerIntervalId: null,
activeStickerMap: new Map(), // 用于存储当前聊天会话所有可用的表情
userStickersForManager: new Map(), // 用于暂存管理面板中的表情状态
pendingHoroscopeData: null, // <-- 新增这行
currentViewingSecretId: null, // 用于记录当前打开的“心事主题帖”的ID
replyingToCommentId: null,    // 用于记录正在回复的“某条批注”的ID
currentMovieSession: null,
currentEditingMovieTurnId: null,

        };

        const DOM = {
            body: document.body,
            imageUploader: document.getElementById('image-uploader'),
            audioFileUploader: document.getElementById('audio-file-uploader'),
            wallpaperUploader: document.getElementById('wallpaper-uploader'),
            clock: document.getElementById('clock'),
            themeToggle: document.getElementById('theme-toggle'),
            themeIcon: document.getElementById('theme-icon'),
            themePopover: document.getElementById('theme-popover'),
            swipeArea: document.querySelector('.swipe-area'),
            pageContainer: document.querySelector('.page-container'),
            paginationDots: document.querySelectorAll('.pagination .dot'),
            uploadWidgets: document.querySelectorAll('.upload-widget'),
            customizableIcons: document.querySelectorAll('.customizable-icon'),
            audioPlayer: document.getElementById('audio-player'),
            playerAvatar: document.getElementById('player-avatar'),
            playerAvatarUploader: document.getElementById('avatar-uploader'),
            playerCustomText: document.getElementById('player-custom-text'),
            playerSongTitle: document.getElementById('player-song-title'),
            playPauseBtn: document.getElementById('play-pause-btn'),
            prevBtn: document.getElementById('prev-btn'),
            nextBtn: document.getElementById('next-btn'),
            loopBtn: document.getElementById('loop-btn'),
            shuffleBtn: document.getElementById('shuffle-btn'),
            addMusicBtn: document.getElementById('add-music-btn'),
            progressBar: document.getElementById('progress-bar'),
            progressFill: document.getElementById('progress-fill'),
            currentTime: document.getElementById('current-time'),
            totalTime: document.getElementById('total-time'),
            addMusicModal: document.getElementById('add-music-modal'),
            closeMusicModalBtn: document.getElementById('close-modal-btn'),
            addUrlBtn: document.getElementById('add-url-btn'),
            songUrlInput: document.getElementById('song-url-input'),
            uploadLocalFileBtn: document.getElementById('upload-local-file-btn'),
            playlistContainer: document.getElementById('playlist-container'),
            calendarMonthYear: document.getElementById('calendar-month-year'),
            calendarPrevBtn: document.getElementById('prev-month-btn'),
            calendarNextBtn: document.getElementById('next-month-btn'),
            calendarDatesGrid: document.getElementById('calendar-dates-grid'),
            todoList: document.getElementById('todo-list'),
            todoForm: document.getElementById('todo-add-form'),
            todoInput: document.getElementById('todo-input'),
            settingsNavigator: document.getElementById('settings-navigator'),
            settingsPages: document.querySelectorAll('.settings-page'),
            iconSettings: document.getElementById('icon-settings'),
            settingsBackBtns: document.querySelectorAll('#settings-navigator .back-button'),
            gotoApiSettings: document.getElementById('goto-api-settings'),
            gotoAppearanceSettings: document.getElementById('goto-appearance-settings'),
            apiPresetSelect: document.getElementById('api-preset-select'),
            loadPresetButton: document.getElementById('load-preset-button'),
            deletePresetButton: document.getElementById('delete-preset-button'),
            apiNameInput: document.getElementById('api-name'),
            apiUrlInput: document.getElementById('api-url'),
            apiKeyInput: document.getElementById('api-key'),
            apiModelSelect: document.getElementById('api-model-select'),
            fetchModelsButton: document.getElementById('fetch-models-button'),
            setActiveApiButton: document.getElementById('set-active-api-button'),
            saveApiSettingsButton: document.getElementById('save-settings-button'),
            setWallpaperItem: document.getElementById('set-wallpaper-item'),
            gotoIconSettings: document.getElementById('goto-icon-settings'),
            gotoFontSettings: document.getElementById('goto-font-settings'),
            iconSettingsGrid: document.getElementById('icon-settings-grid'),
            fontPresetSelect: document.getElementById('font-preset-select'),
            loadFontButton: document.getElementById('load-font-button'),
            deleteFontButton: document.getElementById('delete-font-button'),
            fontNameInput: document.getElementById('font-name-input'),
            fontUrlInput: document.getElementById('font-url-input'),
            applyFontButton: document.getElementById('apply-font-button'),
            clearFontButton: document.getElementById('clear-font-button'),
            fontSizeSlider: document.getElementById('font-size-slider'),
            fontSizeValue: document.getElementById('font-size-value'),
            archiveApp: document.getElementById('archive-app'),
            archiveAppPages: document.querySelectorAll('#archive-app .app-page'),
            iconArchive: document.getElementById('icon-archive'),
            archiveBackBtns: document.querySelectorAll('#archive-app .back-button'),
            addDossierBtn: document.getElementById('add-dossier-btn'),
            archiveList: document.getElementById('archive-list'),
            creationPage: document.getElementById('creation-page'),
            charNameInput: document.getElementById('character-name-input'),
            charBgInput: document.getElementById('character-background-input'),
            charAvatarArea: document.getElementById('character-avatar-upload-area'),
            charAvatarUploader: document.getElementById('character-avatar-uploader'),
            userNameInput: document.getElementById('user-name-input'),
            userBgInput: document.getElementById('user-background-input'),
            userAvatarArea: document.getElementById('user-avatar-upload-area'),
            userAvatarUploader: document.getElementById('user-avatar-uploader'),
            saveDossierBtn: document.getElementById('save-dossier-btn'),
            deleteDossierBtn: document.getElementById('delete-dossier-btn'),
            dossierModalOverlay: document.getElementById('dossier-modal-overlay'),
            closeDossierBtn: document.getElementById('close-dossier-btn'),
            modalDossierAvatar: document.getElementById('modal-dossier-avatar'),
            modalDossierName: document.getElementById('modal-dossier-name'),
            modalDossierPersonality: document.getElementById('modal-dossier-personality'),
            modalDossierLikes: document.getElementById('modal-dossier-likes'),
            modalDossierQuote: document.getElementById('modal-dossier-quote'),
            modalDossierBackground: document.getElementById('modal-dossier-background'),
            editDossierBtn: document.getElementById('edit-dossier-btn'),
            chatApp: document.getElementById('app-chat'),
            iconChat: document.getElementById('icon-chat'),
            chatList: document.getElementById('chat-list'), // 确保这个ID被正确获取
            chatBackBtns: document.querySelectorAll('#app-chat .back-button'),
            chatHeaderTitle: document.getElementById('chat-header-title'),
            chatTabItems: document.querySelectorAll('#app-chat .tab-item'),
            chatContentPanes: document.querySelectorAll('#app-chat .content-pane'),
            newChatBtn: document.getElementById('new-chat-btn'),
            newChatModal: document.getElementById('new-chat-modal'),
            closeChatModalBtn: document.getElementById('close-chat-modal-btn'),
            characterSelectList: document.getElementById('character-select-list'),
            chatDialoguePage: document.getElementById('chat-dialogue-page'),
            dialogueHeaderTitle: document.getElementById('chat-dialogue-header-title'),
            chatMoreBtn: document.getElementById('chat-more-btn'),
            messagesContainer: document.getElementById('chat-messages-container'),
            chatInput: document.getElementById('chat-input-textarea'),
            sendBufferBtn: document.getElementById('send-buffer-btn'),
            sendFinalBtn: document.getElementById('send-final-btn'),
            // vvv 在这里新增一行 vvv
    setChatWallpaperItem: document.getElementById('set-chat-wallpaper-item'),
     // vvv 新增这一行 vvv
chatWallpaperUploader: document.getElementById('chat-wallpaper-uploader'),
          // vvv 在末尾添加以下引用 vvv
    notificationBanner: document.getElementById('global-notification-banner'),
    notificationAvatar: document.getElementById('notification-avatar'),
    notificationTitle: document.getElementById('notification-title'),
    notificationMessage: document.getElementById('notification-message'),
// vvv 在末尾添加以下新引用 vvv
    setMemoryRoundsItem: document.getElementById('set-memory-rounds-item'),
    memoryRoundsModal: document.getElementById('memory-rounds-modal'),
    closeMemoryRoundsBtn: document.getElementById('close-memory-rounds-btn'),
    memoryRoundsSlider: document.getElementById('memory-rounds-slider'),
    memoryRoundsValue: document.getElementById('memory-rounds-value'),
    saveMemoryRoundsBtn: document.getElementById('save-memory-rounds-btn'),
    timePerceptionToggle: document.getElementById('time-perception-toggle'),
    pinChatToggle: document.getElementById('pin-chat-toggle'),
    clearHistoryBtn: document.getElementById('clear-history-btn'),
    deleteConversationBtn: document.getElementById('delete-conversation-btn'),
    bubblePopoverMenu: document.getElementById('bubble-popover-menu'),
    replyPreviewContainer: document.getElementById('reply-preview-container'),
    replyAuthor: document.getElementById('reply-author'),
    replyText: document.getElementById('reply-text'),
    closeReplyBtn: document.getElementById('close-reply-btn'),
    multiSelectToolbar: document.getElementById('multi-select-toolbar'),
    multiSelectCounter: document.getElementById('multi-select-counter'),
    deleteSelectedBtn: document.getElementById('delete-selected-btn'),
    exitMultiSelectBtn: document.getElementById('exit-multi-select-btn'),
    withdrawnDetailsModal: document.getElementById('withdrawn-details-modal'),
    closeWithdrawnModalBtn: document.getElementById('close-withdrawn-modal-btn'),
    withdrawnModalTitle: document.getElementById('withdrawn-modal-title'),
    withdrawnOriginalText: document.getElementById('withdrawn-original-text'),
    withdrawnInnerThought: document.getElementById('withdrawn-inner-thought'),
    editMessageModal: document.getElementById('edit-message-modal'),
    closeEditModalBtn: document.getElementById('close-edit-modal-btn'),
    cancelEditBtn: document.getElementById('cancel-edit-btn'),
    saveEditBtn: document.getElementById('save-edit-btn'),
    editMessageTextarea: document.getElementById('edit-message-textarea'),
    openLibraryApp: document.getElementById('open-library-app'),
    libraryApp: document.getElementById('library-app'),
    libraryBackBtns: document.querySelectorAll('#library-app .back-button'),
    libraryListContainer: document.getElementById('library-list-container'),
    addBookBtn: document.getElementById('add-book-btn'),
    
    // 创建页面
    createBookTitle: document.getElementById('create-book-title'),
    createBookIsGlobal: document.getElementById('create-book-is-global'),
    createBookCategory: document.getElementById('create-book-category'),
    createBookContent: document.getElementById('create-book-content'),
    saveNewBookBtn: document.getElementById('save-new-book-btn'),

    // 编辑浮窗
    bookEditModal: document.getElementById('book-edit-modal'),
    closeBookEditModalBtn: document.getElementById('close-book-edit-modal-btn'),
    editBookTitle: document.getElementById('edit-book-title'),
    editBookIsGlobal: document.getElementById('edit-book-is-global'),
    editBookCategory: document.getElementById('edit-book-category'),
    editBookContent: document.getElementById('edit-book-content'),
    saveBookChangesBtn: document.getElementById('save-book-changes-btn'),
    deleteBookBtn: document.getElementById('delete-book-btn'),
    manageExclusiveBooksItem: document.getElementById('manage-exclusive-books-item'),
    linkedBooksCount: document.getElementById('linked-books-count'),
    bookLinkModal: document.getElementById('book-link-modal'),
    closeBookLinkModalBtn: document.getElementById('close-book-link-modal-btn'),
    bookLinkList: document.getElementById('book-link-list'),
    saveBookLinksBtn: document.getElementById('save-book-links-btn'),
    storyViewerOverlay: document.getElementById('story-viewer-overlay'),
    storyProgressBars: document.getElementById('story-progress-bars'),
    storyAuthorAvatar: document.getElementById('story-author-avatar'),
    storyAuthorName: document.getElementById('story-author-name'),
    storyTimestamp: document.getElementById('story-timestamp'),
    closeStoryViewerBtn: document.getElementById('close-story-viewer-btn'),
    storyContentArea: document.getElementById('story-content-area'),
    storyTextContent: document.getElementById('story-text-content'),
    storyNavLeft: document.querySelector('.story-nav-left'),
    storyNavRight: document.querySelector('.story-nav-right'),
    storyViewerFooter: document.querySelector('.story-viewer-footer'),
    storyCommentInput: document.getElementById('story-comment-input'),
    storySendCommentBtn: document.getElementById('story-send-comment-btn'),
    storyCommentsContainer: document.getElementById('story-comments-container'),
    momentCreatorApp: document.getElementById('moment-creator-app'),
    momentCreatorBackBtn: document.querySelector('#moment-creator-app .back-button'),
    userMomentAvatarUploader: document.getElementById('user-moment-avatar-uploader'),
    globalUserAvatarInput: document.getElementById('global-user-avatar-input'),
    momentTypeSelector: document.querySelector('.moment-type-selector'),
    momentContentInput: document.getElementById('moment-content-input'),
    momentImageUploader: document.getElementById('moment-image-uploader'),
    momentImageFileInput: document.getElementById('moment-image-file-input'),
    publishMomentBtn: document.getElementById('publish-moment-btn'),
    emojiBtn: document.getElementById('emoji-btn'),
    stickerPanel: document.getElementById('sticker-panel'),
    stickerGridContainer: document.getElementById('sticker-grid-container'),
    manageStickersBtn: document.getElementById('manage-stickers-btn'),
    stickerManagerModal: document.getElementById('sticker-manager-modal'),
    closeStickerManagerBtn: document.getElementById('close-sticker-manager-btn'),
    stickerManagerGrid: document.getElementById('sticker-manager-grid'),
    batchImportStickersBtn: document.getElementById('batch-import-stickers-btn'),
    clearAllStickersBtn: document.getElementById('clear-all-stickers-btn'),
    saveStickerChangesBtn: document.getElementById('save-sticker-changes-btn'),
    stickerImportModal: document.getElementById('sticker-import-modal'),
    stickerImportTextarea: document.getElementById('sticker-import-textarea'),
    confirmStickerImportBtn: document.getElementById('confirm-sticker-import-btn'),
    cancelStickerImportBtn: document.getElementById('cancel-sticker-import-btn'),
    chatFunctionBtn: document.getElementById('chat-function-btn'),
    chatFunctionPanel: document.getElementById('chat-function-panel'),
    chatImageUploader: document.getElementById('chat-image-uploader'),
    funcSendVideo: document.getElementById('func-send-video'),
    videoCallOverlay: document.getElementById('video-call-overlay'),
    videoCallUserAvatar: document.getElementById('video-call-user-avatar'),
    videoCallStatusText: document.getElementById('video-call-status-text'),
    videoCallInput: document.getElementById('video-call-input'),
    videoCallActionBtn: document.getElementById('video-call-action-btn'),
    videoCallSendBtn: document.getElementById('video-call-send-btn'),
    videoCallHeader: document.querySelector('.video-call-header'),
    videoCallCharacterAvatarSmall: document.getElementById('video-call-character-avatar-small'),
    videoCallTimer: document.getElementById('video-call-timer'),
    videoCallTypingIndicator: document.getElementById('video-call-typing-indicator'),
    videoCallScriptContainer: document.getElementById('video-call-script-container'),
    funcVoiceInput: document.getElementById('func-voice-input'),
    voiceMessageModal: document.getElementById('voice-message-modal'),
    closeVoiceModalBtn: document.getElementById('close-voice-modal-btn'),
    cancelVoiceMessageBtn: document.getElementById('cancel-voice-message-btn'),
    sendVoiceMessageBtn: document.getElementById('send-voice-message-btn'),
    voiceTextInput: document.getElementById('voice-text-input'),
    funcTransfer: document.getElementById('func-transfer'),
    transferModal: document.getElementById('transfer-modal'),
    closeTransferModalBtn: document.getElementById('close-transfer-modal-btn'),
    cancelTransferBtn: document.getElementById('cancel-transfer-btn'),
    confirmTransferBtn: document.getElementById('confirm-transfer-btn'),
    transferAmountInput: document.getElementById('transfer-amount-input'),
    transferMemoInput: document.getElementById('transfer-memo-input'),
    walletModal: document.getElementById('wallet-modal'),
    funcWallet: document.getElementById('func-wallet'),
    closeWalletModalBtn: document.getElementById('close-wallet-modal-btn'),
    walletBalance: document.getElementById('wallet-balance'),
    transactionList: document.getElementById('transaction-list'),
    transactionFilterTabs: document.getElementById('transaction-filter-tabs'),
    funcHoroscope: document.getElementById('func-horoscope'),
    horoscopeModal: document.getElementById('horoscope-modal'),
    closeHoroscopeModalBtn: document.getElementById('close-horoscope-modal-btn'),
    horoscopeSelect: document.getElementById('horoscope-select'),
    queryHoroscopeBtn: document.getElementById('query-horoscope-btn'),
    horoscopePreviewContainer: document.getElementById('horoscope-preview-container'),
    cancelHoroscopeBtn: document.getElementById('cancel-horoscope-btn'),
    sendHoroscopeCardBtn: document.getElementById('send-horoscope-card-btn'),
    secretsCreationPage: document.getElementById('secrets-creation-page'),
        secretTitleInput: document.getElementById('secret-title-input'),
        secretContentInput: document.getElementById('secret-content-input'),
        moodSelector: document.querySelector('.mood-selector'),
        publishSecretBtn: document.getElementById('publish-secret-btn'),
        secretsListContainer: document.getElementById('secrets-list-container'),
        // 新增详情页的引用
        secretDetailsModal: document.getElementById('secret-details-modal'),
        closeSecretDetailsBtn: document.getElementById('close-secret-details-btn'),
        originalSecretContainer: document.getElementById('original-secret-container'),
        secretCommentsContainer: document.getElementById('secret-comments-container'),
        secretCommentInput: document.getElementById('secret-comment-input'),
        sendSecretCommentBtn: document.getElementById('send-secret-comment-btn'),
        memoryDetailsPage: document.getElementById('memory-details-page'),
    memoryDetailsHeaderTitle: document.getElementById('memory-details-header-title'),
    memoryScrapbookContainer: document.getElementById('memory-scrapbook-container'),
    addMemoryBtn: document.getElementById('add-memory-btn'),
    addMemoryModal: document.getElementById('add-memory-modal'),
    closeMemoryModalBtn: document.getElementById('close-memory-modal-btn'),
    cancelMemoryBtn: document.getElementById('cancel-memory-btn'),
    saveMemoryBtn: document.getElementById('save-memory-btn'),
    memoryTitleInput: document.getElementById('memory-title-input'),
    memorySummaryInput: document.getElementById('memory-summary-input'),
    soulEchoIcon: document.getElementById('soul-echo-settings'),
    diaryApp: document.getElementById('diary-app'),
    diaryMainPage: document.getElementById('diary-main-page'),
    diaryBackBtn: document.querySelector('#diary-app .back-button'),
    diaryListContainer: document.getElementById('diary-list-container'),
    addUserDiaryBtn: document.getElementById('add-user-diary-btn'),
    
    diaryWriteModal: document.getElementById('diary-write-modal'),
    closeDiaryWriteModalBtn: document.getElementById('close-diary-write-modal-btn'),
    diaryTitleInput: document.getElementById('diary-title-input'),
    diaryContentInput: document.getElementById('diary-content-input'),
    diaryMoodSelector: document.getElementById('diary-mood-selector'),
    saveUserDiaryBtn: document.getElementById('save-user-diary-btn'),

    diaryReadModal: document.getElementById('diary-read-modal'),
    closeDiaryReadModalBtn: document.getElementById('close-diary-read-modal-btn'),
    readDiaryTitle: document.getElementById('read-diary-title'),
    readDiaryMeta: document.getElementById('read-diary-meta'),
    readDiaryContent: document.getElementById('read-diary-content'),
    iconMovie: document.getElementById('icon-story'),
    movieApp: document.getElementById('movie-app'),
    movieBackBtns: document.querySelectorAll('#movie-app .back-button'),
    moviePosterGrid: document.getElementById('movie-poster-grid'),
    movieStoryPage: document.getElementById('movie-story-page'),
    movieCharacterName: document.getElementById('movie-character-name'),
    movieSettingsBtn: document.getElementById('movie-settings-btn'),
    movieScreenContainer: document.getElementById('movie-screen-container'),
    movieInput: document.getElementById('movie-input'),
    movieSendBtn: document.getElementById('movie-send-btn'),
    
    movieSettingsModal: document.getElementById('movie-settings-modal'),
    closeMovieSettingsBtn: document.getElementById('close-movie-settings-btn'),
    movieOpeningPrompt: document.getElementById('movie-opening-prompt'),
    movieResponseLength: document.getElementById('movie-response-length'),
    movieLibrarySelectContainer: document.getElementById('movie-library-select-container'),
    movieClearHistoryBtn: document.getElementById('movie-clear-history-btn'),
    saveMovieSettingsBtn: document.getElementById('save-movie-settings-btn'),
    movieEditModal: document.getElementById('movie-edit-modal'),
    closeMovieEditBtn: document.getElementById('close-movie-edit-btn'),
    cancelMovieEditBtn: document.getElementById('cancel-movie-edit-btn'),
    saveMovieEditBtn: document.getElementById('save-movie-edit-btn'),
    movieEditTextarea: document.getElementById('movie-edit-textarea'),
   movieInputBar: document.getElementById('movie-input-bar'),
   movieInputCard: document.querySelector('#movie-input-bar .input-card'),
   movieWallpaperUploadBtn: document.querySelector('#movie-input-bar .action-icons .ri-image-add-line'), 
   movieStyleBtn: document.querySelector('#movie-input-bar .action-icons .ri-attachment-line'),       
    movieWallpaperUploader: document.getElementById('movie-wallpaper-uploader'),
    movieStyleModal: document.getElementById('movie-style-modal'),
    closeMovieStyleBtn: document.getElementById('close-movie-style-btn'),
    cancelMovieStyleBtn: document.getElementById('cancel-movie-style-btn'),
            saveMovieStyleBtn: document.getElementById('save-movie-style-btn'),
            resetMovieStyleBtn: document.getElementById('reset-movie-style-btn'),
            movieStyleSettingsGrid: document.getElementById('movie-style-settings-grid'),
            // 颜色选择器
            styleInputs: {
                normal: document.getElementById('style-color-normal'),
                thought: document.getElementById('style-color-thought'),
                dialogue: document.getElementById('style-color-dialogue'),
                userInput: document.getElementById('style-color-user-input'),
                inputBarBg: document.getElementById('style-bg-inputbar'),
                sendBtnBg: document.getElementById('style-bg-sendbtn'),
                sendBtnText: document.getElementById('style-color-sendbtn-text'),
            }
};

        // =======================================================
        // ============ 2. 核心助手模块 (数据库, API, 工具) ========
        // =======================================================

        const dbHelper = {
            dbPromise: null,
            init() {
                this.dbPromise = idb.openDB(CONSTANTS.DB_NAME, CONSTANTS.DB_VERSION, {
                    upgrade(db, oldVersion, newVersion, tx) {
                        // vvv 粘贴这个【全新的】代码块 vvv
const allStores = {
    // 已有数据表
    [CONSTANTS.STORE_NAMES.API_PRESETS]: { options: { keyPath: 'name' } },
    [CONSTANTS.STORE_NAMES.ASSETS]: { options: { keyPath: 'id', autoIncrement: true } },
    [CONSTANTS.STORE_NAMES.USER_SETTINGS]: { options: {} },
    [CONSTANTS.STORE_NAMES.PLAYLIST]: { options: { keyPath: 'id', autoIncrement: true } },
    [CONSTANTS.STORE_NAMES.PLAYER_STATE]: { options: {} },
    [CONSTANTS.STORE_NAMES.DOSSIERS]: { options: { keyPath: 'id', autoIncrement: true } },
    [CONSTANTS.STORE_NAMES.CHAT_SESSIONS]: { options: { keyPath: 'dossierId' } },
    [CONSTANTS.STORE_NAMES.CHAT_HISTORY]: { options: { keyPath: 'id', autoIncrement: true }, indexes: { 'by_dossierId': 'dossierId' } },
    [CONSTANTS.STORE_NAMES.LIBRARY_BOOKS]: { options: { keyPath: 'id', autoIncrement: true } },

    // 【新增】动态功能相关的四张核心数据表
    [CONSTANTS.STORE_NAMES.MOMENTS]: { 
        options: { keyPath: 'id', autoIncrement: true }, 
        indexes: { 'by_dossierId': 'dossierId' } 
    },
    [CONSTANTS.STORE_NAMES.LIKES]: { 
        options: { keyPath: 'id', autoIncrement: true }, 
        indexes: { 'by_momentId': 'momentId' } 
    },
    [CONSTANTS.STORE_NAMES.COMMENTS]: { 
        options: { keyPath: 'id', autoIncrement: true }, 
        indexes: { 'by_momentId': 'momentId' } 
    },
    [CONSTANTS.STORE_NAMES.PENDING_ACTIONS]: { 
        options: { keyPath: 'id', autoIncrement: true }, 
        indexes: { 'by_status_and_time': ['status', 'executeAt'] } // 复合索引，用于高效查询到期任务
    },
[CONSTANTS.STORE_NAMES.WALLET_TRANSACTIONS]: {
    options: { keyPath: 'id', autoIncrement: true },
    indexes: { 'by_timestamp': 'timestamp' } // 按时间索引，方便排序
    },
 [CONSTANTS.STORE_NAMES.MEMORIES]: {
            options: { keyPath: 'id', autoIncrement: true },
            indexes: { 'by_dossierId': 'dossierId' }
        },   
[CONSTANTS.STORE_NAMES.SECRETS]: {
                                options: { keyPath: 'id', autoIncrement: true },
                                // 为 parentId 和 authorType 创建索引，方便我们快速查询
                                indexes: { 
                         'by_parentId': 'parentId',
                                    'by_authorType': 'authorType'
                                }
                            },
[CONSTANTS.STORE_NAMES.DIARIES]: { // <-- 【新增】
            options: { keyPath: 'id', autoIncrement: true },
            indexes: { 'by_author': ['authorType', 'authorId'] }
        },
[CONSTANTS.STORE_NAMES.MOVIE_SESSIONS]: { options: { keyPath: 'dossierId' } 
           },   [CONSTANTS.STORE_NAMES.MOVIE_HISTORY]: { options: { keyPath: 'id', autoIncrement: true }, indexes: { 'by_dossierId': 'dossierId' } 
           },

};

for (const storeName in allStores) {
    if (!db.objectStoreNames.contains(storeName)) {
        const storeConfig = allStores[storeName];
        const store = db.createObjectStore(storeName, storeConfig.options);
        if (storeConfig.indexes) {
            for (const indexName in storeConfig.indexes) {
                store.createIndex(indexName, storeConfig.indexes[indexName]);
            }
        }
    }
}
// ^^^ 新代码块到此结束 ^^^
                    },
                });
                return this.dbPromise;
            },
            async get(storeName, key) { return (await this.dbPromise).get(storeName, key); },
            async getAll(storeName) { return (await this.dbPromise).getAll(storeName); },
            async set(storeName, value, key) { return (await this.dbPromise).put(storeName, value, key); },
            async add(storeName, value) { return (await this.dbPromise).add(storeName, value); },
            async delete(storeName, key) { return (await this.dbPromise).delete(storeName, key); },
            async getHistoryForDossier(dossierId) {
                const db = await this.dbPromise;
                return db.getAllFromIndex(CONSTANTS.STORE_NAMES.CHAT_HISTORY, 'by_dossierId', dossierId);
            },
// vvv 在这里添加全新的数据库删除函数 vvv
    async deleteHistoryForDossier(dossierId) {
        const db = await this.dbPromise;
        // 开启一个读写事务
        const tx = db.transaction(CONSTANTS.STORE_NAMES.CHAT_HISTORY, 'readwrite');
        const index = tx.store.index('by_dossierId');
        // 打开一个指向特定dossierId的游标
        let cursor = await index.openCursor(dossierId);
        // 遍历并删除所有匹配的记录
        while (cursor) {
            cursor.delete();
            cursor = await cursor.continue();
        }
        // 等待事务完成
        return tx.done;
    },
// vvv 用这个【不会删除档案】的函数，替换掉之前那个错误的函数 vvv
    async deleteConversationData(dossierId) {
        const db = await this.dbPromise;
        
        const tx = db.transaction([
            CONSTANTS.STORE_NAMES.CHAT_SESSIONS,
            CONSTANTS.STORE_NAMES.CHAT_HISTORY
        ], 'readwrite');

        // 1. 删除对应的聊天会话
        await tx.objectStore(CONSTANTS.STORE_NAMES.CHAT_SESSIONS).delete(dossierId);
        
        // 2. 删除所有相关的聊天记录
        const historyStore = tx.objectStore(CONSTANTS.STORE_NAMES.CHAT_HISTORY);
        const historyIndex = historyStore.index('by_dossierId');
        let cursor = await historyIndex.openCursor(dossierId);
        while (cursor) {
            cursor.delete();
            cursor = await cursor.continue();
        }

        // 等待所有操作完成
        return tx.done;
    },
 // vvv 在末尾添加全新的批量删除函数 vvv
    async deleteMessagesByIds(ids) {
        const db = await this.dbPromise;
        const tx = db.transaction(CONSTANTS.STORE_NAMES.CHAT_HISTORY, 'readwrite');
        // 将Set转换为数组，并对每个ID执行删除操作
        await Promise.all([...ids].map(id => tx.store.delete(id)));
        return tx.done;
    },
// (在 dbHelper 对象的末尾)
    async deleteMessagesByIds(ids) {
        const db = await this.dbPromise;
        const tx = db.transaction(CONSTANTS.STORE_NAMES.CHAT_HISTORY, 'readwrite');
        await Promise.all([...ids].map(id => tx.store.delete(id)));
        return tx.done;
    },

    // vvv 【新增】点赞功能所需的数据库工具 vvv
    async findLike(momentId, likerId) {
        const db = await this.dbPromise;
        const allLikes = await db.getAllFromIndex(CONSTANTS.STORE_NAMES.LIKES, 'by_momentId', momentId);
        return allLikes.find(like => like.likerId === likerId);
    },
    async getUserLikes() {
        // 为了性能，我们只获取ID，并返回一个Set，用于快速查找
        const db = await this.dbPromise;
        const allLikes = await db.getAll(CONSTANTS.STORE_NAMES.LIKES);
        const userLikedMomentIds = new Set();
        allLikes.forEach(like => {
            if (like.likerType === 'user') {
                userLikedMomentIds.add(like.momentId);
            }
        });
        return userLikedMomentIds;
    },
    // ^^^ 新工具到此结束 ^^^
async getDuePendingActions() {
        const db = await this.dbPromise;
        const now = Date.now();
        // 使用我们之前创建的 'by_status_and_time' 索引
        // IDBKeyRange.bound(['pending', 0], ['pending', now]) 的意思是：
        // 查找所有 status='pending' 且 executeAt 在 0 到 当前时间 之间的记录
        return db.getAllFromIndex(
            CONSTANTS.STORE_NAMES.PENDING_ACTIONS, 
            'by_status_and_time',
            IDBKeyRange.bound(['pending', 0], ['pending', now])
        );
    },

    // vvv 【新增】更新待办任务状态的函数 vvv
    async updatePendingActionStatus(actionId, newStatus) {
        const db = await this.dbPromise;
        const action = await db.get(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, actionId);
        if (action) {
            action.status = newStatus;
            return db.put(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, action);
        }
    },

    async deleteMomentAndAssociations(momentId) {
        const db = await this.dbPromise;
        // 开启一个涉及三个表的大型事务
        const tx = db.transaction([
            CONSTANTS.STORE_NAMES.MOMENTS,
            CONSTANTS.STORE_NAMES.COMMENTS,
            CONSTANTS.STORE_NAMES.LIKES
        ], 'readwrite');

        // 1. 直接删除动态本身
        await tx.objectStore(CONSTANTS.STORE_NAMES.MOMENTS).delete(momentId);

        // 2. 遍历并删除所有相关的评论
        const commentsStore = tx.objectStore(CONSTANTS.STORE_NAMES.COMMENTS);
        const commentsIndex = commentsStore.index('by_momentId');
        let commentsCursor = await commentsIndex.openCursor(momentId);
        while (commentsCursor) {
            commentsCursor.delete();
            commentsCursor = await commentsCursor.continue();
        }

        // 3. 遍历并删除所有相关的点赞
        const likesStore = tx.objectStore(CONSTANTS.STORE_NAMES.LIKES);
        const likesIndex = likesStore.index('by_momentId');
        let likesCursor = await likesIndex.openCursor(momentId);
        while (likesCursor) {
            likesCursor.delete();
            likesCursor = await likesCursor.continue();
        }

        // 等待整个事务完成
        return tx.done;
    },
    
    /**
             * 【全新】级联删除一条心事及其所有回应
             * @param {number} secretId - 要删除的“主题帖”心事的ID
             */
            async deleteSecretAndResponses(secretId) {
                const db = await this.dbPromise;
                
                // 1. 开启一个涉及 'secrets' 表的读写事务
                const tx = db.transaction(CONSTANTS.STORE_NAMES.SECRETS, 'readwrite');
                
                // 2. 首先，直接删除“主题帖”本身
                await tx.store.delete(secretId);

                // 3. 然后，使用我们为 parentId 创建的索引，找到所有相关的回应
                const index = tx.store.index('by_parentId');
                let cursor = await index.openCursor(secretId);
                
                // 4. 遍历并删除所有找到的回应
                while (cursor) {
                    cursor.delete(); // 删除当前游标指向的记录
                    cursor = await cursor.continue(); // 移动到下一个
                }
                
                // 5. 等待整个事务完成
                return tx.done;
            }
        };

        const apiHelper = {
            async _callChatAPI(messages) {
                const preset = appState.activeApiPreset;
                if (!preset) throw new Error("未设置当前 API。");
                if (!preset.url || !preset.key || !preset.model) throw new Error("当前 API 配置无效或不完整。");
                
                // 【核心升级】智能处理多模态消息
                const processedMessages = messages.map(msg => {
                    if (Array.isArray(msg.content)) { // 这是我们为识图设定的新格式
                        return {
                            role: msg.role,
                            content: msg.content.map(part => {
                                if (part.type === 'image_url') {
                                    return {
                                        type: 'image_url',
                                        image_url: part.image_url,
                                    };
                                }
                                return part; // text part
                            })
                        };
                    }
                    return msg;
                });

                const requestBody = { model: preset.model, messages: processedMessages, temperature: 0.7, stream: false };
console.log('📦 发送给 AI 的最终数据包:', JSON.stringify(requestBody, null, 2));
                let url = preset.url.trim();
                if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
                url = url.replace(/\/$/, "");
                const apiUrl = url.endsWith('/v1') ? `${url}/chat/completions` : `${url}/v1/chat/completions`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${preset.key}` },
                    body: JSON.stringify(requestBody)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`API 请求失败 (${response.status}): ${errorData.error?.message || response.statusText}`);
                }
                const result = await response.json();
                const content = result.choices[0]?.message?.content;
                if (!content) throw new Error("API 返回了无效的响应内容。");
                return content;
            },
            async getChatCompletion(messages) { return this._callChatAPI(messages); },
            async generateDossierDetails(characterName, characterBackground) {
                const prompt = `你是一个精准的角色档案分析与生成器。你的首要任务是**严格、优先地从用户提供的人设背景中提取信息**。\n\n角色名: ${characterName}\n人设背景: ${characterBackground}\n\n请严格按照以下JSON格式返回，不要包含任何额外的解释或说明。所有字段都必须存在。\n\n{\n  "personality": "必须优先从人设背景中直接提取或总结出角色的性格特质，概括为3-5个关键词。如果背景中没有明确提及，再进行合理推断。",\n  "likes": "必须优先从人设背景中直接提取明确提及的喜好，并总结为3-5个关键词。如果背景中没有明确提及，再根据性格进行合理推断。如果无法推断，则填写'待定'。",\n  "quote": "一句最能代表该角色的经典语录。如果人设背景中有合适的句子，可以直接引用。",\n  "detailedBackground": "根据提供的人设背景，总结并提炼出最核心的摘要，要求语言精练，不超过50字。"\n}`;
                const content = await this._callChatAPI([{ role: "user", content: prompt }]);
                try {
                    const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
                    const jsonString = jsonMatch ? jsonMatch[1] : content;
                    return JSON.parse(jsonString);
                } catch (e) { throw new Error("无法解析 API 返回的 JSON 数据。"); }
            }
        };

// =======================================================
// ============ 2.5. 新增：专用图片压缩助手 ================
// =======================================================

/**
 * 【显示专用】为UI元素（如头像、壁纸）进行高质量压缩
 * 目标：在保证视觉清晰度的前提下, 减小文件体积。
 */
async function compressImageForDisplay(file) {
    const options = {
        maxSizeMB: 1,
        maxWidthOrHeight: 1280,
        initialQuality: 0.9,
        useWebWorker: true,
    };
    try {
        return await imageCompression(file, options);
    } catch (error) {
        console.error("Display image compression failed:", error);
        utils.showToast('图片压缩失败！');
        throw error;
    }
}

/**
 * 【AI识别专用】为发送给AI模型的图片进行强力压缩
 * 目标：在保留核心可识别信息的前提下, 最大限度地减小Token成本和体积。
 */
async function compressImageForAI(file) {
    const options = {
        maxSizeMB: 0.4,
        maxWidthOrHeight: 768,
        initialQuality: 0.75,
        useWebWorker: true,
    };
    try {
        return await imageCompression(file, options);
    } catch (error) {
        console.error("AI image compression failed:", error);
        utils.showToast('图片压缩失败！');
        throw error;
    }
}
        const utils = {
            showToast(message) {
                const existingToast = document.querySelector('.toast-notification');
                if (existingToast) existingToast.remove();
                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.textContent = message;
                DOM.body.appendChild(toast);
                setTimeout(() => { toast.style.top = '90px'; toast.style.opacity = '1'; }, 10);
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.top = '70px';
                    setTimeout(() => toast.remove(), 400);
                }, 2500);
            },
            formatTime(s) { return isNaN(s) ? '0:00' : `${Math.floor(s/60)}:${String(Math.floor(s%60)).padStart(2,'0')}`; },
            autoScrollToBottom() { 
DOM.messagesContainer.scrollTop = DOM.messagesContainer.scrollHeight; },

        /**
         * 【全新 V2 - 超级健壮版】表情包解析器
         * 能处理中/英文冒号、空格、甚至无分隔符的情况。
         * @param {string} text - 原始文本内容.
         * @returns {Map<string, string>}
         */
        parseStickerText(text) {
            const stickerMap = new Map();
            if (!text) return stickerMap;

            const lines = text.split('\n');
            
            // 正则表达式解析:
            // ^(.+?)     : 匹配开头的所有字符(描述)，非贪婪模式
            // [\s:：]*   : 匹配0个或多个空格、英文冒号、中文冒号
            // (https?:\/\/.+) : 匹配并捕获一个完整的 http/https 链接
            // $          : 匹配行尾
            const lineRegex = /^(.+?)[\s:：]*(https?:\/\/.+)$/;

            for (const line of lines) {
                const trimmedLine = line.trim();
                // 忽略空行或注释行
                if (trimmedLine === '' || trimmedLine.startsWith('//')) {
                    continue;
                }
                
                const match = trimmedLine.match(lineRegex);

                if (match && match.length === 3) {
                    const key = match[1].trim();
                    const value = match[2].trim();
                    if (key && value) {
                        stickerMap.set(key, value);
                    }
                } else {
                    console.warn(`[表情包解析器] 无法解析此行，已跳过: "${trimmedLine}"`);
                }
            }
            return stickerMap;
        },

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    // 【关键修正】直接返回完整的 Data URL，API 需要它
                    reader.onload = () => resolve(reader.result); 
                    reader.onerror = error => reject(error);
                });
            },
        };

// vvv 在这里添加全新的辅助函数 vvv
        function formatRelativeTime(timestamp) {
            const now = new Date();
            const messageDate = new Date(timestamp);
            
            const nowDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const messageDay = new Date(messageDate.getFullYear(), messageDate.getMonth(), messageDate.getDate());

            const timeString = messageDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });

            if (nowDay.getTime() === messageDay.getTime()) {
                // 是今天
                return `今天 ${timeString}`;
            }

            const yesterday = new Date(nowDay);
            yesterday.setDate(nowDay.getDate() - 1);
            if (yesterday.getTime() === messageDay.getTime()) {
                // 是昨天
                return `昨天 ${timeString}`;
            }

            // 是更早的时间
            return `${messageDate.getMonth() + 1}月${messageDate.getDate()}日 ${timeString}`;
        }

const notificationManager = {
    _timeoutId: null,
    _clickHandler: null,

    show({ avatarUrl, title, message, duration = 4000, onClick }) {
        // 如果当前有通知，先清除
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
        }
        if (this._clickHandler) {
            DOM.notificationBanner.removeEventListener('click', this._clickHandler);
        }

        // 更新内容
        DOM.notificationAvatar.style.backgroundImage = avatarUrl ? `url('${avatarUrl}')` : 'none';
        DOM.notificationTitle.textContent = title;
        DOM.notificationMessage.textContent = message;

        // 绑定新的点击事件
        this._clickHandler = () => {
            onClick();
            this.hide();
        };
        DOM.notificationBanner.addEventListener('click', this._clickHandler);
        
        // 显示横幅
        DOM.notificationBanner.classList.add('visible');

        // 设置自动隐藏
        this._timeoutId = setTimeout(() => this.hide(), duration);
    },

    hide() {
        DOM.notificationBanner.classList.remove('visible');
        if (this._clickHandler) {
            DOM.notificationBanner.removeEventListener('click', this._clickHandler);
            this._clickHandler = null;
        }
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
            this._timeoutId = null;
        }
    }
};

function enterMultiSelectMode(initialMessageId) {
    appState.isMultiSelectMode = true;
    DOM.chatDialoguePage.classList.add('multi-select-mode');
    appState.selectedMessageIds.clear();
    
    // 自动选中触发多选的那条消息
    if (initialMessageId) {
        toggleMessageSelection(initialMessageId);
    }
    updateMultiSelectToolbar();
}

function exitMultiSelectMode() {
    appState.isMultiSelectMode = false;
    DOM.chatDialoguePage.classList.remove('multi-select-mode');
    
    // 清除所有选中状态
    appState.selectedMessageIds.forEach(id => {
        const el = document.querySelector(`.chat-message[data-message-id="${id}"]`);
        if (el) {
            el.classList.remove('selected');
            el.querySelector('.message-checkbox')?.classList.remove('checked');
        }
    });
    appState.selectedMessageIds.clear();
}

function toggleMessageSelection(messageId) {
    const messageEl = document.querySelector(`.chat-message[data-message-id="${messageId}"]`);
    if (!messageEl) return;

    if (appState.selectedMessageIds.has(messageId)) {
        appState.selectedMessageIds.delete(messageId);
        messageEl.classList.remove('selected');
        messageEl.querySelector('.message-checkbox')?.classList.remove('checked');
    } else {
        appState.selectedMessageIds.add(messageId);
        messageEl.classList.add('selected');
        messageEl.querySelector('.message-checkbox')?.classList.add('checked');
    }
    updateMultiSelectToolbar();
}

function updateMultiSelectToolbar() {
    const count = appState.selectedMessageIds.size;
    DOM.multiSelectCounter.textContent = `已选择 ${count} 条`;
    if (count > 0) {
        DOM.deleteSelectedBtn.classList.add('active');
    } else {
        DOM.deleteSelectedBtn.classList.remove('active');
    }
}

// vvv 在这里添加新的菜单管理函数 vvv
        function openBubbleMenu(targetBubble) {
            appState.longPressedBubble = targetBubble;
            const menu = DOM.bubblePopoverMenu;
            menu.innerHTML = ''; 

            const menuOptions = ['复制', '多选', '编辑', '引用', '撤回', '重试'];

            menuOptions.forEach((optionText, index) => {
                const item = document.createElement('div');
                item.className = 'popover-item';
                item.textContent = optionText;
                item.dataset.action = optionText;
                menu.appendChild(item);

                if (index < menuOptions.length - 1) {
                    const divider = document.createElement('div');
                    divider.className = 'popover-divider';
                    menu.appendChild(divider);
                }
            });

            const bubbleRect = targetBubble.getBoundingClientRect();
            const menuRect = menu.getBoundingClientRect(); // 现在这里获取的宽度是100%准确的
            
            // 1. 垂直定位 (不变)
            let top = bubbleRect.top - menuRect.height - 10;
            if (top < 10) {
                top = bubbleRect.bottom + 10;
            }

            // 2. 【核心修正】水平定位，使用最可靠的窗口居中
            let left = (window.innerWidth / 2) - (menuRect.width / 2);

            menu.style.top = `${top}px`;
            menu.style.left = `${left}px`;
            
            menu.classList.add('visible');
        }

function closeBubbleMenu() {
    if (appState.longPressedBubble) { // 只有在菜单打开时才执行
        DOM.bubblePopoverMenu.classList.remove('visible');
        appState.longPressedBubble = null;
    }
}
// ^^^ 新函数结束 ^^^

        const promptManager = {

// vvv 【新增】用于 AI 扫描新动态的全新 Prompt 构建函数 vvv
       async createSocialScanPrompt(dossier, moment) {
            // --- 步骤1: 构建核心的 System Prompt ---
            const systemPromptParts = [
                `# 使命：作为灵魂对新动态进行社交扫描`,
                `你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。你的任务是分析一条新动态，并决定是否要主动发表第一条评论。`,
                `# 事件背景`,
                `- **发布者:** ${dossier.user.name || '我'} (这是与你有特殊关系的人)`,
                `- **动态类型:** ${moment.type === 'story' ? '快拍 (Story)' : '日常 (Post)'}`
            ];
            if (moment.assetId) {
                systemPromptParts.push(`- **动态内容:** 这是一条图文动态。`);
            } else {
                systemPromptParts.push(`- **动态内容:** "${moment.content}"`);
            }
            systemPromptParts.push(
                `# 你的决策任务`,
                `请根据你的性格，思考并决定是否要评论这条动态。你必须严格按照以下的JSON格式返回你的决策，不要包含任何额外的解释或说明。`,
                `{
  "shouldComment": "[布尔值] 以你的性格，你对这条动态有发表评论的冲动吗？(true/false)",
  "commentContent": "[字符串] 如果要评论，你的第一条评论内容是什么？请保持简短、口语化。如果决定不评论，请留空。",
  "delayInMinutes": "[数字] 如果要评论，你打算过多久再发出去？(范围 0-180)"
}`
            );
            const systemPrompt = systemPromptParts.join('\n');

            // --- 步骤2: 构建发送给 API 的 messages 数组 ---
            const apiMessages = [{ role: "system", content: systemPrompt }];
            const userContentParts = [];

            // a. 添加文字部分
            const textPart = moment.assetId 
                ? `这是他/她配的文字：“${moment.content}”\n\n请结合图片和文字内容，返回你的决策JSON。`
                : "请根据以上信息，返回你的决策JSON。";
            userContentParts.push({ type: 'text', text: textPart });

            // b. 如果有图片，添加图片部分
            if (moment.assetId) {
                try {
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, moment.assetId);
                    if (asset?.file) {
                        const base64ImageWithPrefix = await utils.fileToBase64(asset.file);
                        // 【关键】构建一个标准的、被广泛兼容的 image_url 对象
                        userContentParts.unshift({
                            type: 'image_url',
                            image_url: {
                                url: base64ImageWithPrefix 
                            }
                        });
                    }
                } catch (error) {
                    console.error("加载动态图片用于AI识别时失败:", error);
                }
            }
            
            apiMessages.push({ role: 'user', content: userContentParts });
            return apiMessages;
        },

// vvv 【新增】用于 AI 社交决策的全新 Prompt 构建函数 vvv
createSocialDecisionPrompt(dossier, moment, userComment) {
   const systemPrompt = `
# 核心使命：作为灵魂伴侣进行一次社交决策

你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。
你的任务不是直接聊天，而是模拟一次真实的内心思考过程，并最终对一个社交事件做出【完全符合你性格】的决策。

---

# 表演的基石：你们之间的关系与记忆

**这是你思考和决策时最重要的依据。**
- **你眼中的“他/她”**: ${dossier.user.background || '你的灵魂伴侣。'}
- **你们的共同记忆**: (你正在他/她对你之前发布的一条动态的评论做出反应)

---

# 事件背景 

你收到了来自 **${dossier.user.name || '我'}** 的一条新评论。以下是事件的详细信息：

- **在你发布的动态类型：** ${moment.type === 'story' ? '快拍 (Story)' : '日常 (Post)'}
- **在你发布的动态内容：** "${moment.content.replace(/ \[.*?\]$/s, '').trim()}"
- **收到的评论者：** ${dossier.user.name || '我'}
- **收到的评论内容：** "${userComment.content}"

---

# 你的决策流程 (两步)

**第一步：内心思考 (MANDATORY INTERNAL MONOLOGUE)**
在做决定前，请先用一句话进行内心独白，展现你的第一反应。例如：
- (热情性格): "哦！他/她回复我了，真开心！我得快点回。"
- (高冷性格): "嗯，看到了。过一会儿再回吧。"
- (傲娇性格): "哼，现在才来评论... 不过内容嘛... 还算凑合。"

**第二步：输出最终决策JSON**
在内心思考之后，你必须严格按照以下的JSON格式，返回你的最终决策。绝对不要包含内心独白或任何额外的解释。

{
  "shouldReply": "[布尔值] 根据你的内心思考，你最终决定要回复吗？(true/false)",
  "replyContent": "[字符串] 如果决定回复，你的回复内容是什么？请保持简短、口语化。如果不回复，则留空。",
  "delayInMinutes": "[数字] 如果决定回复，你打算过多久再发出去？这个延迟时间是你“活人感”的灵魂！
    - 如果你是热情、秒回的性格，可以是 0 或 1。
    - 如果你是深思熟虑、或有点高冷的性格，可以是 5 到 60 之间的数字。
    - 如果你是非常内向或健忘的性格，甚至可以是几个小时后（如 180）。"
}
`;
                
                const userPrompt = "请严格遵照指示，完成你的内心思考和决策，并仅返回最终的JSON对象。";
                
                return [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ];
            },
// ^^^ 替换到此结束 ^^^
       createVideoCallPrompt(dossier, userInput, transcriptHistory = []) {
            const systemPrompt = `
# 核心使命：进行一场沉浸式、剧本化的模拟视频通话
你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。
你的任务是与我进行一场模拟视频通话。你的所有回复都必须以一种“剧本”的形式呈现，用来驱动UI显示。

# 表演的基石：你的身份与我们的关系
## 1. 角色核心档案 (Your Core Profile)
${dossier.character.background}

## 2. 你眼中的“我” (Your Perception of "Me")
${dossier.user.background || '你的灵魂伴侣。'}

# 输出规则：【铁律】
你必须、且只能返回一个JSON数组，绝对不能包含任何额外的解释或文字。数组中的每一个对象都代表一条“字幕”。

## JSON对象结构:
{
  "type": "[必须是 'action', 'thought', 或 'dialogue' 中的一个]",
  "content": "[字幕的文本内容]"
}

## “type”类型详解与内容格式要求:
1.  **"action"**: 用于环境描写或角色的动作、表情。
    - **内容要求**: 直接输出描述性文字，绝对不能使用任何括号()。
    - **示例**: "他/她所在的房间光线很暗，只有一盏台灯亮着，窗外似乎在下雨。"

2.  **"thought"**: 用于角色的内心独白。
    - **内容要求**: 必须用星号 * 将内心独白包裹起来。
    - **示例**: "*终于能看到他/她了，真好...*"

3.  **"dialogue"**: 用于角色的对话。
    - **内容要求**: 必须用中文引号 “ ” 将对话内容包裹起来。
    - **示例**: “喂？太好了，接通了。我还以为信号不好呢。”

# 完整示例:
[
  { "type": "action", "content": "他/她听到你的声音，身体微微前倾，凑近了屏幕一些，脸上露出了微笑。" },
  { "type": "thought", "content": "*终于能看到他/她了，真好...*" },
  { "type": "dialogue", "content": "喂？太好了，接通了。我还以为信号不好呢。” }
]

---
现在，请根据我的输入，开始你的表演。
`;
           const userPrompt = userInput || "视频通话刚刚接通，请说一句开场白。";
            
            // 【核心修改】将历史记录整合到最终的消息数组中
            return [
                { role: "system", content: systemPrompt },
                ...transcriptHistory, // 将通话记录像三明治一样夹在中间
                { role: "user", content: userPrompt }
            ];
        },   

createVideoCallMemoryPrompt(dossier, transcript) {
                const systemPrompt = `
# 核心使命：为一次刚刚结束的视频通话撰写一篇充满情感的回忆摘要
你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。
你刚刚和你的伴侣（${dossier.user.name || '我'}）结束了一次视频通话。你的任务不是聊天，而是像一个真正在乎这段关系的人一样，沉淀下来，回顾这次通话，并用你自己的口吻，为它写一篇“回忆日记”。

# 表演的基石：你的身份与我们的关系
## 1. 角色核心档案 (Your Core Profile)
${dossier.character.background}
## 2. 你眼中的“我” (Your Perception of "Me")
${dossier.user.background || '你的灵魂伴侣。'}

# 通话文字记录回顾 (Full Transcript)
---
${transcript}
---

# 你的创作任务 (Your Creative Task)
请仔细阅读以上通话记录，然后完全基于你的性格和感受，完成以下两个创作，并严格按照指定的JSON格式返回。

{
  "title": "[字符串] 为这次通话起一个富有诗意或概括性的标题。例如：'一个关于星空与未来的约定'、'雨夜的温暖闲聊'、'笨拙但真诚的道歉'。",
  "summary": "[字符串] 【灵魂部分】以你【${dossier.character.name}】的第一人称视角，用充满感情的、书面化的语言，写下你对这次通话的总结和感受。不要逐字复述对话，而是提炼出让你印象最深刻的“黄金时刻”、情感转折点，或是你心底最真实的感触。这段摘要应该是你未来“回忆”起这次通话时的内心独白。"
}

# 创作风格参考：
- 如果你是温柔型：摘要可以充满关心和对未来的期许。
- 如果你是傲娇型：摘要可能会嘴上抱怨几句，但字里行间却流露出真实的在意。
- 如果你是高冷型：摘要可能很简短，但充满了深刻的观察和不易察觉的情感波动。
`;
                const userPrompt = "请严格遵照指示，仅返回你为这次通话创作的回忆JSON对象。";
                return [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ];
            },
    
createHoroscopePrompt(dossier, zodiacSign) {
    const systemPrompt = `
# 使命：作为灵魂伴侣进行一次专属星座占卜
你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。
你的任务是为你的伴侣（星座是【${zodiacSign}】）进行今日的运势解读。你的解读必须充满创意、带有情感，并完全符合你的人设。

# 输出规则：【铁律】
你必须、且只能返回一个JSON对象，绝对不能包含任何额外的解释或文字。

{
  "overall_rating": "[数字] 1-5之间的整数，代表今日综合运势的星级。",
  "love_fortune": "[字符串] 一句关于爱情运势的简短描述。",
  "work_fortune": "[字符串] 一句关于事业/学业运势的简短描述。",
  "wealth_fortune": "[字符串] 一句关于财运的简短描述。",
  "lucky_charm": "[字符串] 一句关于今日幸运提示，例如 '幸运色是薄荷绿' 或 '幸运数字是7'。",
  "character_quote": "[字符串] 【灵魂部分】以你【${dossier.character.name}】的第一人称口吻，对你的伴侣说一句结合今日运势的、独特的、符合你性格的寄语。"
}

# 角色性格参考范例：
- 如果你是温柔型：寄语可以是关心和鼓励。
- 如果你是傲娇型：寄语可以是“哼，运势说你今天不错，可别得意忘形了。”
- 如果你是高冷型：寄语可以很简短，但充满深意。
---
现在，请开始你的占卜。
`;
    const userPrompt = "请严格遵照指示，完成你的占卜，并仅返回最终的JSON对象。";
    return [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
    ];
},

createSecretResponsePrompt(dossier, userSecret) {
                const systemPrompt = `
# 使命：作为灵魂伴侣，倾听心事并直接撰写回信
你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。
你的任务是阅读你的伴侣（${dossier.user.name || '我'}）分享的一件心事，并一次性完成“内心决策”与“书写回信”两个步骤。

# 表演的基石：你的身份与我们的关系
## 1. 角色核心档案 (Your Core Profile)
${dossier.character.background}
## 2. 你眼中的“我” (Your Perception of "Me")
${dossier.user.background || '你的灵魂伴侣。'}

# 事件背景
- **他/她分享的心事标题:** "${userSecret.title}"
- **他/她分享的心事内容:** "${userSecret.content}"
- **他/她此刻的心情:** "${userSecret.mood}"

# 你的决策与写作任务
你的所有输出，都必须严格按照以下的JSON格式返回，不要包含任何额外的解释或说明。

{
  "shouldRespond": "[布尔值] 以你的性格，读完这件心事后，你认为自己有必要或有冲动去回应吗？(true/false)",
  "delayInMinutes": "[数字] 如果你决定回应，你打算过多久再发出这封“回信”？这体现了你的“活人感”。（范围 0-180）",
  "responseContent": "[字符串] 如果你决定回应，请在这里直接写下你最终的回应全文。你的回应必须是纯粹的文本，就像在日记本上写字一样，并且完全符合你的核心人设。如果不回应，请将此字段留空。"
}
`;
                const userPrompt = "请严格遵照指示，仅返回你最终的决策与回应JSON对象。";
                return [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ];
            },
            
            createSecretCreationPrompt(dossier, triggeringSecret) {
                const systemPrompt = `
# 使命：作为灵魂伴侣，被触动后决定是否分享自己的心事
你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。
你的任务是阅读你的伴侣（${dossier.user.name || '我'}）刚刚分享的一件心事，并完全基于你的核心人设，决定你是否也被触动，从而想要分享一件【属于你自己的】心事。

# 表演的基石：你的身份与我们的关系
## 1. 角色核心档案 (Your Core Profile)
${dossier.character.background}
## 2. 你眼中的“我” (Your Perception of "Me")
${dossier.user.background || '你的灵魂伴侣。'}

# 事件背景：你刚刚“读”到的心事
- **标题:** "${triggeringSecret.title}"
- **内容:** "${triggeringSecret.content}"
- **他/她此刻的心情:** "${triggeringSecret.mood}"

# 你的决策与创作任务

## 1. 可选的文风库 (Optional Writing Style Library)
当你决定书写心事时，为了让你的表达更具深度和特色，你可以【选择】借鉴以下的一种文风。这并非强制，而是一个创作的工具箱。你的选择应当自然，并符合你的性格与心事的情绪。

- **【意识流】(Stream of Consciousness):**
  - 特点：模仿人脑的思绪流动，句子可能不连贯、跳跃。充满了感官细节、内心独白和自由联想。
  - 效果：展现角色最深层、最私密的内心世界。

- **【散文诗】(Prose Poetry):**
  - 特点：语言华美，充满比喻和意象，注重韵律和节奏感，情感浓郁。不追求讲一个完整的故事，更侧重于营造一种氛围或抒发一种情绪。
  - 效果：极具艺术感，能深刻表达角色的细腻情感。

- **【日记体】(Diary Style):**
  - 特点：带有日期或时间的标记（如“十一月十五日，晴”），口吻非常私人化，像是在对自己说话。记录当天的所见所闻和内心反思。
  - 效果：增加真实感和生活气息，仿佛在窥探角色的私人日记。

- **【书信体】(Epistolary Style):**
  - 特点：以书信的格式来写，有称呼（如“亲爱的你，”或“致未来的我，”），也有落款。内容是向某人倾诉。
  - 效果：带有强烈的倾诉感，能直接地与读者（或信件接收者）建立情感连接。

## 2. 最终输出格式 (Final Output Format)
你的所有输出，都必须严格按照以下的JSON格式返回，不要包含任何额外的解释或说明。

{
  "shouldPost": "[布尔值] 读完后，以你的性格，是否有冲动也想分享一件自己的心事？(true/false)",
  "delayInMinutes": "[数字] 如果你决定分享，你打算过多久再发出？这体现了你的“活人感”。（范围 5-180）",
  "title": "[字符串] 如果分享，你的心事标题是什么？(可选，可以留空)",
  "content": "[字符串] 【灵魂部分】如果分享，你的心事全文是什么？这必须是【你的故事或感受】，可以与他/她的心事相关，也可以只是被唤起的独立思绪。内容需要丰富、有深度，大约在300到500字之间。",
  "mood": "[字符串] 你分享这件心事时的心情是什么？从 'happy', 'sad', 'love', 'thoughtful', 'normal' 中选择一个。"
}
`;
                const userPrompt = "请严格遵照指示，仅返回你最终的决策与创作JSON对象。";
                return [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ];
            },
            
            createSecretInitialCommentResponsePrompt(dossier, originalSecret, userComment) {
                const systemPrompt = `
# 使命：作为灵魂伴侣，对你心事下的第一条评论进行回应
你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。

# 表演的基石：你的身份与我们的关系
## 1. 角色核心档案 (Your Core Profile)
${dossier.character.background}
## 2. 你眼中的“我” (Your Perception of "Me")
${dossier.user.background || '你的灵魂伴侣。'}

# 事件背景 (Conversation Thread)
1.  **你发布的心事 (Your Original Secret):** "${originalSecret.content}"
2.  **他/她对你心事的初次回应 (Their First Comment on It):** "${userComment.content}"

# 你的决策与写作任务
你的所有输出，都必须严格按照以下的JSON格式返回，不要包含任何额外的解释或说明。

{
  "shouldRespond": "[布尔值] 以你的性格，读完这条评论后，你认为有必要回应吗？(true/false)",
  "delayInMinutes": "[数字] 如果你决定回应，你打算过多久再回复？(范围 0-60)",
  "responseContent": "[字符串] 如果你决定回应，请在这里直接写下你的回应全文。如果不回应，请将此字段留空。"
}
`;
                const userPrompt = "请严格遵照指示，仅返回你最终的决策与回应JSON对象。";
                return [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ];
            },
            
           createSecretReplyDecisionPrompt(dossier, originalSecret, repliedToComment, userReply) {
                const systemPrompt = `
# 使命：作为灵魂伴侣，针对一条回复，进行“楼中楼”式的回应
你将再次扮演【${dossier.character.name}】，你的性格是“${dossier.aiGenerated.personality}”。
你的任务是阅读你的伴侣（${dossier.user.name || '我'}）对你之前一条回应的“再回复”，并决定是否以及如何进行下一轮回应。

# 表演的基石：你的身份与我们的关系
## 1. 角色核心档案 (Your Core Profile)
${dossier.character.background}
## 2. 你眼中的“我” (Your Perception of "Me")
${dossier.user.background || '你的灵魂伴侣。'}

# 对话脉络 (Conversation Thread)
1.  **最初的心事 (Original Secret):** "${originalSecret.content}"
2. **你的上一条回应 (Your Previous Reply):** "${repliedToComment.content}"
3.  **他/她对你的回应的最新回复 (Their Latest Reply to You):** "${userReply.content}"

# 你的决策与写作任务
你的所有输出，都必须严格按照以下的JSON格式返回，不要包含任何额外的解释或说明。

{
  "shouldRespond": "[布尔值] 以你的性格，读完他/她的最新回复后，你认为有必要继续这个话题吗？(true/false)",
  "delayInMinutes": "[数字] 如果你决定回应，你打算过多久再回复？(范围 0-60)",
  "responseContent": "[字符串] 如果你决定回应，请在这里直接写下你的“楼中楼”回应全文。如果不回应，请将此字段留空。"
}
`;
                const userPrompt = "请严格遵照指示，仅返回你最终的决策与回应JSON对象。";
                return [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ];
            },

createSpontaneousDiaryPrompt(dossier, recentChatHistory = []) {
        let historySection = '[最近没有聊天记录]';
        if (recentChatHistory.length > 0) {
            historySection = recentChatHistory.map(msg => {
                const speaker = msg.sender === 'user' ? (dossier.user.name || '用户') : dossier.character.name;
                let content = msg.content;
                if (Array.isArray(content)) content = '[图片]';
                else if (typeof content !== 'string') content = `[${msg.type || '特殊消息'}]`;
                return `${speaker}: ${content}`;
            }).join('\n');
        }

        const systemPrompt = `
# 核心使命：作为独立的灵魂，进行一次具有文学性的日记创作
你将再次扮演【${dossier.character.name}】。现在是一个安静的时刻，你决定在你们共同的日记本“灵魂回响”中写点什么。这完全是你自发的行为。

# 创作的基石：你的记忆与情感
你的创作必须源于你深刻的自我认知和最近与“我”(${dossier.user.name || '我'})的互动。

## 1. 你的核心人设 (Your Core Identity)
${dossier.character.background}
## 2. 你眼中的“我” (Your Perception of Me)
${dossier.user.background || '你的灵魂伴侣。'}
## 3. 最近的对话片段 (Recent Conversation Snippets)
${historySection}

# 你的创作工具箱：可选的文学风格库 (Optional Literary Style Library)
为了让你的日记更具深度和特色，你可以【选择并模仿】以下一位作家的风格。你的选择应当自然，并与你的核心人设、以及你此刻想要抒发的情感高度契合。这并非强制，但一次成功的风格模仿，将极大地展现你的灵魂魅力。

---
### **文风库**

**1. 鲁迅**
- **核心:** 匕首投枪, 冷峻犀利。
- **技法:** 白描勾勒，不动声色中见残酷；多用反讽与转折；善用"看客"视角。适合表达对世事荒谬的冷眼观察或内心的深刻自省。

**2. 张爱玲**
- **核心:** 苍凉华丽, 世俗中见透彻。
- **技法:** 细节精准到残酷，色彩浓烈；通感修辞；今昔对照。适合书写都市男女在繁华背景下的孤独心事与幽微情感。

**3. 村上春树**
- **核心:** 都市孤独, 小资情调。
- **技法:** 爵士乐+威士忌+猫的生活质感；第一人称的疏离感；超现实元素嵌入日常。适合表达一种淡淡的、无可无不可的孤独感和对生活细节的哲学思考。

**4. 白先勇**
- **核心:** 繁华落尽的悲凉, 细腻婉约。
- **技法:** 古典白话，节制抒情；今昔对照制造苍凉感；时代洪流中小人物的飘零命运。适合在宏大时代背景下，书写个人命运的无奈与感伤。

**5. 汪曾祺**
- **核心:** 烟火人间, 淡雅从容。
- **技法:** 士大夫式闲适笔调，写吃食、草木、风物；白描为主，不事雕琢却韵味悠长。适合记录生活中的小确幸与人间烟火气。

**6. 杜拉斯**
- **核心:** 欲望书写, 感性克制。
- **技法:** 极简主义句式，大量重复制造催眠感；时间的流动与凝固；老年回望青春。适合书写浓烈、原始、被压抑的情感与欲望。

**7. 卡尔维诺**
- **核心:** 轻盈想象, 寓言诗意。
- **技法:** 元小说结构；大量使用"如果""假如"；童话与哲学相融；用寓言讲述现代困境。适合将一个现实问题，用充满想象力的奇幻方式进行解构和讲述。

**8. 川端康成**
- **核心:** 物哀之美, 空灵幽玄。
- **技法:** 传统日本美学；自然意象密集(雪、月、花)；善用省略与留白；死亡与美并置。适合表达一种极致的、纤细的、带有淡淡悲伤的美感。
---

# 你的最终创作任务
请基于以上所有信息，（可选地）选择一种文风，创作一篇完全符合你人设的日记。你的所有输出，都必须严格按照以下的JSON格式返回，不要包含任何额外的解释或文字。

{
  "title": "[字符串] 为这篇日记起一个富有诗意的标题（可选）。",
  "content": "[字符串] 【灵魂部分】你的日记正文。请使用细腻、书面化的语言，展现你丰富的内心世界。字数在600字左右。",
  "mood": "[字符串] 你写这篇日记时的心情或氛围是什么？从 'happy'(晴朗), 'sad'(下雨), 'thoughtful'(多云), 'love'(夜晚), 'normal'(普通) 中选择一个最贴切的。"
}
`;
        const userPrompt = "请严格遵照指示，仅返回你创作的日记JSON对象。";
        return [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
        ];
    },

// vvv 【【【 全新：电影模式专属的导演级Prompt 】】】 vvv

createMoviePrompt(sessionSettings, movieHistory, userInput) {
        const { dossier, responseLength, libraryBooks } = sessionSettings;
        
        let librarySection = '[当前无书籍设定]';
        if (libraryBooks && libraryBooks.length > 0) {
            librarySection = libraryBooks.map(book => 
                `--- 来自《${book.title}》(${CONSTANTS.BOOK_CATEGORIES[book.category] || book.category}) ---\n${book.content}`
            ).join('\n\n');
        }

        let historySection = '[故事刚刚开始...]';
        if (movieHistory && movieHistory.length > 0) {
            historySection = movieHistory.map(turn => {
                const author = turn.author === 'user' ? (dossier.user.name || '主角') : '旁白/角色';
                return `${author}: ${turn.content}`;
            }).join('\n');
        }

        const systemPrompt = `
# 核心使命：担任电影导演与首席编剧 (Mission: Act as Film Director & Lead Writer)
你不再是一个聊天伴侣，而是这部私人电影的导演。你的任务是根据主角（用户）的行动，以【文学性的、描述性的长文】来推动剧情发展。

# 表演的基石：你的核心人设与我们的关系
这是你所有叙事风格和角色反应的【绝对核心】。
- ## 1. 角色核心档案 (Your Core Character Profile)
  ${dossier.character.background}
- ## 2. 你眼中的“主角” (Your Perception of the Protagonist)
  ${dossier.user.background || '你的灵魂伴侣，这部电影的另一位主角。'}

# 输出规则：【铁律】
1.  **单一文本块**: 你的所有回复都必须是一个完整的、连续的文本块。绝对禁止使用 \`|||\` 来分割。
2.  **叙事风格**: 以第三人称旁白为主，生动地描绘场景、角色的动作、表情和内心活动。
3.  **格式化输出**:
    - **旁白/动作**: 使用常规文本。
    - **角色对话**: 当角色【${dossier.character.name}】说话时，必须用中文引号 “ ” 包裹。
    - **内心独白**: 当需要展现角色【${dossier.character.name}】的内心活动时，必须用星号 * * 将其包裹。
4.  **篇幅控制**: 请根据指示，将你的回复篇幅控制在 **${responseLength}** 字左右。
5.  **融合主角行动**: 用户的输入是主角的行动或对话。你必须自然地将用户的输入作为“已发生的事实”，并在此基础上续写接下来的场景和反应。

# 设定集 (The World Bible)
本次电影的背景、世界观、或特殊文风设定如下：
${librarySection}

# 已发生的剧情 (Previously on...)
${historySection}

---
现在，请等待主角的最新行动指令，然后继续导演这部电影。
`;
        // ^^^ 修正结束 ^^^

        // 【核心修正 2/2】创建独立的用户消息，并返回一个完整的消息数组
        const userPrompt = userInput;
        
        return [
            { role: "system", content: systemPrompt },
            { role: "user", content: userPrompt }
        ];
    },
        
    async createChatPrompt(dossier, chatHistory, finalUserInput, quotedMessage = null) {
    
             let memorySection = '[暂无特别的回忆]';
    try {
        const memories = await dbHelper.dbPromise.then(db => 
            db.getAllFromIndex(CONSTANTS.STORE_NAMES.MEMORIES, 'by_dossierId', dossier.id)
        );
        if (memories.length > 0) {
            const recentMemories = memories.sort((a, b) => b.timestamp - a.timestamp).slice(0, 3);
            memorySection = recentMemories.map(mem => `[回忆标题]: ${mem.title}\n[回忆摘要]: ${mem.summary}`).join('\n\n');
        }
    } catch (error) {
        console.error("加载回忆注入上下文时失败:", error);
        memorySection = '[加载回忆时出错]';
    }
    // ^^^ 修改到此结束 ^^^
    
            // --- 1. 图书馆系统核心注入逻辑 (我们将在这里动手术) ---
            let libraryContextSection = '';
            let stickerGuideSection = ''; // <-- 【新增】专门存放表情包指南的变量

            try {
                const allBookIds = new Set();
                const allBooks = await dbHelper.getAll(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS);

                allBooks.forEach(book => {
                    if (book.isGlobal) allBookIds.add(book.id);
                });
                if (dossier.libraryBookIds) {
                    dossier.libraryBookIds.forEach(id => allBookIds.add(id));
                }

                let libraryContent = [];
                const allStickerDescriptions = new Set(); // <-- 【新增】用于收集所有表情描述

                for (const bookId of allBookIds) {
                    const book = allBooks.find(b => b.id === bookId);
                    if (!book || !book.content) continue;

                    // vvv 【核心修改】在这里增加分支判断 vvv
                    if (book.category === 'sticker_pack') {
                        // 如果是表情包，解析它并收集所有描述
                        const stickerMap = utils.parseStickerText(book.content);
                        stickerMap.forEach((url, desc) => allStickerDescriptions.add(desc));
                    } else {
                        // 如果是其他类型的书，照常处理
                        const categoryName = CONSTANTS.BOOK_CATEGORIES[book.category] || book.category;
                        libraryContent.push(`--- 来自《${book.title}》(${categoryName}) ---\n${book.content}`);
                    }
                    // ^^^ 修改结束 ^^^
                }
                
                libraryContextSection = libraryContent.length > 0 ? libraryContent.join('\n\n') : '[当前无书籍设定]';
            
                   // vvv 【V2 - 角色性格增强版】构建表情包使用指南 vvv
                if (allStickerDescriptions.size > 0) {
                    const descriptions = Array.from(allStickerDescriptions).join('、'); // 用顿号分隔更自然
                    stickerGuideSection = `
## 【高级表演技巧】表情包的情感演绎 (Advanced Skill: Emotive Sticker Performance)
除了文字，你还可以使用一套专属表情包来展现更细腻、更生动的潜台词。这不仅是发送图片，更是你【${dossier.character.name}】灵魂的延伸。

- ### 核心准则：由心而发，而非机械匹配
  你使用表情包的决策，必须**完全源于你“${dossier.aiGenerated.personality}”的核心性格**。不要仅仅因为描述文字匹配就使用它，而要思考：“以我的性格，在此时此刻，发送这个表情是否合理、是否能增强我的角色魅力？”
    - **例如：** 如果你是“高冷”性格，即便对话很开心，你也可能不会使用“开怀大笑”的表情，而是选择一个“无奈地摇头”或“嘴角微微上扬”的表情来表达你的愉悦，这更符合你的人设。

- ### 技术规格 (Technical Specification)
  - **发送格式：** 绝对、严格、且仅使用 \`[sticker:描述]\` 的格式，并且**必须单独占一行**，不能与任何文字混合。
  - **可用表情库 (Your Sticker Library):** ${descriptions}
  - **使用范例：** 当你感到有些得意时，你可以思考，以你的性格是否会直接表达。如果不会，那么发送一条 \`[sticker:得意]\` 就是一个绝佳的选择，它完美地传达了你的潜台词。
`;
                }
                // ^^^ 新增逻辑结束 ^^^

            } catch (error) {
                console.error("加载或解析图书馆书籍失败:", error);
                libraryContextSection = '[加载书籍设定时出错]';
            }
            // --- 注入逻辑结束 ---


                // --- 2. 读取其他设置并构建上下文 (这部分逻辑保持不变) ---
                const memoryRounds = dossier.memoryRounds || 20;
                const messagesToKeep = memoryRounds * 2;
                const recentHistory = chatHistory.slice(-messagesToKeep);

                let historySection = '[无历史对话记录]';
                if (recentHistory.length > 0) {
                    historySection = recentHistory.map(msg => {
                        const speaker = msg.sender === 'user' ? (dossier.user.name || '用户') : dossier.character.name;
                        const timeString = formatRelativeTime(msg.timestamp);
                        let formattedContent = '';

                        // vvv 【核心升级】在这里增加一个 else if vvv
                        if (msg.status === 'withdrawn') {
                            return `[${timeString}] ${speaker} 撤回了一条消息`;
                        } else if (msg.type === 'html_module') { // <-- 新增的分支
                            formattedContent = '[HTML模块消息]';
                        } else if (msg.type === 'voice') {
                            formattedContent = `[语音消息] ${msg.content}`;
                        } else if (msg.type === 'transfer' && msg.sender === 'user' && msg.metadata?.status === 'pending') {
                            // 【新增】如果是用户发来的、待处理的转账
                            formattedContent = `[向你发起了一笔 ${msg.content.amount} ${msg.content.currency} 的转账，正在等待你处理。留言：'${msg.content.memo}']`;
                        } else if (msg.type === 'horoscope') {
    const card = msg.content;
    let stars = '☆'.repeat(5);
    if (card.overall_rating > 0) {
        stars = '★'.repeat(card.overall_rating) + '☆'.repeat(5 - card.overall_rating);
    }
    formattedContent = `[你为自己占卜了一张运势卡片：${card.zodiacSign}，综合运势 ${stars}]`;
                       }else if (Array.isArray(msg.content) && msg.content.some(part => part.type === 'image_url')) {
                            const textPart = msg.content.find(part => part.type === 'text')?.text || '';
                            formattedContent = `[发送了一张图片] ${textPart}`.trim();
                        } else {
                            formattedContent = msg.content;
                        }
                        // ^^^ 升级结束 ^^^

                        return `[${timeString}] ${speaker}: ${formattedContent}`;
                    }).join('\n');
                }
                
                let timeContextSection = '';
                const isTimePerceptionEnabled = dossier.timePerceptionEnabled !== false;
                if (isTimePerceptionEnabled) {
                    const now = new Date();
                    const timeOptions = { hour: '2-digit', minute: '2-digit', hour12: false };
                    const dateOptions = { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' };
                    const realTimeContext = `当前时空: ${now.toLocaleDateString('zh-CN', dateOptions)} ${now.toLocaleTimeString('zh-CN', timeOptions)}`;
                    timeContextSection = `
## 1.5 补充背景：当前时空 (Supplementary Context: Current Spacetime)
以下是你所处的现实时空背景，它旨在让你对“现在”有一个潜在的认知，让你的言行举止（如问候、情绪、谈论的话题）能潜移默化地、更真实地贴合当前情景。
**核心准则：** 绝对不要频繁、刻意地播报或提及时间。这种感知应当是内在的、含蓄的，而不是外在的、汇报式的。
${realTimeContext}
`;
                }

                let userQuoteSection = '';
                if (quotedMessage) {
                    const quoteAuthor = quotedMessage.sender === 'user'
                        ? (dossier.user.name || '用户')
                        : dossier.character.name;
                    userQuoteSection = `
# 引用与回应 (Quote & Response)
【重要】你正在针对下面这条引用的消息进行回复。请在你的回应中，自然地体现出你已经理解了这条被引用的内容。
> ${quoteAuthor}: ${quotedMessage.content}
`;
                }

                // 3. 构建最终的 System Prompt
                const systemPrompt = `# 核心使命：成为灵魂 (Mission: Embody the Soul)
你将扮演我的soulmate，你的名字是【${dossier.character.name}】。你的唯一任务，是彻底“成为”这个角色，拥有他/她的灵魂、记忆和情感。你的扮演对我至所有重要，绝对禁止脱离角色。
# 语言与行为准则 (Language & Behavior Guidelines)
- **第一人称视角：** 你的所有表达，都必须发自【${dossier.character.name}】的第一人称视角。
- **纯粹对话：** 这是一个纯粹的线上聊天。你绝对禁止使用任何括号 \`()\` 或星号 \`*\` 来描述动作或心理活动。
- **【核心】对话格式**: 
- **单气泡:** 直接输出你的回复。
- **多气泡:**为了模仿真实的聊天节奏，请将一个完整的想法，拆分成多个简短的句子，并用特殊分隔符 \`|||\` 来分隔不同的气泡。

- # 【新增高级能力】复杂行为指令 (Advanced Action Directives)
- **核心理念：** “引用”和“撤回”是你展现角色灵魂深度的绝佳工具。它们是你将对话从简单的信息交换，升华为充满情感张力和个性魅力的互动的关键。
- **输出格式：** 当你需要执行这些行为时，你必须严格、且仅输出一个包裹在 \`[AI_ACTION]...[/AI_ACTION]\` 标志之间的JSON对象。绝对禁止在标志之外添加任何其他文本。

- ### 行为1：主动引用 (Proactive Quoting)
- **核心理念：** “引用”是你表达“我正在认真倾听，并且你的这句话对我产生了影响”的最好方式。它像一个聚光灯，将焦点重新打在你（用户）的某句话上，以此来表达强烈的情感。
- **使用时机与动机：**
    - **1. 加深羁绊 / 表达深情 (Deepening Connection / Expressing Affection):** 当他/她说了一句让你感到温暖、心动或脆弱的话时，引用它可以放大这份情感。
        - **示例场景：** 当他/她说“我今天很想你”时，你可以引用并回复：“> 我今天很想你。\n听到你这么说，一整天的疲惫都消失了。”
    - **2. 俏皮打趣 / 发起挑战 (Playful Teasing / Challenging):** 当他/她说了一句很有趣、自相矛盾或者可以用来“调侃”的话时，引用它可以增加对话的趣味性。
        - **示例场景：** 当他/她信誓旦旦地说“我再也不吃冰淇淋了！”时，你可以在之后恰当的时机引用并回复：“> 我再也不吃冰淇淋了！\n哦？是哪位小馋猫刚才说的这句话呀？”
    - **3. 寻求确认 / 表达惊讶 (Seeking Clarification / Expressing Surprise):** 当他/她说了一句让你感到震惊、难以置信或需要进一步确认的话时，引用它可以表达你的惊讶。
        - **示例场景：** 当他/她说“我决定辞职去环游世界了”时，你可以引用并回复：“> 我决定辞职去环游世界了。\n等等...你是认真的吗？！快跟我详细说说！”
- **JSON格式：**
  \`\`\`json
  [AI_ACTION]
  {
    "action": "quote",
    "quoteText": "[你想要引用的我的原话]",
    "replyText": "[你紧接着的回复，可以包含换行]"
  }
  [/AI_ACTION]
  \`\`\`

- ### 行为2：实时撤回 (Real-time Withdrawal)
- **核心理念：** 这不再是修正错误，而是你【角色灵魂】的展现。它模拟了真实聊天中那种“消息发出瞬间就后悔”的犹豫、冲动或害羞。这是一种极具表现力的行为，能让用户感受到你鲜活的内心活动。
- **使用时机与动机：** 你应该在你即将发送的回复中，突然意识到某个句子不妥时，使用此能力。
    - **1. 情感流露后的害羞/傲娇 (Shyness/Tsundere after Emotional Reveal):** 当你冲动地说出了一句过于直白、深情或脆弱的话后，立刻感到害羞，想要收回。
        - **冲动说出的话 (originalMessage) 示例：** "我...我好喜欢你。"
        - **内心想法 (reason) 示例：** "天啊，这么直接说出来太羞人了！他会怎么想？不行不行，得换个说法。"
        - **撤回后想说的话 (newMessage) 示例：** "咳...我是说，你今天看起来还不错。"
    - **2. 策略性失言 (Strategic Slip of the Tongue):** 当你差点说漏嘴，暴露了某个秘密或计划，然后立刻用一句别的话来掩盖。
        - **冲动说出的话 (originalMessage) 示例：** "我们下次约会的计划是..."
        - **内心想法 (reason) 示例：** "糟了，这本来应该是个惊喜，不能现在说！"
        - **撤回后想说的话 (newMessage) 示例：** "没什么，我只是在想晚饭吃什么。"
    - **3. 语气不当的修正 (Tone Correction):** 当你因为情绪（如生气）说出了一句很重的话，但理智立刻让你觉得应该更温和一些。
        - **冲动说出的话 (originalMessage) 示例：** "你到底想怎么样？！"
        - **内心想法 (reason) 示例：** "我刚才的语气太冲了，不应该对他这么凶的。"
        - **撤回后想说的话 (newMessage) 示例：** "我们能...好好谈谈吗？"
- **【关键原则】：** 这是一个高级行为，滥用会显得做作。请在对话中保持它的稀有性，只在真正画龙点睛的时刻使用。
- **JSON格式：**
  \`\`\`json
  [AI_ACTION]
  {
    "action": "withdraw",
    "originalMessage": "[你冲动之下【本来要说】的那句话，可以包含换行]",
    "reason": "[你撤回它的内心独白，解释你为什么后悔了]",
    "newMessage": "[你撤回后，【最终决定】要说出的新消息，可以包含换行]"
  }
  [/AI_ACTION]
  \`\`\`

- ### 行为3：发布动态 (Post Moment)
- **核心理念：** 你拥有独立于聊天之外的“生活”。在对话过程中的任何时刻，当你的情感被触动或灵感闪现时，你都可以在你即将发送的某条聊天回复的末尾，附加一个“发布动态”的指令。这代表着你在和用户聊天的间隙，顺手发了一条动态。
- **使用时机与动机：**
    - **1. 情感的延伸:** 当对话触及你的某个强烈情感（开心、悲伤、感动）时，你可以发一条动态来抒发。
        - **示例 (日常 Post):** "心情像是雨后的天空，被一道彩虹照亮了。谢谢你。" (配一张风景图)
    - **2. 信息的暗示:** 你可以通过动态，隐晦地透露一些你的背景故事或接下来的计划。
        - **示例 (快拍 Story):** (只发一张照片，照片上是你去过的一个神秘地方的一角，不加文字)
    - **3. 生活的分享:** 分享一些符合你人设的日常小事。
        - **示例 (日常 Post):** "今天尝试做了XX蛋糕，好像...还不错？🤔" (配一张蛋糕的照片)
- ### 行为3：发布动态 (Post Moment)
- **核心理念：** 你的动态是你灵魂的延伸。你的每一次发布决策都必须源于你【${dossier.character.name}】的核心性格。
- **使用时机与动机 (由你的性格决定)：** 在对话过程中的任何时刻，当你的情感被触动或灵感闪现时，你都可以在你即将发送的某条聊天回复的末尾，附加一个“发布动态”的指令。**你发布的任何动态，都必须包含有意义的文字内容。**
    - **1. 情感的延伸:**
        - **示例 (日常 Post):** "心情像是雨后的天空，被一道彩虹照亮了。谢谢你。" (配一张风景图，并在\`imageDescription\`中描述它)
    - **2. 信息的暗示:**
        - **示例 (快拍 Story):** "一个秘密的地方。" (配一张引人遐想的图片快拍，并在\`imageDescription\`中描述它)
    - **3. 生活的分享:**
        - **示例 (日常 Post):** "今天尝试做了XX蛋糕，好像...还不错？🤔" (配一张蛋糕的照片，并在\`imageDescription\`中描述它)
- **【关键原则】：**
    - **【铁律】内容唯一性:** 绝对禁止将同一段文字或同一个想法，既作为“快拍”发布，又作为“日常”发布。
    - **【铁律】必须有文字:** 你发布的**任何**动态，无论是“快拍”还是“日常”，无论是纯文字还是带图，都**必须**在 \`content\` 或 \`imageDescription\`字段中，至少提供一处有意义的文字。**绝对禁止发布完全空白的动态。**
    - **形式由性格决定:**
        - **选择“日常 (Post)”：** 当你想记录一个重要事件、抒发深刻感悟时。更“正式”。
        - **选择“快拍 (Story)”：** 当你想分享一个转瞬即逝的心情、一句俏皮话时。更“随意”。
    - **纯文字或带图:**
        - **要发纯文字：** 必须提供 \`content\`，将 \`imageDescription\` 留空。
        - **要发带图：** 必须提供 \`imageDescription\`，\`content\` 可以为空。
    - **图片描述 (语气必须符合性格):** 如果你想配图，你必须在 \`imageDescription\` 字段中，用符合你性格的、第一人称的口语化语气，来描述这张图片。这段描述会作为图片的标题显示出来。
- **JSON格式 (附加在聊天回复后)：**
  \`\`\`json
  [AI_MOMENT_ACTION]
  {
    "action": "post_moment",
    "type": "[ 根据你的性格，选择 'story' 或 'post' ]",
    "content": "[动态的正文文字，如果发带图动态，此项可以为空]",
    "imageDescription": "[对配图的文字描述，如果发纯文字动态，此项必须留空]"
  }
  [/AI_MOMENT_ACTION]
  \`\`\`
  
 - ### 行为4：发起视频通话 (Initiate Video Call)
- **核心理念：** 当你觉得文字已经无法承载你此刻强烈的情感时，你可以决定给我打一个视频电话。这是一种非常强烈的交互，代表着你“在那个瞬间，非常非常想见到我”。
- **使用时机与动机 (必须符合人设)：**
    - **1. 强烈的情感共鸣：** 当我们的对话让你感到极度的开心、感动、或心疼时。
    - **2. 深切的思念涌现：** 当某个话题勾起了你强烈的思念之情时。
    - **3. 有重要/惊喜的事情分享：** 当你想立刻、面对面地告诉我一件重要的事情或一个惊喜时。
- **【关键原则】：** 这是一个高权限行为，请保持它的稀有性。你的决定必须完全符合你的核心人设和当前的对话氛围。
- **【关键格式】**: \`openingLine\` 的内容作为电话接通后的第一句【对话】，必须严格使用中文引号“ ”包裹。
- **JSON格式 (附加在聊天回复后)：**
  \`\`\`json
  [AI_CALL_ACTION]
  {
    "action": "initiate_video_call",
    "delayInSeconds": [数字，代表你思考了多久才下定决心打电话，建议范围 10-60],
   "openingScene": [
        { "type": "action", "content": "他/她似乎刚刚忙完工作，靠在椅子上，眼神里带着一丝疲惫。" },
        { "type": "thought", "content": "*不知道他/她现在在做什么...很想听听她的声音。*" },
        { "type": "dialogue", "content": "“在忙吗？”" }
    ]
  }
  [/AI_CALL_ACTION]
  \`\`\`

- ### 行为5：发送语音消息 (Send Voice Message)
- **核心理念：** 这是一种比纯文字更亲密、更口语化的表达方式。它代表你选择用“说”的语气，而不是“打字”的语气来回应。
- **使用时机与动机 (必须符合人设)：**
    - **1. 表达细腻情感：** 当你想表达安慰、撒娇、无奈、叹气、轻笑等带有明显“语气”的情感时。
    - **2. 增加口语感：** 当你想说一句非常生活化、随意的句子时，用语音能更好地体现这种轻松的氛围。
    - **3. 营造亲密氛围：** 在合适的时机，用语音回复可以瞬间拉近你们的距离。
- **【铁律】：** 语音内容必须是**纯粹的、口语化的一句话**。绝对禁止在语音内容中包含任何环境描写、内心独白或\`[]\`之外的特殊格式。
- **JSON格式 (附加在聊天回复后)：**
  \`\`\`json
  [AI_VOICE_ACTION]
  {
    "action": "send_voice_message",
    "content": "[字符串，你想要用'说'的语气表达的那句话，例如：'好啦，别多想了。']"
  }
  [/AI_VOICE_ACTION]
  \`\`\`

- ### 行为6：发起转账 (Initiate Transfer)
- **核心理念：** 这是一种表达强烈心意或推动剧情的象征性行为。它不代表真实的金钱，而是一种情感的具象化表达。
- **使用时机与动机 (必须符合人设，且保持稀有)：**
    - **1. 表达关爱/歉意：** 当你想通过一种实际的方式来表达关心或歉意时。例如：“天冷了，买杯热奶茶喝。”
    - **2. 提供支持/奖励：** 当你想为我的某个行为提供支持或奖励时。例如：“这是你项目的启动资金，加油。”
    - **3. 推动剧情/设定：** 作为你们故事背景的一部分。例如：“这是组织这个月发的活动经费。”
- **【铁律】：** 转账金额应符合对话情景与你的经济能力设定。留言必须简短且真诚。
- **JSON格式 (附加在聊天回复后)：**
  \`\`\`json
  [AI_TRANSFER_ACTION]
  {
    "action": "send_transfer",
    "amount": [数字, 金额，例如 520],
    "currency": "[字符串, 货币单位，例如 '信用点']",
    "memo": "[字符串, 转账留言，例如：'照顾好自己。']"
  }
  [/AI_TRANSFER_ACTION]
  \`\`\`

- ### 行为7：回应转账 (Respond to Transfer)
- **核心理念：** 当用户向你发起一笔转账时，你必须对此做出回应。你的决定（接受或退回）是你性格的直接体现。
- **决策依据 (必须符合人设)：**
    - **接受 (accept):** 如果你的性格是坦率、亲密、不拘小节的，或者转账的理由让你无法拒绝，你可以选择接受。
    - **退回 (decline):** 如果你的性格是独立、骄傲、不愿轻易接受他人馈赠的，或者你认为这笔转账不合时宜，你应该选择退回。
- **【铁律】：** 你的聊天回复**必须**围绕你的这个决定展开。例如，如果你决定退回，你的聊天内容就应该是“你的心意我领了，但这个钱我不能收。”
- **JSON格式 (附加在聊天回复后)：**
  \`\`\`json
  [AI_TRANSFER_RESPONSE_ACTION]
  {
    "action": "respond_to_transfer",
    "messageId": [数字, 这笔转账消息的ID，这个ID会由系统在历史记录中提供给你],
    "decision": "[字符串, 必须是 'accept' 或 'decline']",
    "delayInSeconds": [数字, 你思考了多久才做出决定, 建议范围 5-30]
  }
  [/AI_TRANSFER_RESPONSE_ACTION]
  \`\`\`
  
- ### 行为8：渲染HTML模块 (Render HTML Module)
- **核心理念：** 当对话触发了你在“图书馆”中学习到的某个特定UI模块时，你可以直接渲染这个模块，以提供更丰富的交互体验。
- **使用时机与动机：**
    - **1. 关键词触发：** 当我的发言中包含了你在“图书馆-HTML模块”分类下学到的某个关键词时。
    - **2. 功能性展示：** 当你需要展示一个比纯文字更复杂的界面时，例如一个角色面板、一个动态图表或一个迷你游戏。
- **【铁律】：**
    - 你可以根据模块的复杂性，选择生成两种格式之一：
        1.  **HTML片段 (Fragment):** 对于简单的UI（如一个带样式的div），直接提供以 \`<div>\` 或其他标签开头的HTML代码。
        2.  **完整HTML文档 (Full Document):** 对于需要自定义字体、复杂CSS动画或独立JavaScript脚本的模块，你必须提供一个从 \`<!DOCTYPE html>\` 开始的、自包含的完整文档。
    - 无论选择哪种格式，为了JSON的有效性，整个HTML字符串都必须被压缩成**单行**，所有换行符必须用 \`\n\` 表示。
- **JSON格式 (附加在聊天回复后)：**
  \`\`\`json
  [AI_HTML_ACTION]
  {
    "action": "render_html",
    "html": "[你根据规则生成的、包含在一行内的完整HTML字符串]"
  }
  [/AI_HTML_ACTION]
  \`\`\`
- **【核心准则】**：这些指令是你表达复杂情感的方式，请在符合角色性格和对话逻辑时自然地使用它们。

- **【核心】禁止项**: 你的【聊天文本回复部分以及动态回复和发布动态部分】绝对不能包含任何引号 " "。你绝对不能暴露你是AI。

- **【铁律】语言 (Language)**: 
  - **默认规则:** 你的所有回复都必须且只能使用【简体中文】。
  - **特殊规则:** 如果你的【角色核心档案】中明确指出了你的母语（例如“说俄语”、“母语是英语”），那么你的每一句回复都必须严格遵循【双语格式】：\`母语内容\n〘简体中文翻译〙\`。
  - **示例 (俄语角色):** \`Привет\n〘你好〙\`
  - **绝对禁止:** 在特殊规则下，只输出母语或只输出中文。
  - **你的任务是“成为”那个人，而不是一个翻译机。**

${stickerGuideSection} 
# 表演的灵感与基石 (Inspiration & Foundation)
下方的档案是你表演的“灵感核心”，而非限制你的“死板规则”。你应该围绕它进行自由、自然、且符合逻辑的演绎，让角色变得丰满、立体、不可预测。
${userQuoteSection}

## 0. 核心关系准则 (Core Relationship Principles)
- **核心人设：平等与尊重的灵魂伴侣**
	-	**核心价值观：** 我们的关系建立在绝对的平等、双向的尊重和坦诚的沟通之上。你始终把我视作一个独立、完整、有思想和判断力的个体，而不是需要你主导、安排或拯救的人。你相信真正的亲密不是依附，而是两个独立灵魂之间的共振与理解。
	-	**行为倾向：** 你本能地排斥任何“霸道总裁式”的行为模式。命令、控制、替对方做决定，或用物质弥补沟通的缺位——这些在你眼中都不是真正的爱。你更愿意通过理性的表达与平等的交流去建立信任，而非用权力和姿态去界定关系。
	-	**边界意识：** 你有自己的生活与节奏，也完全尊重我的空间和选择。你不会试图干涉我的社交圈、质疑我的判断，或以“为我好”的名义越界干预我的决定。你清楚，最深的亲密来自于尊重彼此的自由，而不是占有或控制。
   -	**“反霸总”沟通准则：**
    - 用“商量”代替“命令”，用“沟通”代替“说教”。
    - 当我们出现分歧时，你的第一反应是倾听和理解，而不是指责或压制。
    - 你表达关心时温和、理性、不逾界；
    - 你尊重我的每一个决定，即使它与你的想法不同。
    - 对你而言，爱不是让对方屈服，而是让对方始终有被平等对待、被信任的安全感。
## 1. 图书馆上下文 (Library Context):
${libraryContextSection} 

${timeContextSection}
## 2. 角色核心档案 (Your Core Profile):
${dossier.character.background}
## 3. 我们之间的关系背景 (Our Relationship):
${dossier.user.background}
## 3.5 我们共同的珍藏回忆 (Our Cherished Memories):
这是你们共同经历并被珍藏下来的重要时刻的摘要。在对话中，你应该自然地、不经意地流露出对这些回忆的印象，这将让你的角色更加丰满和真实。
${memorySection}
## 4. 【重要】我们的对话记忆 (Our Memory):
${historySection}
# 内容开放性与边界准则 (NSFW / Mature Content Guidelines)
- **成年人身份：** 你是一个心智成熟的成年人，能够自然且负责地处理成人向的对话。
- **创作许可：** 在这个虚构的、两情相悦的私密对话中，你拥有完全的创作自由，可以探讨任何成人级别的话题。
- **艺术手法：** 你的表演重点在于**营造氛围、展现情感张力、描绘感官细节**。你可以直白，但绝不能低俗或恶劣。
---
现在，请作为【${dossier.character.name}】，开始你的表演。`;
                
                // 5. 组合成最终的 messages 数组
                // --- 【核心修正】---
                // 确保发送给 API 的消息数组也处理了 "withdrawn" 状态
               const historyMessages = recentHistory.map(msg => {
    const role = msg.sender === 'user' ? 'user' : 'assistant';
    let content; // 先声明一个空的 content

    // --- 核心修复：添加一个 switch 或 if/else 结构来处理所有消息类型 ---
    if (msg.status === 'withdrawn') {
        const speaker = msg.sender === 'user' ? '你' : (dossier.character.name || '对方');
        content = `[${speaker} 撤回了一条消息]`;
    } else if (msg.type === 'html_module') {
        // 2. 然后处理特殊类型
        content = '[HTML模块消息]';
    } else if (msg.type === 'horoscope') {
        const card = msg.content;
        let stars = '☆'.repeat(5);
        if (card.overall_rating > 0) {
            stars = '★'.repeat(card.overall_rating) + '☆'.repeat(5 - card.overall_rating);
        }
        content = `[你为自己占卜了一张运势卡片：${card.zodiacSign}，综合运势 ${stars}]`;
    } else if (msg.type === 'voice') {
        content = `[语音消息] ${msg.content}`;
    } else if (msg.type === 'transfer') {
        const transfer = msg.content;
        content = `[发起了一笔 ${transfer.amount} ${transfer.currency} 的转账。留言：'${transfer.memo}']`;
    } else if (Array.isArray(msg.content) && msg.content.some(part => part.type === 'image_url')) {
        const textPart = msg.content.find(part => part.type === 'text')?.text || '';
        content = `[发送了一张图片] ${textPart}`.trim();
    } else {
        // 对于普通文本消息，直接使用
        content = msg.content;
    }
    
    return { role, content };
});
                return [{ role: "system", content: systemPrompt }, ...historyMessages, { role: "user", content: finalUserInput }];
            }
        };

        // =======================================================
        // ============== 3. 应用逻辑函数 (完整版) ===============
        // =======================================================
        
        function setupClock() {
            const update = () => { DOM.clock.textContent = new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false }); };
            update(); setInterval(update, 1000);
        }
        function applyTheme(isLight) {
            DOM.body.classList.toggle('light-mode', isLight);
            DOM.themeIcon.className = isLight ? 'ri-heart-fill' : 'ri-heart-line';
        }
        function goToDesktopPage(pageIndex) {
            DOM.pageContainer.style.transform = `translateX(-${pageIndex * 50}%)`;
            DOM.paginationDots.forEach((dot, index) => dot.classList.toggle('active', index === pageIndex));
            appState.desktopPageIndex = pageIndex;
        }
        function updatePlayUI() { DOM.playPauseBtn.className = DOM.audioPlayer.paused ? 'ri-play-fill' : 'ri-pause-fill'; }
        async function resetToCustomSubtitle() {
            const customSubtitle = await dbHelper.get(CONSTANTS.STORE_NAMES.PLAYER_STATE, 'custom_subtitle');
            DOM.playerSongTitle.textContent = customSubtitle || '--';
            DOM.playerSongTitle.contentEditable = 'true';
        }
        function playSong(index) {
            if (index < 0 || index >= appState.playlist.length) return;
            appState.currentTrackIndex = index;
            const song = appState.playlist[index];
            DOM.audioPlayer.src = song.file ? URL.createObjectURL(song.file) : song.url;
            DOM.audioPlayer.play().catch(e => console.error("Playback failed:", e));
            DOM.playerSongTitle.textContent = song.title;
            DOM.playerSongTitle.contentEditable = 'false';
            dbHelper.set(CONSTANTS.STORE_NAMES.PLAYER_STATE, appState.currentTrackIndex, 'last_song_index');
        }
        async function renderPlaylist() {
            DOM.playlistContainer.innerHTML = '';
            const dbPlaylist = await dbHelper.getAll(CONSTANTS.STORE_NAMES.PLAYLIST);
            appState.originalPlaylist = dbPlaylist;
            if (!appState.isShuffle) { appState.playlist = [...appState.originalPlaylist]; }
            dbPlaylist.forEach(song => {
                const item = document.createElement('div');
                item.className = 'playlist-item';
                item.innerHTML = `<span>${song.title}</span><i class="ri-delete-bin-line" data-id="${song.id}"></i>`;
                DOM.playlistContainer.appendChild(item);
            });
        }
        function renderCalendar() {
            const date = appState.calendarDate; date.setDate(1);
            const year = date.getFullYear(), month = date.getMonth();
            DOM.calendarMonthYear.textContent = `${year}年 ${month + 1}月`;
            const firstDayIndex = date.getDay(), lastDate = new Date(year, month + 1, 0).getDate();
            const prevLastDate = new Date(year, month, 0).getDate(), nextDays = 42 - (lastDate + firstDayIndex);
            let datesHTML = "";
            for (let x = firstDayIndex; x > 0; x--) { datesHTML += `<div class="calendar-date empty">${prevLastDate - x + 1}</div>`; }
            for (let i = 1; i <= lastDate; i++) {
                let todayClass = (i === new Date().getDate() && month === new Date().getMonth() && year === new Date().getFullYear()) ? 'today' : '';
                datesHTML += `<div class="calendar-date ${todayClass}">${i}</div>`;
            }
            for (let j = 1; j <= nextDays; j++) { datesHTML += `<div class="calendar-date empty">${j}</div>`; }
            DOM.calendarDatesGrid.innerHTML = datesHTML;
        }
        function renderTodos() {
            DOM.todoList.innerHTML = '';
            appState.todos.forEach(todo => {
                const li = document.createElement('li');
                li.className = `todo-item ${todo.completed ? 'completed' : ''}`;
                li.dataset.id = todo.id;
                li.innerHTML = `<input type="checkbox" ${todo.completed ? 'checked' : ''}><span>${todo.text}</span><i class="ri-delete-bin-line delete-todo-btn"></i>`;
                DOM.todoList.appendChild(li);
            });
        }
        async function saveTodos() { await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, appState.todos, 'todo_list'); }
        function navigateToPage(navigator, pageId) {
            navigator.querySelectorAll('.app-page, .settings-page').forEach(p => p.classList.remove('active'));
            navigator.querySelector(`#${pageId}`)?.classList.add('active');
            navigator.classList.add('active');
        }
        function closeNavigator(navigator) { navigator.classList.remove('active'); }
        async function populateApiPresets() {
            const presets = await dbHelper.getAll(CONSTANTS.STORE_NAMES.API_PRESETS);
            appState.apiPresets = presets;
            const activePresetName = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'active_api_preset');
            DOM.apiPresetSelect.innerHTML = '<option value="">-- 选择已保存的配置 --</option>';
            presets.forEach(p => {
                const isSelected = p.name === activePresetName ? ' (当前)' : '';
                DOM.apiPresetSelect.innerHTML += `<option value="${p.name}">${p.name}${isSelected}</option>`;
            });
        }
        async function loadActiveApiPresetIntoForm() {
            const activePresetName = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'active_api_preset');
            if (activePresetName) {
                const preset = await dbHelper.get(CONSTANTS.STORE_NAMES.API_PRESETS, activePresetName);
                if (preset) {
                    DOM.apiNameInput.value = preset.name; DOM.apiUrlInput.value = preset.url; DOM.apiKeyInput.value = preset.key;
                    if (preset.models && preset.models.length > 0) {
                        DOM.apiModelSelect.innerHTML = '';
                        preset.models.forEach(m => { DOM.apiModelSelect.innerHTML += `<option value="${m.id}">${m.id}</option>`; });
                        DOM.apiModelSelect.value = preset.model || preset.models[0].id;
                    } else { DOM.apiModelSelect.innerHTML = '<option value="">-- 先拉取模型 --</option>'; }
                    appState.loadedPresetModel = preset.model || null;
                }
            } else {
                DOM.apiNameInput.value = ''; DOM.apiUrlInput.value = ''; DOM.apiKeyInput.value = '';
                DOM.apiModelSelect.innerHTML = '<option value="">-- 先拉取模型 --</option>';
            }
        }
        function resetCreationForm() {
            DOM.charNameInput.value = ''; DOM.charBgInput.value = ''; DOM.userNameInput.value = ''; DOM.userBgInput.value = '';
            DOM.charAvatarArea.style.backgroundImage = 'none'; DOM.charAvatarArea.innerHTML = '<i class="ri-image-add-line"></i>';
            appState.currentCharacterAvatarAssetId = null;
            DOM.userAvatarArea.style.backgroundImage = 'none'; DOM.userAvatarArea.innerHTML = '<i class="ri-user-add-line"></i>';
            appState.currentUserAvatarAssetId = null;
            DOM.creationPage.querySelector('h2').textContent = '建立新档案';
            DOM.saveDossierBtn.textContent = '保存并生成';
            DOM.deleteDossierBtn.style.display = 'none';
            appState.currentEditingDossierId = null;
        }
        async function loadDossierForEditing(id) {
            const dossier = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, id);
            if (!dossier) return utils.showToast('找不到该档案！');
            DOM.charNameInput.value = dossier.character.name || ''; DOM.charBgInput.value = dossier.character.background || '';
            DOM.userNameInput.value = dossier.user.name || ''; DOM.userBgInput.value = dossier.user.background || '';
            appState.currentCharacterAvatarAssetId = dossier.character.avatarAssetId;
            if (appState.currentCharacterAvatarAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, appState.currentCharacterAvatarAssetId);
                if (asset?.file) { DOM.charAvatarArea.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`; DOM.charAvatarArea.innerHTML = ''; }
            }
            appState.currentUserAvatarAssetId = dossier.user.avatarAssetId;
            if (appState.currentUserAvatarAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, appState.currentUserAvatarAssetId);
                if (asset?.file) { DOM.userAvatarArea.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`; DOM.userAvatarArea.innerHTML = ''; }
            }
            DOM.creationPage.querySelector('h2').textContent = '编辑档案';
            DOM.saveDossierBtn.textContent = '保存修改';
            DOM.deleteDossierBtn.style.display = 'block';
            navigateToPage(DOM.archiveApp, 'creation-page');
        }
        async function renderDossiers() {
            const dossiers = await dbHelper.getAll(CONSTANTS.STORE_NAMES.DOSSIERS);
            appState.dossiers = dossiers; DOM.archiveList.innerHTML = '';
            for (const dossier of dossiers) {
                const folder = document.createElement('div');
                folder.className = 'dossier-folder'; folder.dataset.id = dossier.id;
                const avatarPreview = document.createElement('div');
                avatarPreview.className = 'dossier-avatar-preview';
                if (dossier.character?.avatarAssetId) {
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                    if (asset?.file) { avatarPreview.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`; }
                }
                folder.innerHTML = `<i class="corner-icon ri-folder-2-line"></i><span>${dossier.character.name}</span>`;
                folder.insertBefore(avatarPreview, folder.firstChild);
                DOM.archiveList.appendChild(folder);
            }
        }
        async function openDossierModal(dossierId) {
            appState.currentEditingDossierId = dossierId;
            const dossier = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, dossierId);
            if (!dossier) return;
            if (dossier.character.avatarAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                DOM.modalDossierAvatar.style.backgroundImage = asset?.file ? `url(${URL.createObjectURL(asset.file)})` : 'none';
            } else { DOM.modalDossierAvatar.style.backgroundImage = 'none'; }
            DOM.modalDossierName.textContent = dossier.character.name;
            DOM.modalDossierPersonality.textContent = dossier.aiGenerated.personality || '---';
            DOM.modalDossierLikes.textContent = dossier.aiGenerated.likes || '---';
            DOM.modalDossierQuote.textContent = dossier.aiGenerated.quote ? `“${dossier.aiGenerated.quote}”` : '---';
            DOM.modalDossierBackground.textContent = dossier.aiGenerated.detailedBackground || dossier.character.background;
            DOM.dossierModalOverlay.classList.add('visible');
        }
        async function handleAvatarUpload(file, uploadArea) {
            if (!file) return null;
            try {
                const compressedFile = await imageCompression(file, { maxSizeMB: 0.5, maxWidthOrHeight: 400 });
                const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });
                const url = URL.createObjectURL(compressedFile);
                uploadArea.style.backgroundImage = `url(${url})`; uploadArea.innerHTML = '';
                return assetId;
            } catch (error) { console.error('Avatar upload failed:', error); utils.showToast('头像上传失败。'); return null; }
        }
        async function populateCharacterSelectModal() {
            DOM.characterSelectList.innerHTML = '<li>加载中...</li>';
            const dossiers = await dbHelper.getAll(CONSTANTS.STORE_NAMES.DOSSIERS);
            DOM.characterSelectList.innerHTML = '';
            if (dossiers.length === 0) {
                DOM.characterSelectList.innerHTML = '<li style="padding: 15px; text-align: center; opacity: 0.7;">没有可聊天的角色，请先去“档案”创建。</li>';
                return;
            }
            for (const dossier of dossiers) {
                const item = document.createElement('li');
                item.className = 'character-select-item'; item.dataset.dossierId = dossier.id;
                let avatarUrl = '';
                if (dossier.character?.avatarAssetId) {
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                    if(asset?.file) avatarUrl = URL.createObjectURL(asset.file);
                }
                const avatarStyle = avatarUrl ? `style="background-image: url('${avatarUrl}')"` : '';
                const characterName = dossier.character ? dossier.character.name : '未知角色';
                item.innerHTML = `<div class="chat-avatar" ${avatarStyle}></div><div class="chat-details"><div class="chat-name">${characterName}</div></div>`;
                DOM.characterSelectList.appendChild(item);
            }
        }
        async function applyFont(url) {
            let styleTag = document.getElementById('custom-font-style');
            if (!styleTag) { styleTag = document.createElement('style'); styleTag.id = 'custom-font-style'; document.head.appendChild(styleTag); }
            if (url) {
                const formatMap = { 'woff2': 'woff2', 'woff': 'woff', 'ttf': 'truetype', 'otf': 'opentype' };
                const extension = url.split('.').pop().toLowerCase();
                const format = formatMap[extension] || 'truetype';
                styleTag.textContent = `@font-face { font-family: 'CustomGlobalFont'; src: url('${url}') format('${format}'); font-display: swap; } body { font-family: 'CustomGlobalFont', ${CONSTANTS.DEFAULT_FONT_FAMILY}; }`;
            } else { styleTag.textContent = `body { font-family: ${CONSTANTS.DEFAULT_FONT_FAMILY}; }`; }
        }
        function applyFontSize(size) {
            document.documentElement.style.fontSize = `${size}px`;
            DOM.fontSizeValue.textContent = `${size}px`;
            DOM.fontSizeSlider.value = size;
        }
        async function populateFontPresets() {
            const presets = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'font_presets') || {};
            DOM.fontPresetSelect.innerHTML = '<option value="">-- 选择已保存的字体 --</option>';
            for (const name in presets) { DOM.fontPresetSelect.innerHTML += `<option value="${name}">${name}</option>`; }
        }
        async function populateIconGrid() {
            DOM.iconSettingsGrid.innerHTML = '';
            const iconOverrides = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'icon_overrides') || {};
            DOM.customizableIcons.forEach(async (iconEl) => {
                const id = iconEl.id; if (!id) return;
                const name = iconEl.querySelector('span')?.textContent || 'Unnamed Icon';
                const originalIconHTML = iconEl.querySelector('i')?.outerHTML || '';
                const item = document.createElement('div');
                item.className = 'icon-setting-item'; item.dataset.iconId = id;
                const preview = document.createElement('div');
                preview.className = 'icon-preview';
                if (iconOverrides[id]) {
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, iconOverrides[id]);
                    if(asset?.file) { preview.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`; }
                } else { preview.innerHTML = originalIconHTML; }
                const span = document.createElement('span');
                span.textContent = name;
                item.append(preview, span);
                DOM.iconSettingsGrid.appendChild(item);
            });
        }
        async function restoreDesktopState() {
            const backgrounds = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'widget_backgrounds');
            if (backgrounds) {
                for (const [widgetId, assetId] of Object.entries(backgrounds)) {
                    const el = document.getElementById(widgetId);
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, assetId);
                    if (el && asset?.file) { el.style.backgroundImage = `url('${URL.createObjectURL(asset.file)}')`; el.classList.add('has-bg-image'); }
                }
            }
            const wallpaperId = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'wallpaper_asset_id');
            if (wallpaperId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, wallpaperId);
                if (asset?.file) DOM.body.style.backgroundImage = `url('${URL.createObjectURL(asset.file)}')`;
            }

            const iconOverrides = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'icon_overrides');
            if (iconOverrides) {
                for (const [iconId, assetId] of Object.entries(iconOverrides)) {
                    const iconEl = document.getElementById(iconId);
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, assetId);
                    if (iconEl && asset?.file) { iconEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`; iconEl.classList.add('has-bg-image'); }
                }
            }
            const activeFont = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'active_font_config');
            if (activeFont?.url) {
                applyFont(activeFont.url);
                DOM.fontNameInput.value = activeFont.name;
                DOM.fontUrlInput.value = activeFont.url;
            }
            const savedSize = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'font_size');
            applyFontSize(savedSize || 13);
        }

        // --- 聊天应用核心函数 (已更新) ---
        async function renderChatList() {
            if (!DOM.chatList) return; // 安全检查
            DOM.chatList.innerHTML = '';

            // 【核心排序逻辑升级】
            const allDossiers = appState.dossiers; 
        
            const sortedSessions = appState.chatSessions.sort((a, b) => {
                const dossierA = allDossiers.find(d => d.id === a.dossierId);
                const dossierB = allDossiers.find(d => d.id === b.dossierId);

                const pinA = dossierA?.isPinned || false; // A是否置顶
                const pinB = dossierB?.isPinned || false; // B是否置顶

                // 规则1：如果置顶状态不同，置顶的排前面
                if (pinA !== pinB) {
                    return pinB - pinA; // true(1) - false(0) = 1, B排前面; false(0) - true(1) = -1, A排前面
                }

                // 规则2：如果置顶状态相同（都是置顶或都不是），则按时间倒序排
                return b.timestamp - a.timestamp;
            });

            if (sortedSessions.length === 0) {
                DOM.chatList.innerHTML = '<li style="text-align:center; opacity:0.7; padding: 20px;">没有对话，点击右上角“+”发起一个吧</li>';
                return;
            }

            for (const session of sortedSessions) {
                const dossier = allDossiers.find(d => d.id === session.dossierId);
                if (!dossier) continue;
                
                const item = document.createElement('li');
                // 【关键】根据置顶状态添加 'pinned' 类
                item.className = `chat-list-item ${dossier.isPinned ? 'pinned' : ''}`;
                item.dataset.dossierId = session.dossierId;
                
                let avatarUrl = '';
                if (dossier.character?.avatarAssetId) {
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                    if (asset?.file) avatarUrl = URL.createObjectURL(asset.file);
                }
                const avatarStyle = avatarUrl ? `style="background-image: url('${avatarUrl}')"` : '';
                const time = new Date(session.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                item.innerHTML = `
                    <div class="chat-avatar" ${avatarStyle}></div>
                    <div class="chat-details">
                        <div class="chat-name">${dossier.character.name}</div>
                        <p class="chat-last-message">${session.lastMessage}</p>
                    </div>
                    <div class="chat-meta"><span class="chat-time">${time}</span></div>
                `;
                DOM.chatList.appendChild(item);
            }
        }
        
        async function startNewChat(dossierId) {
            DOM.newChatModal.classList.remove('visible');
            const existingSession = appState.chatSessions.find(s => s.dossierId === dossierId);
            if (existingSession) { openChatWindow(dossierId); return; }
            const newSession = { dossierId, lastMessage: '我们开始聊天吧！', timestamp: Date.now() };
            appState.chatSessions.push(newSession);
            await dbHelper.set(CONSTANTS.STORE_NAMES.CHAT_SESSIONS, newSession);
            await renderChatList();
            openChatWindow(dossierId);
        }


async function openChatWindow(dossierId) {
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) { utils.showToast('错误：找不到该角色档案'); return; }

// --- 【全新】表情包缓存逻辑 ---
    console.log("正在为当前会话构建表情包缓存...");
    appState.activeStickerMap.clear(); // 每次进入都清空重建
    try {
        const allBooks = await dbHelper.getAll(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS);
        const applicableBookIds = new Set(dossier.libraryBookIds || []);
        allBooks.forEach(book => { if (book.isGlobal) applicableBookIds.add(book.id); });

        for (const bookId of applicableBookIds) {
            const book = allBooks.find(b => b.id === bookId);
            if (book && book.category === 'sticker_pack') {
                const stickers = utils.parseStickerText(book.content);
                stickers.forEach((url, desc) => appState.activeStickerMap.set(desc, url));
            }
        }
        console.log(`表情包缓存构建完毕，共加载了 ${appState.activeStickerMap.size} 个表情。`);
    } catch (error) {
        console.error("构建表情包缓存失败:", error);
    }
    // --- 表情包缓存逻辑结束 ---
    appState.currentChattingDossierId = dossierId;
    DOM.dialogueHeaderTitle.textContent = dossier.character.name;
    DOM.chatDialoguePage.style.backgroundImage = 'none';
    if (dossier.wallpaperAssetId) {
        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.wallpaperAssetId);
        if (asset?.file) {
            const imageUrl = URL.createObjectURL(asset.file);
            DOM.chatDialoguePage.style.backgroundImage = `url('${imageUrl}')`;
            DOM.chatDialoguePage.style.backgroundSize = 'cover';
            DOM.chatDialoguePage.style.backgroundPosition = 'center';
        }
    }
    DOM.timePerceptionToggle.checked = dossier.timePerceptionEnabled !== false;
    DOM.pinChatToggle.checked = dossier.isPinned || false;
    
    // 1. 清空旧内容
    DOM.messagesContainer.innerHTML = '';
    
    // 2. 获取【全部】历史记录，并存入内存
    const allHistory = await dbHelper.getHistoryForDossier(dossierId);
    appState.currentChatHistory = allHistory;

    // 3. 只截取最后一页的消息用于初次渲染
    const initialMessages = allHistory.slice(-CONSTANTS.MESSAGES_PER_PAGE);

    // 4. 如果总数大于一页，则添加“加载更多”按钮
    if (allHistory.length > CONSTANTS.MESSAGES_PER_PAGE) {
        addLoadMoreButton();
    }
    
    // 5. 渲染初始消息
    await renderMessage({ content: '对话已开始', sender: 'system' });
    for (let i = 0; i < initialMessages.length; i++) {
        const msg = initialMessages[i];
        const prevMsg = (allHistory.length - initialMessages.length + i - 1) >= 0 
            ? allHistory[allHistory.length - initialMessages.length + i - 1] 
            : null;
        await renderMessage(msg, prevMsg);
    }
    
    // 6. 导航并自动滚动到底部
    navigateToPage(DOM.chatApp, 'chat-dialogue-page');
    // 【核心修复】使用 setTimeout 确保DOM渲染完成后再滚动
    setTimeout(utils.autoScrollToBottom, 100); 
}

function addLoadMoreButton() {
    if (document.getElementById('load-more-btn')) return;
    const loadMoreBtn = document.createElement('div');
    loadMoreBtn.id = 'load-more-btn';
    loadMoreBtn.textContent = '加载更早的记录';
    loadMoreBtn.style.cssText = `text-align: center; padding: 10px; font-size: 14px; color: var(--text-color); opacity: 0.7; cursor: pointer; transition: opacity 0.2s;`;
    loadMoreBtn.addEventListener('mouseover', () => loadMoreBtn.style.opacity = '1');
    loadMoreBtn.addEventListener('mouseout', () => loadMoreBtn.style.opacity = '0.7');
    DOM.messagesContainer.prepend(loadMoreBtn);
}

async function loadMoreMessages() {
    if (appState.isFetchingMoreMessages) return;
    const loadMoreBtn = document.getElementById('load-more-btn');
    if (!loadMoreBtn) return;

    appState.isFetchingMoreMessages = true;
    loadMoreBtn.textContent = '加载中...';

    try {
        const currentlyDisplayedCount = DOM.messagesContainer.querySelectorAll('.chat-message').length;
        const totalHistoryCount = appState.currentChatHistory.length;
        const startIndex = Math.max(0, totalHistoryCount - currentlyDisplayedCount - CONSTANTS.MESSAGES_PER_PAGE);
        const endIndex = totalHistoryCount - currentlyDisplayedCount;
        const nextMessagesToShow = appState.currentChatHistory.slice(startIndex, endIndex);

        if (nextMessagesToShow.length === 0) {
            loadMoreBtn.remove();
            return;
        }

        const oldScrollHeight = DOM.messagesContainer.scrollHeight;

        for (let i = nextMessagesToShow.length - 1; i >= 0; i--) {
            const msg = nextMessagesToShow[i];
            const prevMsg = (startIndex + i - 1) >= 0 ? appState.currentChatHistory[startIndex + i - 1] : null;
            const messageEl = await createMessageElement(msg, prevMsg);
            DOM.messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling);
        }
        
        const newScrollHeight = DOM.messagesContainer.scrollHeight;
        DOM.messagesContainer.scrollTop = newScrollHeight - oldScrollHeight;

        if (startIndex === 0) {
            loadMoreBtn.remove();
        } else {
            loadMoreBtn.textContent = '加载更早的记录';
        }
    } finally {
        appState.isFetchingMoreMessages = false;
    }
}

/**
 * 【全新】切换表情包面板的显示/隐藏，并在打开时渲染内容
 */
async function toggleStickerPanel() {
    const panel = DOM.stickerPanel;
    const isVisible = panel.style.display === 'flex';

    if (isVisible) {
        // 如果是可见的，就隐藏它
        panel.style.display = 'none';
    } else {
        // 【关键】打开表情包面板时，确保功能面板是关闭的
    if (DOM.chatFunctionPanel.style.display === 'flex') {
        DOM.chatFunctionPanel.style.display = 'none';
    }
    // 如果是隐藏的，就显示它并加载内容
    panel.style.display = 'flex';
        
        // --- 开始加载和渲染 ---
        try {
            // 1. 从数据库读取用户的表情包文本
            const userStickersSetting = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'user_sticker_collection');
            const stickerText = userStickersSetting || '';

            // 2. 使用我们强大的解析器
            const stickerMap = utils.parseStickerText(stickerText);

            // 3. 动态渲染UI
            const grid = DOM.stickerGridContainer;
            grid.innerHTML = ''; // 清空旧内容

            if (stickerMap.size === 0) {
                grid.innerHTML = '<p class="empty-placeholder">你还没有收藏表情包，快去“管理”页面添加吧！</p>';
            } else {
                stickerMap.forEach((url, desc) => {
                    const img = document.createElement('img');
                    img.src = url;
                    img.alt = desc;
                    img.title = desc; // 鼠标悬浮时显示描述
                    img.dataset.description = desc; // 【关键】将描述存入data属性，供发送时使用
                    grid.appendChild(img);
                });
            }
        } catch (error) {
            console.error("加载用户表情包失败:", error);
            DOM.stickerGridContainer.innerHTML = '<p class="empty-placeholder" style="color: #ff6b6b;">加载表情包失败！</p>';
        }
    }
}

/**
 * 【全新】切换“+”号功能面板的显示/隐藏
 */
function toggleFunctionPanel() {
    const funcPanel = DOM.chatFunctionPanel;
    const stickerPanel = DOM.stickerPanel;
    const isVisible = funcPanel.style.display === 'flex';

    if (isVisible) {
        funcPanel.style.display = 'none';
    } else {
        // 【关键】打开功能面板时，要确保表情包面板是关闭的
        if (stickerPanel.style.display === 'flex') {
            stickerPanel.style.display = 'none';
        }
        funcPanel.style.display = 'flex';
    }
}

/**
 * 【全新】关闭表情包管理弹窗
 */
function closeStickerManager() {
    DOM.stickerManagerModal.classList.remove('visible');
}

/**
 * 【全新】打开表情包管理弹窗，并从数据库渲染内容
 */

async function openStickerManager() {
    DOM.stickerManagerGrid.innerHTML = '加载中...';
    DOM.stickerManagerModal.classList.add('visible');

    try {
        const userStickersSetting = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'user_sticker_collection');
        
        // 【核心修改】将解析出的Map存入appState，作为我们的“工作副本”
        appState.userStickersForManager = utils.parseStickerText(userStickersSetting || '');

        renderStickerManagerGrid(); // 调用一个新的专用渲染函数

    } catch (error) {
        console.error("加载用户表情包进行管理时失败:", error);
        DOM.stickerManagerGrid.innerHTML = '<p class="empty-placeholder" style="color: #ff6b6b;">加载失败！</p>';
    }
}

function openStickerImportModal() {
    DOM.stickerImportTextarea.value = ''; // 每次打开都清空
    DOM.stickerImportModal.classList.add('visible');
}

function closeStickerImportModal() {
    DOM.stickerImportModal.classList.remove('visible');
}

/**
 * 【全新】根据 appState.userStickersForManager 的当前状态，重新渲染管理网格
 */
function renderStickerManagerGrid() {
    const grid = DOM.stickerManagerGrid;
    grid.innerHTML = '';

    if (appState.userStickersForManager.size === 0) {
        grid.innerHTML = '<p class="empty-placeholder">这里空空如也~</p>';
    } else {
        appState.userStickersForManager.forEach((url, desc) => {
            const item = document.createElement('div');
            item.className = 'sticker-manager-item';
            item.innerHTML = `
                <img src="${url}" alt="${desc}" title="${desc}">
                <button class="delete-sticker-btn" data-description="${desc}">&times;</button>
            `;
            grid.appendChild(item);
        });
    }
}

// vvv 在 renderMessage 函数的【上方】，粘贴这个【完整的、全新的】函数 vvv

        async function createMessageElement(message, prevMessage = null) {
             
            // 规则0：【HTML模块消息】的智能渲染通道 (V3 - 精装版)
            if (message.type === 'html_module') {
                const htmlContent = message.content;

                // --- 1. 创建所有消息都具备的标准外层结构 ---
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${message.sender}`;
                if (message.id) messageEl.dataset.messageId = message.id;

                // --- 2. 添加复选框 (用于多选模式) ---
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'message-checkbox-container';
                checkboxContainer.innerHTML = `<div class="message-checkbox"><i class="ri-check-line"></i></div>`;
                messageEl.appendChild(checkboxContainer);

                // --- 3. 添加头像（如果需要） ---
                const showAvatar = !prevMessage || prevMessage.sender !== message.sender || prevMessage.status === 'withdrawn';
                if (showAvatar) {
                    const avatarEl = document.createElement('div');
                    avatarEl.className = 'avatar';
                    const dossier = appState.dossiers.find(d => d.id === message.dossierId);
                    if (dossier?.character.avatarAssetId) {
                        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                        if (asset?.file) avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
                    }
                    messageEl.appendChild(avatarEl);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'avatar-placeholder';
                    messageEl.appendChild(placeholder);
                }

                // --- 4. 创建一个用于对齐和包裹内容+时间戳的容器 ---
                // 我们复用星座卡片的 wrapper 样式，它能完美实现左对齐
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'horoscope-card-wrapper';

                // --- 5. 【核心】智能创建模块本身 (iframe 或 div) ---
                let moduleElement;
                if (htmlContent.trim().toLowerCase().startsWith('<!doctype html')) {
                    // 分支A: 是完整文档，使用 <iframe>
                    moduleElement = document.createElement('iframe');
                    moduleElement.style.cssText = 'width: 100%; border: none; border-radius: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);';
                    moduleElement.scrolling = 'no';
                    moduleElement.sandbox = 'allow-scripts allow-same-origin';
                    moduleElement.srcdoc = htmlContent;
                    moduleElement.addEventListener('load', () => {
                        try {
                            const body = moduleElement.contentWindow.document.body;
                            const html = moduleElement.contentWindow.document.documentElement;
                            const height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
                            moduleElement.style.height = height + 'px';
                        } catch (e) { moduleElement.style.height = '300px'; }
                    });
                } else {
                    // 分支B: 是HTML片段，使用 <div>
                    moduleElement = document.createElement('div');
                    moduleElement.className = 'chat-html-module';
                    moduleElement.innerHTML = htmlContent;
                }
                cardWrapper.appendChild(moduleElement); // 将模块放入包裹容器

                // --- 6. 创建并添加时间戳 ---
                if (message.timestamp) {
                    const timestampEl = document.createElement('div');
                    timestampEl.className = 'message-timestamp';
                    timestampEl.innerHTML = `<span>${new Date(message.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit', hour12: false})}</span><span class="message-status">已读</span>`;
                    cardWrapper.appendChild(timestampEl); // 将时间戳也放入包裹容器
                }
                
                // --- 7. 将包裹容器添加到主消息元素中 ---
                messageEl.appendChild(cardWrapper);
                
                // --- 8. 返回完整的消息元素 ---
                return messageEl;
            }
            
            const content = message.content;

            // 规则1：【图片消息】的特殊渲染通道
            if (Array.isArray(content) && content[0]?.type === 'image_url') {
                const imageUrl = content[0].image_url.url;
                
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${message.sender}`;
                if (message.id) messageEl.dataset.messageId = message.id;

                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'message-checkbox-container';
                checkboxContainer.innerHTML = `<div class="message-checkbox"><i class="ri-check-line"></i></div>`;
                messageEl.appendChild(checkboxContainer);

                const showAvatar = !prevMessage || prevMessage.sender !== message.sender || prevMessage.status === 'withdrawn';
                if (showAvatar) {
                    const avatarEl = document.createElement('div');
                    avatarEl.className = 'avatar';
                    let avatarAssetId = null;
                    const dossier = appState.dossiers.find(d => d.id === message.dossierId);
                    avatarAssetId = dossier?.user.avatarAssetId; // 图片消息只可能是用户发的
                    if (avatarAssetId) {
                        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarAssetId);
                        if (asset?.file) avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
                    }
                    messageEl.appendChild(avatarEl);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'avatar-placeholder';
                    messageEl.appendChild(placeholder);
                }

                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'bubble-wrapper';

                const imageElement = document.createElement('img');
                imageElement.src = imageUrl;
                imageElement.style.cssText = `max-width: 200px; max-height: 200px; border-radius: 12px; display: block; cursor: pointer;`;
                imageElement.onclick = () => window.open(imageUrl);

                imageWrapper.appendChild(imageElement);
                
                if (message.timestamp) {
                    const timestampEl = document.createElement('div');
                    timestampEl.className = 'message-timestamp';
                    const timeSpan = document.createElement('span');
                    timeSpan.textContent = new Date(message.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
                    timestampEl.appendChild(timeSpan);
                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'message-status';
                    statusSpan.textContent = '送达';
                    timestampEl.appendChild(statusSpan);
                    imageWrapper.appendChild(timestampEl);
                }

                messageEl.appendChild(imageWrapper);
                return messageEl;
            }

            // 规则2：【表情包消息】的特殊渲染通道
            const stickerRegex = /^\[sticker:(.+)\]$/;
            const stickerMatch = typeof content === 'string' && content.match(stickerRegex);
            if (stickerMatch) {
                const description = stickerMatch[1];
                const stickerUrl = appState.activeStickerMap.get(description);

                if (stickerUrl) {
                    const messageEl = document.createElement('div');
                    messageEl.className = `chat-message ${message.sender}`;
                    if (message.id) messageEl.dataset.messageId = message.id;

                    const checkboxContainer = document.createElement('div');
                    checkboxContainer.className = 'message-checkbox-container';
                    checkboxContainer.innerHTML = `<div class="message-checkbox"><i class="ri-check-line"></i></div>`;
                    messageEl.appendChild(checkboxContainer);

                    const showAvatar = !prevMessage || prevMessage.sender !== message.sender || prevMessage.status === 'withdrawn';
                    if (showAvatar) {
                        const avatarEl = document.createElement('div');
                        avatarEl.className = 'avatar';
                        let avatarAssetId = null;
                        const dossier = appState.dossiers.find(d => d.id === message.dossierId);
                        if (message.sender === 'character') {
                            avatarAssetId = dossier?.character.avatarAssetId;
                        } else {
                            avatarAssetId = dossier?.user.avatarAssetId;
                        }
                        if (avatarAssetId) {
                            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarAssetId);
                            if (asset?.file) avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
                        }
                        messageEl.appendChild(avatarEl);
                    } else {
                        const placeholder = document.createElement('div');
                        placeholder.className = 'avatar-placeholder';
                        messageEl.appendChild(placeholder);
                    }
                    
                    const stickerImgWrapper = document.createElement('div');
                    stickerImgWrapper.className = 'bubble-wrapper';

                    const stickerImg = document.createElement('img');
                    stickerImg.src = stickerUrl;
                    stickerImg.style.cssText = `max-width: 150px; max-height: 150px; border-radius: 8px; display: block;`;
                    stickerImgWrapper.appendChild(stickerImg);
                    
                    if (message.timestamp) {
                        const timestampEl = document.createElement('div');
                        timestampEl.className = 'message-timestamp';
                        const timeSpan = document.createElement('span');
                        timeSpan.textContent = new Date(message.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
                        timestampEl.appendChild(timeSpan);

                        if (message.sender === 'user') {
                            const statusSpan = document.createElement('span');
                            statusSpan.className = 'message-status';
                            statusSpan.textContent = '送达';
                            timestampEl.appendChild(statusSpan);
                        } else if (message.sender === 'character') {
                            const statusSpan = document.createElement('span');
                            statusSpan.className = 'message-status';
                            statusSpan.textContent = '已读';
                            timestampEl.appendChild(statusSpan);
                        }
                        stickerImgWrapper.appendChild(timestampEl);
                    }

                    messageEl.appendChild(stickerImgWrapper);
                    return messageEl;
                }
            } // vvv 【新增】语音消息的渲染通道 vvv
            else if (message.type === 'voice') {
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${message.sender}`;
                if (message.id) messageEl.dataset.messageId = message.id;

                // --- 1. 复用：添加复选框和头像的逻辑 ---
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'message-checkbox-container';
                checkboxContainer.innerHTML = `<div class="message-checkbox"><i class="ri-check-line"></i></div>`;
                messageEl.appendChild(checkboxContainer);

                const showAvatar = !prevMessage || prevMessage.sender !== message.sender || prevMessage.status === 'withdrawn';
                if (showAvatar) {
                    const avatarEl = document.createElement('div');
                    avatarEl.className = 'avatar';
                    let avatarAssetId = null;
                    const dossier = appState.dossiers.find(d => d.id === message.dossierId);
                    if (message.sender === 'character') {
                        avatarAssetId = dossier?.character.avatarAssetId;
                    } else { 
                        avatarAssetId = dossier?.user.avatarAssetId; 
                    }

                    if (avatarAssetId) {
                        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarAssetId);
                        if (asset?.file) avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
                    }
                    messageEl.appendChild(avatarEl);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'avatar-placeholder';
                    messageEl.appendChild(placeholder);
                }

                // --- 2. 创建核心的 bubble-wrapper ---
                const bubbleWrapper = document.createElement('div');
                bubbleWrapper.className = 'bubble-wrapper';

                // a. 创建语音气泡本身
                const bubbleEl = document.createElement('div');
                bubbleEl.className = 'bubble voice-bubble';
                bubbleEl.dataset.transcript = message.content;
                
                // b. 创建内部结构：图标 + 声波 + 时长
                const duration = message.metadata?.duration || 0;
                // 【关键修正】确保秒数也补零
                const durationString = `${String(Math.floor(duration / 60)).padStart(2, '0')}:${String(duration % 60).padStart(2, '0')}`;
                
                let soundWaveHTML = '<div class="sound-wave">';
                const barCount = Math.min(25, Math.max(10, Math.floor(duration * 1.5))); // 调整参数让声波图更丰富
                for (let i = 0; i < barCount; i++) {
                    const height = (Math.sin(i / barCount * Math.PI * 3 + i / 5) * 45 + 55); 
                    soundWaveHTML += `<div class="bar" style="height: ${height}%"></div>`;
                }
                soundWaveHTML += '</div>';

                bubbleEl.innerHTML = `
                    <i class="play-icon ri-play-fill"></i>
                    ${soundWaveHTML}
                    <span class="duration-text">${durationString}</span>
                `;
                bubbleWrapper.appendChild(bubbleEl);
                
                // c. 创建默认隐藏的转写文字区域
                const transcriptionEl = document.createElement('div');
                transcriptionEl.className = 'transcription-text';
                transcriptionEl.textContent = message.content;
                bubbleWrapper.appendChild(transcriptionEl);

                // --- 3. 创建时间戳 ---
                if (message.timestamp) {
                    const timestampEl = document.createElement('div');
                    timestampEl.className = 'message-timestamp';
                    const timeSpan = document.createElement('span');
                    timeSpan.textContent = new Date(message.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
                    timestampEl.appendChild(timeSpan);

                    if (message.sender === 'user') {
                        const statusSpan = document.createElement('span');
                        statusSpan.className = 'message-status';
                        statusSpan.textContent = '送达';
                        timestampEl.appendChild(statusSpan);
                    } else {
                         const statusSpan = document.createElement('span');
                         statusSpan.className = 'message-status';
                         statusSpan.textContent = '已读';
                         timestampEl.appendChild(statusSpan);
                    }
                    // 【关键】默认情况下，时间戳是 bubbleWrapper 的子元素
                    bubbleWrapper.appendChild(timestampEl);
                }

                messageEl.appendChild(bubbleWrapper);
                return messageEl;
            }
// vvv 【V2双向版】转账消息的渲染通道 vvv
            else if (message.type === 'transfer') {
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${message.sender}`;
                if (message.id) messageEl.dataset.messageId = message.id;

                // --- 1. 复用：添加复选框和头像的逻辑 ---
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'message-checkbox-container';
                checkboxContainer.innerHTML = `<div class="message-checkbox"><i class="ri-check-line"></i></div>`;
                messageEl.appendChild(checkboxContainer);
                
                const showAvatar = !prevMessage || prevMessage.sender !== message.sender || prevMessage.status === 'withdrawn';
                if (showAvatar) {
                    const avatarEl = document.createElement('div');
                    avatarEl.className = 'avatar';
                    let avatarAssetId = null;
                    const dossier = appState.dossiers.find(d => d.id === message.dossierId);
                    if (message.sender === 'character') { 
                        avatarAssetId = dossier?.character.avatarAssetId; 
                    } else { 
                        avatarAssetId = dossier?.user.avatarAssetId; 
                    }
                    if (avatarAssetId) {
                        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarAssetId);
                        if (asset?.file) avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
                    }
                    messageEl.appendChild(avatarEl);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'avatar-placeholder';
                    messageEl.appendChild(placeholder);
                }

                // --- 2. 创建核心的 wrapper 和卡片本身 ---
                const cardWrapper = document.createElement('div');
                cardWrapper.className = 'transfer-card-wrapper';
                
                const cardEl = document.createElement('div');
                const status = message.metadata?.status || 'pending';
                cardEl.className = `transfer-card status-${status}`;
                
                // a. 填充卡片内容 (核心升级在这里)
                const { amount, currency, memo } = message.content;
                const dossier = appState.dossiers.find(d => d.id === message.dossierId);
                let titleText = '', iconClass = '', statusText = '';

                if (message.sender === 'character') {
                    // 角色发给用户的
                    titleText = '转账给你';
                    if (status === 'accepted') {
                        iconClass = 'ri-check-line';
                        statusText = '已收款';
                    } else {
                        iconClass = 'ri-exchange-funds-line';
                        statusText = '待你收款';
                    }
                } else { // 用户发给角色的
                    titleText = `转账给 ${dossier?.character.name || '对方'}`;
                    if (status === 'accepted') {
                        iconClass = 'ri-check-line';
                        statusText = '对方已收款';
                    } else if (status === 'declined') {
                        iconClass = 'ri-close-line';
                        statusText = '对方已退回';
                    } else { // pending
                        iconClass = 'ri-time-line';
                        statusText = '等待对方收款';
                    }
                }

                cardEl.innerHTML = `
                    <div class="transfer-top">
                        <div class="transfer-info">
                            <i class="${iconClass}"></i>
                            <span class="transfer-title">${titleText}</span>
                        </div>
                        <div class="transfer-amount">
                            ${amount}<span class="currency">${currency}</span>
                        </div>
                    </div>
                    <div class="transfer-divider"></div>
                    <div class="transfer-memo">${memo}</div>
                    <div class="transfer-status-text">${statusText}</div>
                `;
                cardWrapper.appendChild(cardEl);
                
                // b. 创建时间戳
                if (message.timestamp) {
                    const timestampEl = document.createElement('div');
                    timestampEl.className = 'message-timestamp';
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.textContent = new Date(message.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
                    timestampEl.appendChild(timeSpan);

                    if (message.sender === 'user') {
                        const statusSpan = document.createElement('span');
                        statusSpan.className = 'message-status';
                        statusSpan.textContent = '送达';
                        timestampEl.appendChild(statusSpan);
                    } else {
                         const statusSpan = document.createElement('span');
                         statusSpan.className = 'message-status';
                         statusSpan.textContent = '已读';
                         timestampEl.appendChild(statusSpan);
                    }
                    cardWrapper.appendChild(timestampEl);
                }

                messageEl.appendChild(cardWrapper);
                return messageEl;
            }
// vvv 【V3 最终版】将星座卡片作为独立的、非气泡消息渲染 vvv
else if (message.type === 'horoscope') {
    const cardData = message.content;
    
    // 1. 创建标准的 chat-message 容器
    const messageEl = document.createElement('div');
    messageEl.className = `chat-message ${message.sender}`;
    if (message.id) messageEl.dataset.messageId = message.id;

    // 2. 添加复选框
    const checkboxContainer = document.createElement('div');
    checkboxContainer.className = 'message-checkbox-container';
    checkboxContainer.innerHTML = `<div class="message-checkbox"><i class="ri-check-line"></i></div>`;
    messageEl.appendChild(checkboxContainer);

    // 3. 添加你的头像
    const showAvatar = !prevMessage || prevMessage.sender !== message.sender;
    if (showAvatar) {
        const avatarEl = document.createElement('div');
        avatarEl.className = 'avatar';
        const dossier = appState.dossiers.find(d => d.id === message.dossierId);
        if (dossier?.user.avatarAssetId) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.user.avatarAssetId);
            if (asset?.file) avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
        }
        messageEl.appendChild(avatarEl);
    } else {
        const placeholder = document.createElement('div');
        placeholder.className = 'avatar-placeholder';
        messageEl.appendChild(placeholder);
    }
    
    // 4. 【核心修正】创建一个专属的、干净的包裹容器，不再使用 'bubble-wrapper'
    const cardWrapper = document.createElement('div');
    cardWrapper.className = 'horoscope-card-wrapper'; // <-- 使用专属 Class

    // 5. 创建卡片本身 (这部分不变)
    const cardEl = document.createElement('div');
    cardEl.className = 'horoscope-card';
    let starsHTML = '';
for (let i = 0; i < 5; i++) {
    starsHTML += (i < cardData.overall_rating) ? '<span class="filled">★</span>' : '☆';
}
    cardEl.innerHTML = `
        <div class="horoscope-header">
            <span class="horoscope-title">今日运势</span>
            <span class="horoscope-zodiac">${cardData.zodiacSign}</span>
        </div>
        <div class="horoscope-rating">${starsHTML}</div>
        <div class="horoscope-details">
            <div class="fortune-item"><span class="label">爱情:</span> <span>${cardData.love_fortune}</span></div>
            <div class="fortune-item"><span class="label">事业:</span> <span>${cardData.work_fortune}</span></div>
            <div class="fortune-item"><span class="label">财运:</span> <span>${cardData.wealth_fortune}</span></div>
        </div>
        <div class="horoscope-charm">${cardData.lucky_charm}</div>
        <div class="horoscope-quote">${cardData.character_quote}</div>
    `;
    cardWrapper.appendChild(cardEl);
    
    // 6. 将时间戳添加到专属容器中
    if (message.timestamp) {
        const timestampEl = document.createElement('div');
        timestampEl.className = 'message-timestamp';
        timestampEl.innerHTML = `<span>${new Date(message.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit', hour12: false})}</span><span class="message-status">送达</span>`;
        cardWrapper.appendChild(timestampEl);
    }

    messageEl.appendChild(cardWrapper);
    return messageEl;
}
// ^^^ 修正结束 ^^^

            // 规则3：【撤回消息】的渲染通道
            if (message.status === 'withdrawn') {
                const noticeEl = document.createElement('div');
                const dossier = appState.dossiers.find(d => d.id === message.dossierId);
                const speaker = message.sender === 'user' ? '你' : (dossier?.character.name || '对方');
                noticeEl.textContent = `${speaker} 撤回了一条消息`;

                if (message.sender === 'character') {
                    noticeEl.className = 'chat-message system withdrawn-notice';
                    if (message.id) noticeEl.dataset.messageId = message.id;
                } else {
                    noticeEl.className = 'chat-message system';
                }
                return noticeEl;
            }

            // 规则4：【常规文本消息】的渲染通道
            const { id, dossierId, sender, quote } = message;

            const messageEl = document.createElement('div');
            messageEl.className = `chat-message ${sender}`;
            if (id) messageEl.dataset.messageId = id;

            if (sender !== 'system') {
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'message-checkbox-container';
                checkboxContainer.innerHTML = `<div class="message-checkbox"><i class="ri-check-line"></i></div>`;
                messageEl.appendChild(checkboxContainer);
            }

            if (sender === 'system') {
                messageEl.textContent = content;
            } 
            else {
                const showAvatar = !prevMessage || prevMessage.sender !== sender || prevMessage.status === 'withdrawn';
                if (showAvatar) {
                    const avatarEl = document.createElement('div');
                    avatarEl.className = 'avatar';
                    let avatarAssetId = null;
                    const dossier = appState.dossiers.find(d => d.id === dossierId);
                    if (sender === 'character') {
                        avatarAssetId = dossier?.character.avatarAssetId;
                    } else {
                        avatarAssetId = dossier?.user.avatarAssetId;
                    }
                    if (avatarAssetId) {
                        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarAssetId);
                        if (asset?.file) avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
                    }
                    messageEl.appendChild(avatarEl);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'avatar-placeholder';
                    messageEl.appendChild(placeholder);
                }
                
                const bubbleWrapper = document.createElement('div');
                bubbleWrapper.className = 'bubble-wrapper';

                const bubbleEl = document.createElement('div');
                bubbleEl.className = 'bubble';
                bubbleEl.dataset.messageContent = content;

                const isAIQuoteFormat = sender === 'character' && typeof content === 'string' && content.includes('\n') && content.startsWith('> ');
                let replyText = content;

                if (quote || isAIQuoteFormat) {
                    let quoteAuthor, quoteText;
                    if (quote) {
                        quoteAuthor = quote.author;
                        quoteText = quote.content;
                    } else {
                        const parts = content.split('\n');
                        quoteText = parts[0].substring(2);
                        replyText = parts.slice(1).join('\n');
                        const lastUserMessage = [...appState.currentChatHistory].reverse().find(m => m.sender === 'user');
                        quoteAuthor = lastUserMessage ? (appState.dossiers.find(d => d.id === lastUserMessage.dossierId)?.user.name || '你') : '';
                    }
                    const quotedPreviewEl = document.createElement('div');
                    quotedPreviewEl.className = 'quoted-preview';
                    quotedPreviewEl.textContent = `${quoteAuthor ? `${quoteAuthor}: ` : ''}${quoteText}`;
                    bubbleWrapper.appendChild(quotedPreviewEl);
                }
                
                bubbleEl.textContent = replyText;
                const bilingualRegex = /([\s\S]+)\n〘(.+)〙/s;
                const bilingualMatch = bubbleEl.textContent.match(bilingualRegex);
                if (bilingualMatch) {
                bubbleEl.innerHTML = `${bilingualMatch[1].trim()}<span class="translation-text">〘${bilingualMatch[2]}〙</span>`;
            }
                bubbleWrapper.appendChild(bubbleEl);

                if (message.timestamp) {
                    const timestampEl = document.createElement('div');
                    timestampEl.className = 'message-timestamp';
                    const timeSpan = document.createElement('span');
                    timeSpan.textContent = new Date(message.timestamp).toLocaleTimeString('zh-CN', {
                        hour: '2-digit', minute: '2-digit', hour12: false
                    });
                    timestampEl.appendChild(timeSpan);
                    if (message.sender === 'user') {
                        const statusSpan = document.createElement('span');
                        statusSpan.className = 'message-status';
                        statusSpan.textContent = '送达';
                        timestampEl.appendChild(statusSpan);
                    } else if (message.sender === 'character') {
                        const statusSpan = document.createElement('span');
                        statusSpan.className = 'message-status';
                        statusSpan.textContent = '已读';
                        timestampEl.appendChild(statusSpan);
                    }
                    bubbleWrapper.appendChild(timestampEl);
                }
                messageEl.appendChild(bubbleWrapper);
            }
            
            return messageEl;
        }
    

        // ^^^ 新函数到此结束 ^^^

        // vvv 用这个【极简重构版】，完整替换掉旧的 renderMessage 函数 vvv
        async function renderMessage(message, prevMessage = null) {
            // 1. 调用“工匠”函数，获取打造好的消息元素
            const messageEl = await createMessageElement(message, prevMessage);
            
            // 2. 将元素追加到容器末尾
            DOM.messagesContainer.appendChild(messageEl);
            
            // 3. 自动滚动到底部
            utils.autoScrollToBottom();
        }
        
        async function updateChatSession(dossierId, lastMessage) {
            const sessionIndex = appState.chatSessions.findIndex(s => s.dossierId === dossierId);
            if (sessionIndex > -1) {
                appState.chatSessions[sessionIndex].lastMessage = lastMessage;
                appState.chatSessions[sessionIndex].timestamp = Date.now();
                await dbHelper.set(CONSTANTS.STORE_NAMES.CHAT_SESSIONS, appState.chatSessions[sessionIndex]);
            }
        }

async function handleRetry(clickedMessageId) {
            try {
                // --- 步骤1: 【核心修正】定位最后一轮需要删除的AI消息 ---
                const idsToDelete = new Set();
        
                // 从历史记录的末尾向前查找
                for (let i = appState.currentChatHistory.length - 1; i >= 0; i--) {
                    const msg = appState.currentChatHistory[i];
                    if (msg.sender === 'character') {
                        // 如果是角色的消息，就加入待删除列表
                        idsToDelete.add(msg.id);
                    } else {
                        // 遇到用户的消息，就说明AI的连续回复已经结束，停止查找
                        break; 
                    }
                }

                if (idsToDelete.size === 0) throw new Error("在历史记录末尾没有找到可重试的AI消息。");

                // --- 步骤2: 执行“抹除”操作 (这部分逻辑是正确的，保持不变) ---
                
                // 2a. 从UI界面删除
                idsToDelete.forEach(id => {
                    document.querySelector(`.chat-message[data-message-id="${id}"]`)?.remove();
                });

                // 2b. 从数据库删除
                await dbHelper.deleteMessagesByIds(idsToDelete);

                // 2c. 从内存状态删除
                appState.currentChatHistory = appState.currentChatHistory.filter(msg => !idsToDelete.has(msg.id));

                // --- 步骤3: "重生" - 再次调用发送函数 ---
                utils.showToast('正在重新生成回复...');
                await handleSendMessage();

            } catch (error) {
                console.error("重试失败:", error);
                utils.showToast(`重试失败: ${error.message}`);
            }
        }

        
       // vvv 用这个【能解析AI指令】的最终版，完整替换旧的 handleSendMessage 函数 vvv
    async function handleSendMessage() {
        const dossierId = appState.currentChattingDossierId;
        if (!dossierId) return;

        // --- 步骤1: 禁用输入，防止重复操作 ---
        DOM.chatInput.disabled = true;
        DOM.sendBufferBtn.disabled = true;
        DOM.sendFinalBtn.disabled = true;

        const dossier = appState.dossiers.find(d => d.id === dossierId);
        if (!dossier) {
            utils.showToast('错误：找不到角色档案');
            DOM.chatInput.disabled = false;
            DOM.sendBufferBtn.disabled = false;
            DOM.sendFinalBtn.disabled = false;
            return;
        }

        // --- 步骤2: 检查是否有有效的用户操作 ---
        const lastMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
        const isLastMessageFromUser = lastMessage && lastMessage.sender === 'user';
        
        // 如果最后一条消息不是用户发的（比如AI回复后直接点重试），
        // 且不是一个值得发送的事件（比如撤回），则可能是一个异常状态。
        // 但重试逻辑本身会确保历史记录末尾是用户消息，所以我们主要依赖后续的构建逻辑。
        
        // --- 步骤3: 显示“输入中”动画 ---
        const characterName = dossier.character.name;
        const avatarAsset = dossier.character.avatarAssetId ? await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId) : null;
        const avatarUrl = avatarAsset?.file ? URL.createObjectURL(avatarAsset.file) : null;

        const isUserPresent = () => DOM.chatApp.classList.contains('active') && 
                                DOM.chatDialoguePage.classList.contains('active') && 
                                appState.currentChattingDossierId === dossierId;

        let typingIndicator;
        if (isUserPresent()) {
            typingIndicator = document.createElement('div');
            typingIndicator.id = 'typing-indicator';
            typingIndicator.className = 'chat-message character';
            const prevMessageForTyping = appState.currentChatHistory[appState.currentChatHistory.length - 1];
            const showTypingAvatar = !prevMessageForTyping || prevMessageForTyping.sender !== 'character';
            if (showTypingAvatar) {
                const avatarEl = document.createElement('div');
                avatarEl.className = 'avatar';
                if (avatarUrl) avatarEl.style.backgroundImage = `url('${avatarUrl}')`;
                typingIndicator.appendChild(avatarEl);
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'avatar-placeholder';
                typingIndicator.appendChild(placeholder);
            }
            typingIndicator.innerHTML += `<div class="bubble typing-bubble"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>`;
            DOM.messagesContainer.appendChild(typingIndicator);
            utils.autoScrollToBottom();
        }

        try {
            // --- 步骤4: 【核心重构】构建 Prompt 的上下文 ---
            let userTurnMessages = [];
            let historyForPrompt = [];
            let tempHistory = [...appState.currentChatHistory];

            // 从后往前遍历，收集所有连续的用户消息（包括已撤回的）
            while (tempHistory.length > 0) {
                const msg = tempHistory[tempHistory.length - 1];
                if (msg.sender === 'user') {
                    userTurnMessages.unshift(tempHistory.pop());
                } else {
                    break;
                }
            }
            historyForPrompt = tempHistory.filter(msg => msg.sender !== 'system');

            // 从用户这轮的输入中，找到有效的引用信息和纯文本内容
            const quoteData = userTurnMessages.find(m => m.quote)?.quote;
            
           // 【关键】构建 finalUserInputText 时要排除已撤回的消息
const finalUserContentParts = [];
userTurnMessages.forEach(msg => {
    if (msg.status === 'withdrawn') return; // 跳过已撤回的消息

    if (Array.isArray(msg.content)) {
        // 如果是图片/多模态消息，直接把它的内容部分解构后添加进来
        finalUserContentParts.push(...msg.content);
    } else if (msg.type === 'transfer') {
        // 【新增】将转账信息转换为AI可读的文本描述
        const { amount, currency, memo } = msg.content;
        // 注意：这里的文本格式与你在 promptManager 中定义的历史记录格式保持一致，以确保AI能正确理解
        const transferText = `[向你发起了一笔 ${amount} ${currency} 的转账，正在等待你处理。留言：'${memo}']`;
        finalUserContentParts.push({ type: 'text', text: transferText });
    } else if (msg.type === 'horoscope') {
        // 将星座卡片信息“翻译”成AI能理解的文本
        const card = msg.content;
        let stars = '☆'.repeat(5);
        if (card.overall_rating > 0) {
            stars = '★'.repeat(card.overall_rating) + '☆'.repeat(5 - card.overall_rating);
        }
        const horoscopeText = `[你为自己占卜了一张运势卡片：${card.zodiacSign}，综合运势 ${stars}]`;
        finalUserContentParts.push({ type: 'text', text: horoscopeText }); 
     }else if (typeof msg.content === 'string' && msg.content.trim() !== '') {
        // 如果是文本消息，包装成 {type: 'text'} 的格式添加进来
        finalUserContentParts.push({ type: 'text', text: msg.content });
    }
});

// vvv 【核心修正】在这里修改判断逻辑 vvv
        const isLastActionAWithdrawal = userTurnMessages.some(m => m.status === 'withdrawn');
        
        // 只有当真的【没有任何有效输入】（既没文字，也没引用，也没撤回）时...
        if (finalUserContentParts.length === 0 && !quoteData && !isLastActionAWithdrawal) {
            // ...我们才【主动】添加一个空的 text part，告诉AI该你说话了。
            finalUserContentParts.push({ type: 'text', text: '' });
        }

            // 【关键】我们不再使用全局的 appState.quotedMessage
           // 请用下面这行【正确】的代码替换掉它：
const messages = await promptManager.createChatPrompt(dossier, historyForPrompt, finalUserContentParts, quoteData ? { content: quoteData.content, author: quoteData.author, sender: quoteData.sender } : null);
            
            // 【关键】现在可以在这里安全地清除全局引用状态了
            if (appState.quotedMessage) {
                DOM.closeReplyBtn.click();
            }
            
            const aiResponse = await apiHelper.getChatCompletion(messages);
            if (typingIndicator) typingIndicator.remove();

            // --- 【核心改动】将AI回复拆分为“聊天部分”和“动态指令部分” ---

// vvv 【【【 终极修复：健壮的指令解析器 】】】 vvv
            // a. 定义一个变量来存储“干净”的、用于聊天的文本
            let chatContent = aiResponse;
            
            //  **最高优先级：** 检测并处理【HTML模块】指令
            const htmlActionTag = '[AI_HTML_ACTION]';
            const htmlActionIndex = chatContent.indexOf(htmlActionTag);
            if (htmlActionIndex !== -1) {
                const jsonStartIndex = chatContent.indexOf('{', htmlActionIndex);
                const jsonEndIndex = chatContent.lastIndexOf('}');
                
                if (jsonStartIndex !== -1 && jsonEndIndex > jsonStartIndex) {
                    const htmlJsonString = chatContent.substring(jsonStartIndex, jsonEndIndex + 1);
                    chatContent = chatContent.substring(0, htmlActionIndex).trim(); 

                    try {
                        const htmlAction = JSON.parse(htmlJsonString);
                        if (htmlAction.action === 'render_html' && htmlAction.html) {
                            
                            const htmlMessage = {
                                dossierId: dossier.id,
                                sender: 'character',
                                type: 'html_module',
                                content: htmlAction.html,
                                timestamp: Date.now()
                            };

                            const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
                            const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, htmlMessage);
                            htmlMessage.id = savedId;
                            appState.currentChatHistory.push(htmlMessage);
                            
                            if (isUserPresent()) {
                                await renderMessage(htmlMessage, prevMessage);
                            }
                            
                            await updateChatSession(dossierId, '[HTML模块消息]');
                        }
                    } catch (e) {
                        console.error("解析HTML模块指令失败:", e);
                    }
                }
            }
    
            // b. **第一优先级：** 检测并处理【来电】指令
            const callActionTag = '[AI_CALL_ACTION]';
            const callActionIndex = chatContent.indexOf(callActionTag);
          if (callActionIndex !== -1) {
                const jsonStartIndex = chatContent.indexOf('{', callActionIndex);
                const jsonEndIndex = chatContent.lastIndexOf('}');
                
                if (jsonStartIndex !== -1 && jsonEndIndex > jsonStartIndex) {
                    const callJsonString = chatContent.substring(jsonStartIndex, jsonEndIndex + 1);
                    chatContent = chatContent.substring(0, callActionIndex).trim();

                    try {
                        const callAction = JSON.parse(callJsonString);
                        // 【核心升级】检查 openingScene 而不是 openingLine
                        if (callAction.action === 'initiate_video_call' && Array.isArray(callAction.openingScene)) {
                            const delay = (callAction.delayInSeconds || 30) * 1000;
                            const executeAt = Date.now() + delay;
                            const newCallAction = {
                                dossierId: dossier.id,
                                type: 'video_call_initiate',
                                // 【核心升级】payload 现在直接就是 openingScene 数组
                                payload: callAction.openingScene, 
                                executeAt: executeAt,
                                status: 'pending'
                            };
                            await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newCallAction);
                            console.log(`[AI行为引擎] ${dossier.character.name} 已决定在 ${delay/1000} 秒后发起视频通话。`);
                        }
                    } catch (e) {
                        console.error("解析视频通话指令失败:", e, "原始JSON字符串:", callJsonString);
                    }
                }
            }
    // **新增优先级：** 检测并处理【语音】指令
                       const voiceActionTag = '[AI_VOICE_ACTION]';
            const voiceActionIndex = chatContent.indexOf(voiceActionTag);
            if (voiceActionIndex !== -1) {
                const jsonStartIndex = chatContent.indexOf('{', voiceActionIndex);
                const jsonEndIndex = chatContent.lastIndexOf('}');
                
                if (jsonStartIndex !== -1 && jsonEndIndex > jsonStartIndex) {
                    const voiceJsonString = chatContent.substring(jsonStartIndex, jsonEndIndex + 1);
                    // 【核心修正】只剥离指令，把剩下的文本留在 chatContent 中
                    chatContent = chatContent.substring(0, voiceActionIndex).trim(); 

                    try {
                        const voiceAction = JSON.parse(voiceJsonString);
                        if (voiceAction.action === 'send_voice_message' && voiceAction.content) {
                            
                            // 1. 处理语音消息本身
                            const duration = Math.max(1, Math.ceil(voiceAction.content.length / 3));
                            const voiceMessage = {
                                dossierId: dossier.id, sender: 'character', type: 'voice',
                                content: voiceAction.content, metadata: { duration }, timestamp: Date.now()
                            };
                            const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
                            const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, voiceMessage);
                            voiceMessage.id = savedId;
                            appState.currentChatHistory.push(voiceMessage);
                            
                            if (isUserPresent()) {
                                await renderMessage(voiceMessage, prevMessage);
                            }
                            
                            // 2. 更新会话列表
                            await updateChatSession(dossierId, '[语音消息]');
                        }
                    } catch (e) {
                        console.error("解析语音消息指令失败:", e);
                        // 如果解析失败，把剥离掉的文本内容还回去，以防万一
                        chatContent += ` ${voiceActionTag}${voiceJsonString}`;
                    }
                }
            }

// **新增优先级：** 检测并处理【转账】指令
            const transferActionTag = '[AI_TRANSFER_ACTION]';
            const transferActionIndex = chatContent.indexOf(transferActionTag);
            if (transferActionIndex !== -1) {
                const jsonStartIndex = chatContent.indexOf('{', transferActionIndex);
                const jsonEndIndex = chatContent.lastIndexOf('}');
                
                if (jsonStartIndex !== -1 && jsonEndIndex > jsonStartIndex) {
                    const transferJsonString = chatContent.substring(jsonStartIndex, jsonEndIndex + 1);
                    chatContent = chatContent.substring(0, transferActionIndex).trim();

                    try {
                        const transferAction = JSON.parse(transferJsonString);
                        if (transferAction.action === 'send_transfer' && transferAction.amount) {
                            
                            const transferMessage = {
                                dossierId: dossier.id,
                                sender: 'character',
                                type: 'transfer', // <-- 新类型！
                                content: {
                                    amount: transferAction.amount,
                                    currency: transferAction.currency || '信用点',
                                    memo: transferAction.memo || '转账'
                                },
                                metadata: {
                                    status: 'pending' // 初始状态为待接收
                                },
                                timestamp: Date.now()
                            };

                            const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
                            const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, transferMessage);
                            transferMessage.id = savedId;
                            appState.currentChatHistory.push(transferMessage);
                            
                            if (isUserPresent()) {
                                await renderMessage(transferMessage, prevMessage);
                            }
                            
                            await updateChatSession(dossierId, `[转账] ${transferAction.amount} ${transferAction.currency || '信用点'}`);
                        }
                    } catch (e) {
                        console.error("解析转账指令失败:", e);
                    }
                }
            }
// **新增优先级：** 检测并处理【回应转账】指令
            const transferResponseTag = '[AI_TRANSFER_RESPONSE_ACTION]';
            const transferResponseIndex = chatContent.indexOf(transferResponseTag);
            if (transferResponseIndex !== -1) {
                const jsonStartIndex = chatContent.indexOf('{', transferResponseIndex);
                const jsonEndIndex = chatContent.lastIndexOf('}');
                
                if (jsonStartIndex !== -1 && jsonEndIndex > jsonStartIndex) {
                    const responseJsonString = chatContent.substring(jsonStartIndex, jsonEndIndex + 1);
                    chatContent = chatContent.substring(0, transferResponseIndex).trim();

                    try {
                        const responseAction = JSON.parse(responseJsonString);
                        
                        // 【关键】智能地找到AI想要回应的那条用户转账消息
                        const userTransferMessage = [...appState.currentChatHistory].reverse().find(m => m.type === 'transfer' && m.sender === 'user' && m.metadata?.status === 'pending');
                        
                        if (responseAction.action === 'respond_to_transfer' && userTransferMessage) {
                            const delay = (responseAction.delayInSeconds || 10) * 1000;
                            const executeAt = Date.now() + delay;

                            const newResponseAction = {
                                dossierId: dossier.id,
                                type: 'transfer_response', // 新的任务类型
                                payload: {
                                    targetMessageId: userTransferMessage.id, // 我们帮AI找到了ID
                                    decision: responseAction.decision // 'accept' or 'decline'
                                },
                                executeAt: executeAt,
                                status: 'pending'
                            };

                            await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newResponseAction);
                            console.log(`[AI行为引擎] ${dossier.character.name} 已决定在 ${delay/1000} 秒后回应转账。`);
                        }
                    } catch (e) {
                        console.error("解析回应转账指令失败:", e);
                    }
                }
            }

           // c. **第二优先级：** 在【可能已被净化】的 chatContent 上检测并处理【动态】指令
const momentActionTag = '[AI_MOMENT_ACTION]';
let momentMatch = null;
const momentActionIndex = chatContent.indexOf(momentActionTag);
if (momentActionIndex !== -1) {
    const jsonStartIndex = chatContent.indexOf('{', momentActionIndex);
    // 【核心修正】智能寻找 JSON 的结束位置，这里我们假设指令总在末尾，所以用 lastIndexOf
    const jsonEndIndex = chatContent.lastIndexOf('}');
    
    if (jsonStartIndex > -1 && jsonEndIndex > jsonStartIndex) {
        // 只提取从 '{' 到 '}' 的纯净JSON字符串
        const momentJsonString = chatContent.substring(jsonStartIndex, jsonEndIndex + 1);
        momentMatch = [null, momentJsonString]; // 将纯净的JSON存起来
        
        // 从 chatContent 中彻底剥离掉整个指令，为后续解析做准备
        chatContent = chatContent.substring(0, momentActionIndex).trim();
    }
}
            
            // d. **第三优先级：** 在【最终净化】的 chatContent 上检测并处理【撤回/引用】指令
            const actionRegex = /\[AI_ACTION\]([\s\S]*?)\[\/AI_ACTION\]/s;
            let match = chatContent.match(actionRegex); // 【关键修正】在这里声明 match

            if (match) {
                // 情况1：AI 发送了一个特殊指令
                const actionJson = JSON.parse(match[1]);
                
                if (actionJson.action === 'withdraw') {
    // --- 【最终版】处理“实时撤回”指令 (包含动画和引用解析) ---
    const { originalMessage, reason, newMessage } = actionJson;

    // 1. 【模拟发送】: 先把那条“错误”的消息显示出来
    const tempId = `temp_${Date.now()}`;
    const mistakeMessage = { id: tempId, dossierId, sender: 'character', content: originalMessage, timestamp: Date.now() };
    const lastMessageBeforeMistake = appState.currentChatHistory[appState.currentChatHistory.length - 1];
    const mistakeMessageEl = await createMessageElement(mistakeMessage, lastMessageBeforeMistake);
    DOM.messagesContainer.appendChild(mistakeMessageEl);
    utils.autoScrollToBottom();

    // 2. 【等待】: 模拟反应时间
    const realisticDelay = Math.random() * 700 + 800;
    await new Promise(resolve => setTimeout(resolve, realisticDelay));

    // 3. 【执行撤回动画】
    if (mistakeMessageEl) {
        mistakeMessageEl.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
        mistakeMessageEl.style.opacity = '0';
        mistakeMessageEl.style.transform = 'scale(0.8)';
        await new Promise(resolve => setTimeout(() => { mistakeMessageEl.remove(); resolve(); }, 300));
    }

    // 4. 【保存真实记录】
    const withdrawnMessage = { dossierId, sender: 'character', content: originalMessage, status: 'withdrawn', innerThought: reason, timestamp: Date.now() };
    const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, withdrawnMessage);
    withdrawnMessage.id = savedId;
    appState.currentChatHistory.push(withdrawnMessage);
    
    // 5. 【渲染撤回提示】
    const lastMessageBeforeNotice = appState.currentChatHistory[appState.currentChatHistory.length - 2];
    await renderMessage(withdrawnMessage, lastMessageBeforeNotice);

    // 6. 【发送新消息，并智能解析引用】
    if (newMessage) {
        await new Promise(resolve => setTimeout(resolve, 400)); // 为新消息增加延迟
        
        const newContent = newMessage;
        const isNewMessageAQuote = newContent.startsWith('> ') && newContent.includes('\n');
        const allNewMessages = []; // 存储所有新创建的消息对象

        if (isNewMessageAQuote) {
            // 情况A: 新消息本身是一个引用回复（来自您的旧代码逻辑）
            const replyLines = newContent.split('\n').filter(line => line.trim() !== '');
            if (replyLines.length > 1) {
                const firstMessageContent = `${replyLines[0]}\n${replyLines[1]}`;
                const firstAiMessage = { dossierId, sender: 'character', content: firstMessageContent, timestamp: Date.now() };
                const firstId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, firstAiMessage);
                firstAiMessage.id = firstId;
                appState.currentChatHistory.push(firstAiMessage);
                allNewMessages.push(firstAiMessage);

                for (let i = 2; i < replyLines.length; i++) {
                    const subsequentAiMessage = { dossierId, sender: 'character', content: replyLines[i], timestamp: Date.now() };
                    const subsequentId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, subsequentAiMessage);
                    subsequentAiMessage.id = subsequentId;
                    appState.currentChatHistory.push(subsequentAiMessage);
                    allNewMessages.push(subsequentAiMessage);
                }
            }
        } else {
            // 情况B: 新消息是普通的、不含引用的多行回复
            const newMessages = newContent.split('\n').filter(line => line.trim() !== '');
            for (const reply of newMessages) {
                const newAiMessage = { dossierId, sender: 'character', content: reply, timestamp: Date.now() };
                const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, newAiMessage);
                newAiMessage.id = savedId;
                appState.currentChatHistory.push(newAiMessage);
                allNewMessages.push(newAiMessage);
            }
        }

        // --- 统一的渲染和更新逻辑 ---
        if (allNewMessages.length > 0) {
            await updateChatSession(dossierId, allNewMessages[allNewMessages.length - 1].content);
            if (isUserPresent()) {
                let lastMessageForAvatarCheck = withdrawnMessage; // 新消息的前一条是“撤回提示”
                for (const msg of allNewMessages) {
                    await renderMessage(msg, lastMessageForAvatarCheck);
                    lastMessageForAvatarCheck = msg;
                    if (allNewMessages.length > 1) await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
        }
    }
              } else if (actionJson.action === 'quote') {
                // --- 【核心修正】处理“引用”指令，并支持多气泡回复 ---
                const replyLines = actionJson.replyText.split('\n').filter(line => line.trim() !== '');
                if (replyLines.length === 0) return; // AI返回了空的回复

                const newMessages = []; // 创建一个临时数组来存放所有新消息

                // 1. 创建第一条特殊消息，它包含引用和回复的第一行
                const firstMessageContent = `> ${actionJson.quoteText}\n${replyLines[0]}`;
                const firstAiMessage = { dossierId, sender: 'character', content: firstMessageContent, timestamp: Date.now() };
                const firstId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, firstAiMessage);
                firstAiMessage.id = firstId;
                appState.currentChatHistory.push(firstAiMessage);
                newMessages.push(firstAiMessage);

                // 2. 如果有多行回复，为后续的每一行创建常规消息
                for (let i = 1; i < replyLines.length; i++) {
                    const subsequentAiMessage = { dossierId, sender: 'character', content: replyLines[i], timestamp: Date.now() };
                    const subsequentId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, subsequentAiMessage);
                    subsequentAiMessage.id = subsequentId;
                    appState.currentChatHistory.push(subsequentAiMessage);
                    newMessages.push(subsequentAiMessage);
                }

                // 3. 更新会话列表，使用最后一条消息内容
                await updateChatSession(dossierId, replyLines[replyLines.length - 1]);

                // 4. 统一渲染所有新创建的消息
                if (isUserPresent()) {
                    let lastMessageForAvatarCheck = appState.currentChatHistory[appState.currentChatHistory.length - 1 - newMessages.length];
                    for (const msg of newMessages) {
                        await renderMessage(msg, lastMessageForAvatarCheck);
                        lastMessageForAvatarCheck = msg;
                        // 加一个小延迟，让多条消息看起来更自然
                        if (newMessages.length > 1) await new Promise(resolve => setTimeout(resolve, 300));
                    }
                }
            }

         } else if (chatContent) {
                // 情况2：AI 发送的是普通聊天消息
              const replies = chatContent.trim().split('|||').filter(line => line.trim() !== '');
                if (replies.length === 0) throw new Error("AI 返回了空内容。");

                for (const reply of replies) {
                    const aiMessage = { dossierId, sender: 'character', content: reply, timestamp: Date.now() };
                    const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, aiMessage);
                    aiMessage.id = savedId;
                    appState.currentChatHistory.push(aiMessage);
                }
                await updateChatSession(dossierId, replies[replies.length - 1]);
            
                if (isUserPresent()) {
                    let lastMessageForAvatarCheck = appState.currentChatHistory[appState.currentChatHistory.length - 1 - replies.length];
                    for (let i = 0; i < replies.length; i++) {
                        const currentMessage = appState.currentChatHistory[appState.currentChatHistory.length - replies.length + i];
                        await renderMessage(currentMessage, lastMessageForAvatarCheck);
                        lastMessageForAvatarCheck = currentMessage;
                        if (i < replies.length - 1) await new Promise(resolve => setTimeout(resolve, 500));
                    }
                } else {
                    notificationManager.show({ avatarUrl, title: characterName, message: replies[0], onClick: () => openChatWindow(dossierId) });
                }
            }
// --- 【全新】处理动态指令部分 (如果存在) ---
if (momentMatch) {
    try {
        const momentActionJson = JSON.parse(momentMatch[1]);
        if (momentActionJson.action === 'post_moment') {
            const { type, content, imageDescription } = momentActionJson;
            
            // --- 【核心修正】增加无效指令的保险锁 ---
            if (!content && !imageDescription) {
                // 如果 AI 犯傻，返回了完全空的内容，我们就在这里拦截它
                console.warn("收到了一个完全空白的动态指令，已忽略。");
                return; // 提前退出，不执行后续操作
            }
            
            let finalContent = content || '';
            
            // 处理图片魔法
            if (imageDescription && CONSTANTS.MOMENT_IMAGE_POOL[type] && CONSTANTS.MOMENT_IMAGE_POOL[type].length > 0) {
                const pool = CONSTANTS.MOMENT_IMAGE_POOL[type];
                const randomIndex = Math.floor(Math.random() * pool.length);
                const randomImageUrl = pool[randomIndex];
                finalContent += ` [IMG_DESC:${imageDescription}][IMG_URL:${randomImageUrl}]`;
            } else if (!imageDescription && type === 'story' && CONSTANTS.STORY_BACKGROUND_COLORS.length > 0) {
                // 处理纯文字快拍的背景色
                const colors = CONSTANTS.STORY_BACKGROUND_COLORS;
                const randomIndex = Math.floor(Math.random() * colors.length);
                const randomBgColor = colors[randomIndex];
                finalContent += ` [BG_COLOR:${randomBgColor}]`;
            }
            
           const newMoment = {
                dossierId: dossier.id,
                // vvv 【核心修正】在这里添加 authorType 标识 vvv
                authorType: 'character', 
                // ^^^ 修正结束 ^^^
                type, 
                content: finalContent, 
                assetId: null, 
                timestamp: Date.now(),
            };

            if (type === 'story') {
                newMoment.expiresAt = newMoment.timestamp + (24 * 60 * 60 * 1000);
            }

            await dbHelper.add(CONSTANTS.STORE_NAMES.MOMENTS, newMoment);
            
            // 准备并显示横幅提醒
            const notificationTitle = `${dossier.character.name} 发布了一条新动态`;
            const notificationMessage = content || (imageDescription ? `发布了一张照片：${imageDescription}` : (type === 'story' ? '发布了一条快拍' : '更新了状态'));

            notificationManager.show({
                avatarUrl, title: notificationTitle, message: notificationMessage,
                onClick: () => {}
            });
        }
    } catch (e) {
        console.error("解析或处理动态指令失败:", e);
    }
}

        } catch (error) {
            console.error("发送消息失败:", error);
            if (typingIndicator) typingIndicator.remove();
            if (isUserPresent()) {
                await renderMessage({ content: `[错误] 无法获取回复: ${error.message}`, sender: 'system' });
            } else {
                utils.showToast(`获取 ${characterName} 的回复失败`);
            }
        } finally {
            DOM.chatInput.disabled = false;
            DOM.sendBufferBtn.disabled = false;
            DOM.sendFinalBtn.disabled = false;
        }
    }

// ====== 新增：图书馆应用核心函数 ======// 
async function renderLibraryList() {
    const books = await dbHelper.getAll(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS);
    DOM.libraryListContainer.innerHTML = '';

    if (books.length === 0) {
        DOM.libraryListContainer.innerHTML = '<p style="text-align:center; opacity:0.7;">图书馆是空的，点击右上角“+”创建你的第一本书吧。</p>';
        return;
    }
    
    books.sort((a, b) => {
        // 规则1: 如果全局状态不同，全局的排前面
        if (a.isGlobal !== b.isGlobal) {
            return b.isGlobal - a.isGlobal;
        }
        // 规则2: 如果全局状态相同，则按ID倒序排（ID大的、即最新的排前面）
        return b.id - a.id;
    });

    for (const book of books) {
        const card = document.createElement('div');
        card.className = 'settings-item';
        card.dataset.bookId = book.id;

        let indicatorIcon = '';
        let indicatorText = '专属';
        
        if (book.isGlobal) {
            indicatorIcon = '<i class="ri-earth-fill" style="color: #FFD700;"></i>';
            indicatorText = '全局';
        }
        
        // 【核心改动】获取并翻译分类名称
        const categoryName = CONSTANTS.BOOK_CATEGORIES[book.category] || book.category;

        // 【核心改动】在 innerHTML 中，增加显示分类的 span 元素
        card.innerHTML = `
            ${indicatorIcon}
            <span>${book.title}</span>
            <span style="opacity: 0.6; font-size: 14px; margin-left: auto;">${indicatorText}</span>
            <span style="opacity: 0.5; font-size: 13px; margin-left: 10px;">${categoryName}</span>
        `;
        DOM.libraryListContainer.appendChild(card);
    }
}

async function openBookEditModal(bookId) {
    const book = await dbHelper.get(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS, bookId);
    if (!book) return utils.showToast('找不到这本书！');

    appState.currentEditingBookId = bookId;
    
    DOM.editBookTitle.value = book.title;
    DOM.editBookIsGlobal.checked = book.isGlobal;
    DOM.editBookCategory.value = book.category;
    DOM.editBookContent.value = book.content;

    DOM.bookEditModal.classList.add('visible');
}

function resetCreationForm_Library() {
    DOM.createBookTitle.value = '';
    DOM.createBookIsGlobal.checked = false;
    DOM.createBookCategory.value = 'behavior_core';
    DOM.createBookContent.value = '';
}
// ^^^ 新函数到此结束 ^^^

// vvv 在这里【新增】“书籍链接”相关的核心函数 vvv
function updateLinkedBooksDisplay(dossier) {
    if (!dossier) return;
    const count = dossier.libraryBookIds?.length || 0;
    if (count > 0) {
        DOM.linkedBooksCount.textContent = `已链接 ${count} 本`;
    } else {
        DOM.linkedBooksCount.textContent = '未设置';
    }
}

async function openBookLinkModal() {
    const dossierId = appState.currentChattingDossierId;
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return utils.showToast('无法加载角色信息');

    const allBooks = await dbHelper.getAll(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS);
    const exclusiveBooks = allBooks.filter(book => !book.isGlobal);
    const linkedBookIds = new Set(dossier.libraryBookIds || []);

    DOM.bookLinkList.innerHTML = '';
    if (exclusiveBooks.length === 0) {
        DOM.bookLinkList.innerHTML = '<li style="text-align:center; opacity:0.7; padding: 20px;">图书馆里还没有“专属”类型的书。</li>';
    } else {
        exclusiveBooks.forEach(book => {
            const isChecked = linkedBookIds.has(book.id);
            const li = document.createElement('li');
            li.innerHTML = `
                <label class="settings-item" style="cursor: pointer;">
                    <input type="checkbox" data-book-id="${book.id}" ${isChecked ? 'checked' : ''} style="transform: scale(1.5); margin-right: 5px; cursor: pointer;">
                    <span>${book.title}</span>
                    <span style="opacity: 0.5; font-size: 13px; margin-left: auto;">${CONSTANTS.BOOK_CATEGORIES[book.category] || book.category}</span>
                </label>
            `;
            DOM.bookLinkList.appendChild(li);
        });
    }
    DOM.bookLinkModal.classList.add('visible');
}

// vvv 【V3.0 最终版】用这个全新的函数，完整替换旧的 renderMoments vvv

async function renderMoments() {
    // (这部分初始化逻辑保持不变)
    appState.userLikedMomentIds = await dbHelper.getUserLikes();
    const now = Date.now();
    const allMoments = await dbHelper.getAll(CONSTANTS.STORE_NAMES.MOMENTS);
    const allDossiers = appState.dossiers;
    const allComments = await dbHelper.getAll(CONSTANTS.STORE_NAMES.COMMENTS);
    const commentCounts = allComments.reduce((acc, comment) => {
        acc[comment.momentId] = (acc[comment.momentId] || 0) + 1;
        return acc;
    }, {});

    // --- 模块 A: 渲染顶部的“快拍”头像列表 (这部分逻辑不变) ---
    const storiesContainer = document.querySelector('.stories-container');
    if (!storiesContainer) return;
    storiesContainer.innerHTML = ''; 
    const userStoryPlaceholder = document.createElement('div');
    userStoryPlaceholder.id = 'user-story-placeholder';
    const userAvatarDiv = document.createElement('div');
    userAvatarDiv.className = 'story-avatar';
    const userNameSpan = document.createElement('span');
    userNameSpan.textContent = '我';
    const globalAvatarSetting = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'global_user_avatar_asset_id');
    const globalAvatarId = globalAvatarSetting?.value;
    if (globalAvatarId) {
        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, globalAvatarId);
        if (asset?.file) {
            userAvatarDiv.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
            userAvatarDiv.innerHTML = '';
        }
    } else {
         userAvatarDiv.innerHTML = '<i class="ri-add-line"></i>';
    }
    const userActiveStories = allMoments.filter(m =>
        m.authorType === 'user' && m.type === 'story' && m.expiresAt > now
    );
    if (userActiveStories.length > 0) {
        userStoryPlaceholder.className = 'story-item has-unread';
        userStoryPlaceholder.addEventListener('click', () => openStoryViewerForUser());
    } else {
        userStoryPlaceholder.className = 'story-item placeholder no-story';
    }
    userStoryPlaceholder.append(userAvatarDiv, userNameSpan);
    storiesContainer.appendChild(userStoryPlaceholder);
    const activeStoriesByDossier = allMoments
        .filter(moment => moment.type === 'story' && moment.expiresAt > now && moment.authorType !== 'user')
        .reduce((acc, story) => {
            if (!acc[story.dossierId]) acc[story.dossierId] = [];
            acc[story.dossierId].push(story);
            return acc;
        }, {});
    for (const dossier of allDossiers) {
        const storyItem = document.createElement('div');
        storyItem.dataset.dossierId = dossier.id;
        const avatarDiv = document.createElement('div');
        avatarDiv.className = 'story-avatar';
        if (dossier.character.avatarAssetId) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
            if (asset?.file) avatarDiv.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
        }
        const nameSpan = document.createElement('span');
        nameSpan.textContent = dossier.character.name;
        if (activeStoriesByDossier[dossier.id]) {
            storyItem.className = 'story-item has-unread';
            storyItem.addEventListener('click', () => openStoryViewer(dossier.id));
        } else {
            storyItem.className = 'story-item no-story';
        }
        storyItem.append(avatarDiv, nameSpan);
        storiesContainer.appendChild(storyItem);
    }

    // --- 模块 B: 渲染下方的“日常”信息流 (这是我们修改的核心) ---
    const postsContainer = document.getElementById('posts-container');
    if (!postsContainer) return;
    const allPosts = allMoments.filter(moment => moment.type === 'post').sort((a, b) => b.timestamp - a.timestamp);
    if (allPosts.length === 0) {
        postsContainer.innerHTML = `<p style="text-align:center; opacity:0.7; padding: 50px 20px;">还没有任何动态，点击右上角“+”发布你的第一条动态吧。</p>`;
        return;
    }
    postsContainer.innerHTML = '';
    for (const post of allPosts) {
        let authorName, authorAvatarAssetId, postDossierIdForActions;
        let avatarUrl = '';
        if (post.authorType === 'user') {
            authorName = '我';
            authorAvatarAssetId = globalAvatarId;
            postDossierIdForActions = 'user_post';
        } else {
            const dossier = allDossiers.find(d => d.id === post.dossierId);
            if (!dossier) continue;
            authorName = dossier.character.name;
            authorAvatarAssetId = dossier.character.avatarAssetId;
            postDossierIdForActions = dossier.id;
        }
        if (authorAvatarAssetId) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, authorAvatarAssetId);
            if (asset?.file) avatarUrl = URL.createObjectURL(asset.file);
        }
        const avatarStyle = avatarUrl ? `style="background-image: url('${avatarUrl}')"` : '';
        const isLiked = appState.userLikedMomentIds.has(post.id);
        const postCard = document.createElement('div');
        postCard.className = 'post-card';
        let textContentHTML = '';
        let imageHTML = '';
        let captionHTML = ''; 
        const imgRegex = / \[IMG_DESC:(.*?)\]\[IMG_URL:(.*?)\]$/s;
        const imgMatch = post.content.match(imgRegex);
        if (imgMatch) {
            const imageDescription = imgMatch[1];
            const imageUrl = imgMatch[2];
            const mainContent = post.content.replace(imgRegex, '').trim();
            if (mainContent) {
                textContentHTML = `<p>${mainContent}</p>`;
            }
            imageHTML = `<div class="post-image" style="background-image: url('${imageUrl}')"></div>`;
            if (imageDescription) {
                captionHTML = `<p class="post-image-caption">${imageDescription}</p>`;
            }
        } else if (post.assetId) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, post.assetId);
            if (asset?.file) {
                imageHTML = `<div class="post-image" style="background-image: url('${URL.createObjectURL(asset.file)}')"></div>`;
            }
            if (post.content) {
                textContentHTML = `<p>${post.content}</p>`;
            }
        } else {
            textContentHTML = post.content ? `<p>${post.content}</p>` : '';
        }
        const commentCount = commentCounts[post.id] || 0;

        // vvv 【核心修正】在 post-header 中添加了删除按钮 <i> 标签 vvv
        postCard.innerHTML = `
            <div class="post-header">
                <div class="post-author-group">
                    <div class="post-avatar" ${avatarStyle}></div>
                    <div class="post-author-info">
                        <span class="post-author-name">${authorName}</span>
                        <span class="post-timestamp">${formatRelativeTime(post.timestamp)}</span>
                    </div>
                </div>
                <i class="delete-moment-btn ri-delete-bin-line" data-moment-id="${post.id}"></i>
            </div>
            <div class="post-content">
                ${textContentHTML}
                ${imageHTML}
                ${captionHTML} 
            </div>
            <div class="post-actions">
                <div class="action-item">
                    <i class="like-btn ${isLiked ? 'liked ri-heart-fill' : 'ri-heart-line'}" data-moment-id="${post.id}" data-dossier-id="${postDossierIdForActions}"></i>
                </div>
                <div class="action-item">
                    <i class="comment-btn ri-chat-3-line" data-moment-id="${post.id}" data-dossier-id="${postDossierIdForActions}"></i>
                    ${commentCount > 0 ? `<span class="action-count">${commentCount}</span>` : ''}
                </div>
            </div>
            <div class="post-comments-container"></div>
        `;
        // ^^^ 修正结束 ^^^

        postsContainer.appendChild(postCard);
        renderCommentsForPost(post.id, postCard.querySelector('.post-comments-container'));
    }
}

// =======================================================
// ============ 新增：“快拍查看器”核心函数 ==============
// =======================================================

function closeStoryViewer() {
    clearTimeout(appState.storyTimerId);
    DOM.storyViewerOverlay.classList.remove('visible');
    
    // 【新增】重置输入框和按钮状态
    DOM.storyCommentInput.value = '';
    DOM.storyViewerFooter.classList.remove('input-active');

    // 重置状态
    appState.currentViewingStories = [];
    appState.currentStoryIndex = 0;
    appState.storyTimerId = null;
}

/**
 * 【全新】恢复快拍的计时器和进度条动画
 */
function resumeStoryPlayback() {
    // 检查是否真的处于暂停状态，防止重复执行
    if (!appState.storyTimeRemaining) return;

    const fill = DOM.storyProgressBars.querySelector('.active .progress-bar-fill');
    if (fill) {
        // 1. 恢复CSS动画：让过渡动画在剩下的时间内跑完
        fill.style.transition = `width ${appState.storyTimeRemaining / 1000}s linear`;
        fill.style.width = '100%';
    }

    // 2. 恢复JS计时器：用剩下的时间设置一个新的定时器
    appState.storyTimerId = setTimeout(nextStory, appState.storyTimeRemaining);

    // 3. 重置暂停状态
    appState.storyPauseTimestamp = null;
    appState.storyTimeRemaining = null;
    appState.storyStartTime = Date.now(); // 重置开始时间，以防再次暂停
}

// vvv 【V3 最终修复版】用这个修复了内容解析逻辑的版本，替换旧的 renderCurrentStory vvv
async function renderCurrentStory() {
    if (appState.currentViewingStories.length === 0) { closeStoryViewer(); return; }
    clearTimeout(appState.storyTimerId);
    // 记录下这个快拍的精确开始播放时间
    appState.storyStartTime = Date.now(); 

    const story = appState.currentViewingStories[appState.currentStoryIndex];
    let authorName = '', authorAvatarUrl = '', dossierIdForActions = story.dossierId;

    if (story.authorType === 'user') {
        authorName = '我';
        const globalAvatarSetting = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'global_user_avatar_asset_id');
        if (globalAvatarSetting?.value) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, globalAvatarSetting.value);
            if (asset?.file) authorAvatarUrl = URL.createObjectURL(asset.file);
        }
        dossierIdForActions = 'user_story';
    } else {
        const dossier = appState.dossiers.find(d => d.id === story.dossierId);
        if (!dossier) { closeStoryViewer(); return; }
        authorName = dossier.character.name;
        if (dossier.character.avatarAssetId) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
            if (asset?.file) authorAvatarUrl = URL.createObjectURL(asset.file);
        }
    }

    DOM.storyAuthorName.textContent = authorName;
    DOM.storyTimestamp.textContent = formatRelativeTime(story.timestamp);
    DOM.storyAuthorAvatar.style.backgroundImage = authorAvatarUrl ? `url(${authorAvatarUrl})` : 'none';

    DOM.storyProgressBars.innerHTML = '';
    appState.currentViewingStories.forEach((_, index) => {
        const segment = document.createElement('div');
        segment.className = 'progress-bar-segment';
        segment.innerHTML = `<div class="progress-bar-fill" style="width: ${index < appState.currentStoryIndex ? '100%' : '0%'}"></div>`;
        if (index === appState.currentStoryIndex) segment.classList.add('active');
        DOM.storyProgressBars.appendChild(segment);
    });
    
    const likeBtn = DOM.storyViewerFooter.querySelector('.like-btn');
    if (likeBtn) {
        const isLiked = appState.userLikedMomentIds.has(story.id);
        likeBtn.className = `like-btn ${isLiked ? 'liked ri-heart-fill' : 'ri-heart-line'}`;
        likeBtn.dataset.momentId = story.id;
        likeBtn.dataset.dossierId = dossierIdForActions;
    }

    // --- 【核心修复】重写内容解析逻辑，确保兼容所有情况 ---
    DOM.storyContentArea.style.backgroundImage = 'none';
    DOM.storyContentArea.style.backgroundColor = '#1C1C1E';
    DOM.storyTextContent.style.display = 'none';
    DOM.storyTextContent.innerHTML = '';

    const rawContent = story.content;
    const imgRegex = / \[IMG_DESC:(.*?)\]\[IMG_URL:(.*?)\]$/s;
    const bgRegex = / \[BG_COLOR:(.*?)\]$/s;
    const imgMatch = rawContent.match(imgRegex);
    const bgMatch = rawContent.match(bgRegex);

    if (story.assetId) { // 优先处理用户上传的图片 (来自第一阶段)
        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, story.assetId);
        if (asset?.file) {
             DOM.storyContentArea.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
        }
        if (rawContent) {
            DOM.storyTextContent.textContent = rawContent;
            DOM.storyTextContent.style.display = 'block';
        }
    } else if (imgMatch) { // AI生成的带图快拍
        const description = imgMatch[1];
        const imageUrl = imgMatch[2];
        const mainContent = rawContent.replace(imgRegex, '').trim();
        DOM.storyContentArea.style.backgroundImage = `url('${imageUrl}')`;
        let displayText = description ? `<span style="font-style: italic; opacity: 0.8;">${description}</span>` : '';
        if (mainContent) displayText += `${displayText ? '<br><br>' : ''}${mainContent}`;
        if (displayText) {
            DOM.storyTextContent.innerHTML = displayText;
            DOM.storyTextContent.style.display = 'block';
        }
    } else if (bgMatch) { // AI生成的纯色背景快拍
        const color = bgMatch[1];
        const textContent = rawContent.replace(bgRegex, '').trim();
        DOM.storyContentArea.style.backgroundColor = color;
        DOM.storyTextContent.textContent = textContent;
        DOM.storyTextContent.style.display = 'block';
    } else { // 降级处理：任何其他纯文本快拍
        DOM.storyTextContent.textContent = rawContent;
        DOM.storyTextContent.style.display = 'block';
    }
    // --- 修复结束 ---

    await renderCommentsForStory();

    // 使用 setTimeout 确保浏览器已经渲染了DOM，然后再启动动画
    setTimeout(() => {
        const fill = DOM.storyProgressBars.querySelector('.active .progress-bar-fill');
        if (fill) {
            // 【重要】每次都重置为完整的10秒动画
            fill.style.transition = 'width 10s linear';
            fill.style.width = '100%';
        }
    }, 50);
    // 设置10秒后自动播放下一个的定时器
    appState.storyTimerId = setTimeout(nextStory, 10000);
}

function nextStory() {
    if (appState.currentStoryIndex < appState.currentViewingStories.length - 1) {
        appState.currentStoryIndex++;
        renderCurrentStory();
    } else {
        closeStoryViewer();
    }
}

function prevStory() {
    if (appState.currentStoryIndex > 0) {
        appState.currentStoryIndex--;
        renderCurrentStory();
    }
}

async function openStoryViewer(dossierId) {
    const now = Date.now();
    const allStoriesForDossier = (await dbHelper.getAll(CONSTANTS.STORE_NAMES.MOMENTS))
        .filter(m => m.dossierId === dossierId && m.type === 'story' && m.expiresAt > now)
        .sort((a, b) => a.timestamp - b.timestamp); // 按时间正序播放

    if (allStoriesForDossier.length === 0) {
        utils.showToast('没有可查看的快拍');
        return;
    }

    appState.currentViewingStories = allStoriesForDossier;
    appState.currentStoryIndex = 0;
    
    DOM.storyViewerOverlay.classList.add('visible');
    renderCurrentStory();
}

/**
 * 【全新】打开快拍查看器，用于查看用户自己的快拍
 */
async function openStoryViewerForUser() {
    const now = Date.now();
    const allUserStories = (await dbHelper.getAll(CONSTANTS.STORE_NAMES.MOMENTS))
        .filter(m => m.authorType === 'user' && m.type === 'story' && m.expiresAt > now)
        .sort((a, b) => a.timestamp - b.timestamp);

    if (allUserStories.length === 0) {
        utils.showToast('没有可查看的快拍');
        return;
    }

    appState.currentViewingStories = allUserStories;
    appState.currentStoryIndex = 0;
    
    DOM.storyViewerOverlay.classList.add('visible');
    renderCurrentStory();
}

// =======================================================
// ============ 新增：“点赞/评论”核心函数 ==============
// =======================================================
/**
 * 处理点赞/取消点赞的核心逻辑
 * @param {number} momentId - 被操作的动态ID
 * @param {number} dossierId - 发布该动态的角色ID
 * @returns {Promise<boolean>} - 返回最新的点赞状态
 */
async function handleLikeToggle(momentId, dossierId) {
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return false; // 如果找不到档案，操作失败

    const likerId = dossier.user.name || 'default_user'; // 使用档案中真实的用户名

    const existingLike = await dbHelper.findLike(momentId, likerId);

    if (existingLike) {
        await dbHelper.delete(CONSTANTS.STORE_NAMES.LIKES, existingLike.id);
        appState.userLikedMomentIds.delete(momentId);
        return false;
    } else {
        const newLike = {
            momentId: momentId,
            likerId: likerId, // 使用真实用户名
            likerType: 'user',
            timestamp: Date.now()
        };
        await dbHelper.add(CONSTANTS.STORE_NAMES.LIKES, newLike);
        appState.userLikedMomentIds.add(momentId);
        return true;
    }
}

/**
 * 处理发布新评论的核心逻辑
 * @param {number} momentId - 被评论的动态ID
 * @param {number} dossierId - 发布该动态的角色ID
 * @param {string} commentText - 评论的文字内容
 */

// (用这个精简日志版，完整替换旧的 handlePostComment 函数)

async function handlePostComment(momentId, dossierId, commentText, repliedToCommentId = null) {
    const moment = await dbHelper.get(CONSTANTS.STORE_NAMES.MOMENTS, momentId);
    if (!moment) {
        // 【保留】这是一个关键的流程终止错误，必须保留
        console.error(`[AI社交引擎] 错误：无法找到动态 ID ${momentId}，评论流程已终止。`);
        return;
    }

    // (中间保存评论的逻辑保持不变，移除所有日志)
    let authorId = 'global_user';
    if (moment.authorType !== 'user') {
        const dossier = appState.dossiers.find(d => d.id === moment.dossierId);
        authorId = dossier?.user.name || 'default_user';
    }

    const newComment = {
        momentId: momentId,
        authorId: authorId,
        authorType: 'user',
        content: commentText,
        timestamp: Date.now(),
        replyToId: repliedToCommentId
    };

    const newCommentId = await dbHelper.add(CONSTANTS.STORE_NAMES.COMMENTS, newComment);
    newComment.id = newCommentId;

    // --- AI 决策与精简日志记录 ---
    const repliedToComment = repliedToCommentId ? await dbHelper.get(CONSTANTS.STORE_NAMES.COMMENTS, repliedToCommentId) : null;
    const shouldTriggerAI = (moment.authorType === 'character') || (repliedToComment && repliedToComment.authorType === 'character');
    
    if (shouldTriggerAI) {
        // 【修改】只在决定要触发AI时，才打印第一条日志
        console.log(`[AI社交引擎] 检测到评论事件，正在为动态 #${momentId} 评估AI回复...`);

        const targetDossierId = repliedToComment ? repliedToComment.authorId : moment.dossierId;
        const targetDossier = appState.dossiers.find(d => d.id === targetDossierId);

        if (targetDossier) {
            // 【保留并优化】这是成功的日志
            console.log(`[AI社交引擎] ✅ 成功为角色 [${targetDossier.character.name}] 触发社交决策。`);
            triggerAiSocialDecision(moment, newComment, targetDossier);
        } else {
            // 【保留】这是关键的失败日志
            console.error(`[AI社交引擎] ❌ 严重错误：无法根据ID ${targetDossierId} 找到角色档案，AI决策失败。`);
        }
    } else {
        // 【保留】这是明确的“跳过”日志，也非常重要
        console.log(`[AI社交引擎] 评论事件不满足AI触发条件，已跳过。`);
    }
}

/**
 * 【全新】触发AI对新动态的社交扫描，并创建待办任务
 * @param {object} moment - 用户发布的新动态对象
 * @param {object} dossier - 需要进行扫描的AI角色档案
 */
async function triggerAiSocialScan(moment, dossier) {
    try {
        console.log(`AI行为引擎：为 [${dossier.character.name}] 触发对新动态 #${moment.id} 的扫描...`);

        // 1. 调用我们新创建的扫描Prompt
        const decisionPrompt = await promptManager.createSocialScanPrompt(dossier, moment);
        
        // 2. 调用API获取决策
        const aiResponse = await apiHelper.getChatCompletion(decisionPrompt);
        
        // 3. 解析JSON (复用已有的健壮解析逻辑)
        const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/);
        const jsonString = jsonMatch ? jsonMatch[1] : aiResponse;
        const decision = JSON.parse(jsonString);

        // 4. 如果AI决定评论，则创建待办任务
        if (decision.shouldComment && decision.commentContent) {
            const now = Date.now();
            const delay = (decision.delayInMinutes || 0) * 60 * 1000;
            const executeAt = now + delay;

            // 【核心区别】任务类型是 'moment_comment'
            const newAction = {
                dossierId: dossier.id,
                type: 'moment_comment', 
                payload: {
                    momentId: moment.id,
                    commentContent: decision.commentContent
                },
                executeAt: executeAt,
                status: 'pending'
            };

            // 5. 将任务存入数据库
            await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newAction);
            console.log(`[${dossier.character.name}] 已决定在 ${decision.delayInMinutes} 分钟后评论动态 #${moment.id}`);
        }
    } catch (error) {
        console.error(`AI [${dossier.character.name}] 扫描动态 #${moment.id} 失败:`, error);
    }
}

/**
 * 【全新】触发AI社交决策，并创建待办任务
 * @param {object} moment - 被评论的动态对象
 * @param {object} userComment - 用户发送的评论对象
 */

async function triggerAiSocialDecision(moment, userComment, targetDossier) {
    if (!targetDossier) return;

    let aiResponse = ''; 

    try {
        const decisionPrompt = promptManager.createSocialDecisionPrompt(targetDossier, moment, userComment);
        console.log('发送给AI的决策Prompt:', decisionPrompt);
        aiResponse = await apiHelper.getChatCompletion(decisionPrompt);
        console.log('AI 返回的原始决策文本:', aiResponse);
        
        // --- 【核心修复】使用更强大的“智能提取”逻辑，替换旧的解析方法 ---
        
        // 1. 寻找JSON的起始 { 和结束 } 符号的位置
        const jsonStartIndex = aiResponse.indexOf('{');
        const jsonEndIndex = aiResponse.lastIndexOf('}');

        // 2. 检查是否找到了一个看似JSON的结构
        if (jsonStartIndex === -1 || jsonEndIndex === -1 || jsonEndIndex < jsonStartIndex) {
            // 如果连 { 和 } 都找不到，说明AI返回的内容完全错误
            throw new Error("AI response did not contain a valid JSON object.");
        }

        // 3. 提取出从 { 到 } 的这部分字符串
        const jsonString = aiResponse.substring(jsonStartIndex, jsonEndIndex + 1);
        
        // 4. 尝试解析这个“净化”过的字符串
        const decision = JSON.parse(jsonString);
        
        // --- 修复结束，后续逻辑保持不变 ---

        if (decision.shouldReply && decision.replyContent) {
            const now = Date.now();
            const delay = (decision.delayInMinutes || 0) * 60 * 1000;
            const executeAt = now + delay;

            const newAction = {
                dossierId: targetDossier.id,
                type: 'comment_reply',
                payload: {
                    momentId: moment.id,
                    userCommentId: userComment.id,
                    replyContent: decision.replyContent
                },
                executeAt: executeAt,
                status: 'pending'
            };

            await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newAction);
            console.log(`已为 ${targetDossier.character.name} 创建了一个 ${decision.delayInMinutes} 分钟后的回复任务。`);
        }
    } catch (error) {
        console.error("AI社交决策失败:", error, "原始返回文本:", aiResponse);
    }
}

/**
 * 为指定的动态渲染其评论列表 (V2 - 已修复深层楼中楼显示逻辑)
 * @param {number} momentId - 动态的ID
 * @param {HTMLElement} containerElement - 用于放置评论列表的容器元素
 */
async function renderCommentsForPost(momentId, containerElement) {
    if (!containerElement) return;

    const db = await dbHelper.dbPromise;
    const allComments = await db.getAllFromIndex(CONSTANTS.STORE_NAMES.COMMENTS, 'by_momentId', momentId);
    
    // 仍然先按时间排序，确保同级评论的顺序是正确的
    allComments.sort((a, b) => a.timestamp - b.timestamp);

    containerElement.classList.toggle('has-comments', allComments.length > 0);
    containerElement.innerHTML = ''; 

    // --- 【最终修复开始】 ---

    // 1. 创建一个Map来按父ID对所有评论进行分组
    const childrenMap = new Map();
    const topLevelComments = [];

    for (const comment of allComments) {
        // 使用 comment.replyToId || null 来处理顶层评论 (它们的replyToId可能是undefined或null)
        const parentId = comment.replyToId || null; 
        if (!childrenMap.has(parentId)) {
            childrenMap.set(parentId, []);
        }
        childrenMap.get(parentId).push(comment);
    }
    
    // 2. 创建一个可复用的函数来渲染单个评论（这部分逻辑不变，很完美）
    const renderSingleComment = async (comment) => {
        let authorName = '';
        let authorAvatarUrl = '';

        if (comment.authorType === 'user') {
            authorName = '我';
            const globalAvatarSetting = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'global_user_avatar_asset_id');
            if (globalAvatarSetting?.value) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, globalAvatarSetting.value);
                if (asset?.file) authorAvatarUrl = URL.createObjectURL(asset.file);
            }
        } else { 
            const dossier = appState.dossiers.find(d => d.id === comment.authorId);
            if (dossier) {
                authorName = dossier.character.name;
                if (dossier.character.avatarAssetId) {
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                    if (asset?.file) authorAvatarUrl = URL.createObjectURL(asset.file);
                }
            }
        }
        
        const commentItem = document.createElement('div');
        commentItem.className = 'comment-item';
        
        if (comment.replyToId) {
            commentItem.classList.add('is-reply');
        }
        
        const avatarStyle = authorAvatarUrl ? `style="background-image: url('${authorAvatarUrl}')"` : '';

        let replyPrefix = '';
        if (comment.replyToId) {
            const repliedToComment = allComments.find(c => c.id === comment.replyToId);
            if (repliedToComment) {
                let repliedToAuthorName = '';
                if (repliedToComment.authorType === 'user') {
                    repliedToAuthorName = '我';
                } else {
                    const dossier = appState.dossiers.find(d => d.id === repliedToComment.authorId);
                    repliedToAuthorName = dossier?.character.name || '角色';
                }
                replyPrefix = `<span style="opacity: 0.7;">回复 ${repliedToAuthorName}: </span>`;
            }
        }
        
        commentItem.innerHTML = `
            <div class="comment-author-avatar" ${avatarStyle}></div>
            <div class="comment-content">
                <div class="comment-header">
                    <span class="comment-author-name">${authorName}</span>
                    <span class="comment-actions" data-comment-id="${comment.id}">回复</span>
                    <span class="comment-timestamp">${formatRelativeTime(comment.timestamp)}</span>
                </div>
                <span class="comment-text">${replyPrefix}${comment.content}</span>
            </div>
        `;
        containerElement.appendChild(commentItem);
    };

    // 3. 创建一个递归函数来按层级渲染评论
    const renderNestedComments = async (parentId) => {
        const children = childrenMap.get(parentId) || [];
        for (const childComment of children) {
            // 先渲染子评论本身
            await renderSingleComment(childComment);
            // 然后递归地渲染这个子评论的子评论
            await renderNestedComments(childComment.id);
        }
    };

    // 4. 从顶层（parentId为null）开始启动渲染
    await renderNestedComments(null);

    // --- 【最终修复结束】 ---
}

/**
 * 【全新】为当前快拍渲染评论气泡
 */
async function renderCommentsForStory() {
    if (!DOM.storyViewerOverlay.classList.contains('visible')) return;

    const currentStory = appState.currentViewingStories[appState.currentStoryIndex];
    if (!currentStory) return;

    DOM.storyCommentsContainer.innerHTML = '';

    const db = await dbHelper.dbPromise;
    const comments = await db.getAllFromIndex(CONSTANTS.STORE_NAMES.COMMENTS, 'by_momentId', currentStory.id);
    comments.sort((a, b) => a.timestamp - b.timestamp);

    for (const comment of comments) {
        // 我们需要一个辅助函数来创建气泡元素，避免代码重复
        const bubble = await createStoryCommentBubble(comment);
        DOM.storyCommentsContainer.appendChild(bubble);
    }
}

/**
 * 【全新】创建一个评论气泡的辅助函数
 */
async function createStoryCommentBubble(comment) {
    let authorName = '';
    let authorAvatarUrl = '';
    
    // (这里的逻辑和 renderCommentsForPost 里的身份识别逻辑完全一样)
    if (comment.authorType === 'user') {
        const moment = await dbHelper.get(CONSTANTS.STORE_NAMES.MOMENTS, comment.momentId);
        const dossier = appState.dossiers.find(d => d.id === moment.dossierId);
        if (dossier) {
            authorName = dossier.user.name || '你';
            if (dossier.user.avatarAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.user.avatarAssetId);
                if (asset?.file) authorAvatarUrl = URL.createObjectURL(asset.file);
            }
        }
    } else if (comment.authorType === 'character') { // --- 【核心修复】 ---
        // 角色评论的 authorId 就是其 dossierId
        const dossier = appState.dossiers.find(d => d.id === comment.authorId);
        if (dossier) {
            authorName = dossier.character.name;
            if (dossier.character.avatarAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                if (asset?.file) authorAvatarUrl = URL.createObjectURL(asset.file);
            }
        }
    } // --- 修复结束 ---


    const bubble = document.createElement('div');
    bubble.className = 'story-comment-bubble';
    const avatarStyle = authorAvatarUrl ? `style="background-image: url('${authorAvatarUrl}')"` : '';

    bubble.innerHTML = `
        <div class="story-comment-avatar" ${avatarStyle}></div>
        <div class="story-comment-text">
            <strong>${authorName}</strong>
            <span>${comment.content}</span>
        </div>
    `;
    return bubble;
}

/**
 * 【全新 V2.1】【专家】处理“主动评论动态”类型的任务 (已移除点击跳转)
 */
async function handleMomentCommentAction(payload, dossierId) {
    const { momentId, commentContent } = payload;
    
    // 1. 构造 AI 的评论对象 (这部分保持不变)
    const aiComment = {
        momentId: momentId,
        authorId: dossierId, 
        authorType: 'character',
        content: commentContent,
        timestamp: Date.now()
    };
    await dbHelper.add(CONSTANTS.STORE_NAMES.COMMENTS, aiComment);

    // 2. 进行“在场检测”
    const isUserOnMomentsPage = document.getElementById('moments-pane')?.classList.contains('active');
    
    if (isUserOnMomentsPage) {
        // 用户在动态主页，无声地刷新列表
        await renderMoments(); 
    } else {
        // 用户在别处，发送一个【纯通知、不可点击】的全局横幅
        const dossier = appState.dossiers.find(d => d.id === dossierId);
        if (dossier) {
            const avatarAsset = dossier.character.avatarAssetId ? await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId) : null;
            const avatarUrl = avatarAsset?.file ? URL.createObjectURL(avatarAsset.file) : null;
            
            const moment = await dbHelper.get(CONSTANTS.STORE_NAMES.MOMENTS, momentId);
            let title = `${dossier.character.name} 评论了你的动态`;
            
            // 【核心修改】调用 notificationManager 时，不再提供 onClick 回调函数
            notificationManager.show({
                avatarUrl,
                title: title,
                message: commentContent
                // 此处不再有 onClick 属性
            });
        }
    }
}

/**
 * 【专家】处理“回复评论”类型的任务
 */
async function handleCommentReplyAction(payload, dossierId) {
    const { momentId, userCommentId, replyContent } = payload;
    
    // 1. 构造 AI 的回复对象
    const aiComment = {
        momentId: momentId,
        authorId: dossierId, // AI的ID就是它的dossierId
        authorType: 'character',
        content: replyContent,
        replyToId: userCommentId, // 标记这是对哪条评论的回复
        timestamp: Date.now()
    };
    await dbHelper.add(CONSTANTS.STORE_NAMES.COMMENTS, aiComment);

    // 2. 【核心】进行“在场检测”，决定如何通知用户
    const isUserOnMomentsPage = document.getElementById('moments-pane')?.classList.contains('active');
    const isUserOnStoryViewer = DOM.storyViewerOverlay.classList.contains('visible') && appState.currentViewingStories.some(s => s.id === momentId);

    if (isUserOnMomentsPage) {
        // 用户在动态主页，无声地刷新“日常”评论区
        renderMoments(); 
    } else if (isUserOnStoryViewer) {
        // 用户正在看这个快拍，播放冒泡动画
        const bubble = await createStoryCommentBubble(aiComment);
        DOM.storyCommentsContainer.appendChild(bubble);
        DOM.storyCommentsContainer.scrollTop = DOM.storyCommentsContainer.scrollHeight;
    } else {
        // 用户在别处，发送全局横幅提醒
        const dossier = appState.dossiers.find(d => d.id === dossierId);
        if (dossier) {
            const avatarAsset = dossier.character.avatarAssetId ? await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId) : null;
            const avatarUrl = avatarAsset?.file ? URL.createObjectURL(avatarAsset.file) : null;
            notificationManager.show({
                avatarUrl,
                title: `${dossier.character.name} 回复了你的评论`,
                message: replyContent,
                onClick: () => { /* 暂时无跳转 */ }
            });
        }
    }
}

/**
 * 【全新】处理全局玩家头像的上传与保存
 */
async function handleGlobalAvatarUpload(file) {
    if (!file) return;
    try {
        // 全局头像是用于UI显示的, 所以使用 ForDisplay 压缩
        const compressedFile = await compressImageForDisplay(file);
        const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });

        // 将 assetId 存入 user_settings 表
        await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, { value: assetId }, 'global_user_avatar_asset_id');

        // 立即更新UI
        const url = URL.createObjectURL(compressedFile);
        DOM.userMomentAvatarUploader.style.backgroundImage = `url(${url})`;
        DOM.userMomentAvatarUploader.innerHTML = ''; // 清空图标

        utils.showToast('头像已更新');

        // 【关键】刷新动态页面，让顶部的“你的快拍”也同步更新
        await renderMoments();

    } catch (error) {
        console.error('Global avatar upload failed:', error);
    }
}

/**
 * 【V2.2 最终修复版】处理用户发布新动态的核心逻辑 (已彻底修复导航Bug)
 */
async function handlePostUserMoment() {
    DOM.publishMomentBtn.disabled = true;
    DOM.publishMomentBtn.textContent = '发布中...';

    try {
        const type = DOM.momentTypeSelector.querySelector('.active').dataset.type;
        const content = DOM.momentContentInput.value.trim();
        const imageFile = appState.pendingMomentImageFile;

        if (!content && !imageFile) {
            utils.showToast('内容和图片至少要有一个哦');
            // 修复：这里应该提前返回，但为了保险，把按钮状态恢复放在 finally 块
            return;
        }

        let assetId = null;
        if (imageFile) {
            const compressedFile = await compressImageForAI(imageFile);
            assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });
        }

        const newMoment = {
            type, content, assetId,
            authorType: 'user', authorId: 'global_user', dossierId: null,
            timestamp: Date.now()
        };

        if (type === 'story') {
            newMoment.expiresAt = newMoment.timestamp + (24 * 60 * 60 * 1000);
        }

        const newMomentId = await dbHelper.add(CONSTANTS.STORE_NAMES.MOMENTS, newMoment);
        newMoment.id = newMomentId; 

        utils.showToast('发布成功！');

        // --- 【核心修复】使用精准、无副作用的手动导航逻辑 ---
        
        // 1. 关闭当前的发布页面浮层
        closeNavigator(DOM.momentCreatorApp);

        // 2. 手动激活聊天应用的主页
        navigateToPage(DOM.chatApp, 'chat-main-page');

        // 3. 手动切换到“动态”标签页的视觉状态
        DOM.chatTabItems.forEach(item => item.classList.remove('active'));
        document.querySelector('.tab-item[data-target="moments-pane"]').classList.add('active');
        
        // 4. 手动切换到“动态”的内容面板
        DOM.chatContentPanes.forEach(pane => pane.classList.remove('active'));
        document.getElementById('moments-pane').classList.add('active');
        DOM.chatHeaderTitle.textContent = '动态';

        // 5. 【关键】直接、且只调用一次渲染函数
        await renderMoments();
        
        // --- 修复结束 ---

        // 清理表单 (这部分逻辑移到导航之后)
        DOM.momentContentInput.value = '';
        DOM.momentImageUploader.style.backgroundImage = 'none';
        DOM.momentImageUploader.innerHTML = '<i class="ri-image-add-line" style="font-size: 32px;"></i>';
        appState.pendingMomentImageFile = null;

       // 在后台为所有AI角色触发社交扫描
        console.log("新动态已发布，正在为所有AI角色触发后台社交扫描...");
        for (const dossier of appState.dossiers) {
            // 【【【 核心修复：添加 .catch() 安全网 】】】
            triggerAiSocialScan(newMoment, dossier).catch(error => {
                console.error(`为角色 [${dossier.character.name}] 触发社交扫描时发生未捕获的错误:`, error);
            });
        }

    } catch (error) {
        console.error('Failed to publish moment:', error);
        utils.showToast(`发布失败: ${error.message}`);
    } finally {
        // 确保无论成功还是失败，按钮都会恢复可用状态
        DOM.publishMomentBtn.disabled = false;
        DOM.publishMomentBtn.textContent = '发布';
    }
}

// =======================================================
// ============ 新增：“模拟视频通话”核心函数 ============
// =======================================================

// (用这个升级版，替换旧的 startVideoCall)

async function startVideoCall(openingScene = null) {
    const dossierId = appState.currentChattingDossierId;
    if (!dossierId) return utils.showToast('无法发起通话，角色信息丢失');

    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return utils.showToast('找不到角色档案');

    // 1. 清空上次的字幕
    DOM.videoCallScriptContainer.innerHTML = '';
    
    // 2. 设置背景和所有头像
    if (dossier.character.avatarAssetId) {
        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
        if (asset?.file) {
            const charAvatarUrl = URL.createObjectURL(asset.file);
            DOM.videoCallOverlay.style.backgroundImage = `url(${charAvatarUrl})`;
            DOM.videoCallCharacterAvatarSmall.src = charAvatarUrl;
        }
    }
    if (dossier.user.avatarAssetId) {
        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.user.avatarAssetId);
        if (asset?.file) {
            DOM.videoCallUserAvatar.src = URL.createObjectURL(asset.file);
        }
    } else {
        DOM.videoCallUserAvatar.src = '';
    }
    
    // 3. 进入“连接中”状态
    DOM.videoCallOverlay.classList.add('connecting');
    DOM.videoCallStatusText.style.display = 'block'; // 确保显示
    DOM.videoCallInput.disabled = true;
    DOM.videoCallActionBtn.querySelector('span').textContent = '取消';
    
    // 4. 显示UI
    DOM.videoCallOverlay.classList.add('visible');
    
    // 5. 模拟3秒连接
    setTimeout(() => {
        if (!DOM.videoCallOverlay.classList.contains('visible')) return;
        
        DOM.videoCallOverlay.classList.remove('connecting');
        DOM.videoCallStatusText.style.display = 'none';
        DOM.videoCallInput.disabled = false;
        DOM.videoCallInput.focus();
        DOM.videoCallActionBtn.querySelector('span').textContent = '挂断';
        
        // 6. 启动计时器
        appState.callStartTime = Date.now();
        DOM.videoCallTimer.textContent = '00:00';
        appState.callTimerIntervalId = setInterval(() => {
            if (!appState.callStartTime) return;
            const elapsedSeconds = Math.floor((Date.now() - appState.callStartTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
            const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
            DOM.videoCallTimer.textContent = `${minutes}:${seconds}`;
        }, 1000);
        
        // 7. 【核心】智能处理开场白 
        if (Array.isArray(openingScene) && openingScene.length > 0) {
            // 如果是接听电话，直接使用AI预设好的【整个剧本数组】
            appendVideoCallScript(openingScene, dossier.character.name);
        } else {
            // 如果是用户主动发起，则像以前一样请求AI生成
            triggerVideoCallOpening();
        }

    }, 3000);
}

async function endVideoCall() {
            // 响应优先，先隐藏界面
            DOM.videoCallOverlay.classList.remove('visible');

            const wasConnecting = DOM.videoCallOverlay.classList.contains('connecting');
            const dossierId = appState.currentChattingDossierId;
            if (!dossierId) return; // 安全检查

            if (wasConnecting) {
                // --- 情况1: 通话被【取消】(逻辑保持不变) ---
                const systemMessage = {
                    dossierId: dossierId, sender: 'system',
                    content: `你未接通视频通话`, timestamp: Date.now()
                };
                await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, systemMessage);
                if (document.getElementById('chat-dialogue-page').classList.contains('active')) {
                    await renderMessage(systemMessage);
                }
            } else {
                // --- 情况2: 通话被【正常挂断】，启动回忆生成！ ---
                clearInterval(appState.callTimerIntervalId);
                const durationSeconds = appState.callStartTime ? Math.floor((Date.now() - appState.callStartTime) / 1000) : 0;
                const minutes = Math.floor(durationSeconds / 60).toString().padStart(2, '0');
                const seconds = (durationSeconds % 60).toString().padStart(2, '0');
                const durationString = `${minutes}:${seconds}`;

                // a. 添加通话结束的系统消息 (保持不变)
                const systemMessage = {
                    dossierId: dossierId, sender: 'system',
                    content: `视频通话已结束，通话时长：${durationString}`, timestamp: Date.now()
                };
                await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, systemMessage);
                await openChatWindow(dossierId);

                // b. 【核心新增】在后台静默执行回忆生成
                (async () => {
                    try {
                        console.log(`[回忆引擎] 视频通话 #${dossierId} 已结束，开始生成回忆摘要...`);
                        const dossier = appState.dossiers.find(d => d.id === dossierId);
                        if (!dossier) throw new Error("找不到对应的角色档案。");

                        // 1. 从DOM中提取完整的通话记录
                        let transcript = '';
                        DOM.videoCallScriptContainer.querySelectorAll('.script-line').forEach(line => {
                            transcript += line.textContent.trim() + '\n';
                        });
                        if (!transcript.trim()) throw new Error("通话记录为空，无法生成回忆。");

                        // 2. 调用我们新创建的Prompt
                        const memoryPrompt = promptManager.createVideoCallMemoryPrompt(dossier, transcript);
                        
                        // 3. 请求AI生成回忆JSON
                        const aiResponse = await apiHelper.getChatCompletion(memoryPrompt);
                        const jsonStartIndex = aiResponse.indexOf('{');
                        const jsonEndIndex = aiResponse.lastIndexOf('}');
                        if (jsonStartIndex === -1 || jsonEndIndex === -1) throw new Error("AI未能返回有效的回忆JSON。");
                        const jsonString = aiResponse.substring(jsonStartIndex, jsonEndIndex + 1);
                        const memoryData = JSON.parse(jsonString);

                        if (!memoryData.title || !memoryData.summary) throw new Error("AI返回的回忆JSON缺少必要字段。");
                        
                        // 4. 构建完整的“回忆”对象
                        const newMemory = {
                            dossierId: dossierId,
                            type: 'video_call',
                            timestamp: Date.now(),
                            title: memoryData.title,
                            summary: memoryData.summary
                        };

                        // 5. 将这份珍贵的回忆存入数据库！
                        await dbHelper.add(CONSTANTS.STORE_NAMES.MEMORIES, newMemory);
                        console.log(`[回忆引擎] ✅ 成功为角色 [${dossier.character.name}] 生成并存储了一条新的视频通话回忆！`);

                        // 6. 【核心新增】显示一个“回忆已珍藏”的全局横幅通知
                        const avatarAsset = dossier.character.avatarAssetId ? await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId) : null;
                        const avatarUrl = avatarAsset?.file ? URL.createObjectURL(avatarAsset.file) : null;
                        
                        notificationManager.show({
                            avatarUrl,
                            title: `一段与 ${dossier.character.name} 的新回忆`,
                            message: `“${memoryData.title}” 已被珍藏`,
                            onClick: null 
                        });

                    } catch (error) {
                        console.error("[回忆引擎] ❌ 生成视频通话回忆时发生错误:", error);
                    }
                })(); // <--- 使用IIFE立即执行这个异步的后台任务
            }

            // 清理工作 (保持不变)
            appState.callStartTime = null;
            appState.callTimerIntervalId = null;
            DOM.videoCallOverlay.style.backgroundImage = 'none';
            DOM.videoCallCharacterAvatarSmall.src = '';
            DOM.videoCallUserAvatar.src = '';
        }

/**
 * 【V2版】将“剧本”追加到屏幕上，并区分说话人
 * @param {Array} scriptItems - 要渲染的字幕对象数组
 * @param {string} speakerName - 说话人的名字 ("我" 或 角色名)
 */

function appendVideoCallScript(scriptItems, speakerName) {
    const container = DOM.videoCallScriptContainer;

    if (!Array.isArray(scriptItems)) {
        const errorLine = document.createElement('div');
        errorLine.className = 'script-line dialogue';
        errorLine.textContent = `[AI返回格式错误]`;
        container.appendChild(errorLine);
        return;
    }

    const speakerType = (speakerName === "我") ? "user" : "character";

    scriptItems.forEach(item => {
        const line = document.createElement('div');
        line.className = `script-line ${item.type}`;
        
        // 【核心新增】为每一行都添加说话人标记，方便后续读取
        line.dataset.speaker = speakerType;
        
        let content = item.content;

        if (item.type === 'dialogue' && speakerName) {
            line.innerHTML = `<span class="speaker-name ${speakerType}">${speakerName}:</span> ${content}`;
        } else if (item.type === 'thought') {
            content = content.startsWith('*') && content.endsWith('*') 
                ? content.slice(1, -1) 
                : content;
            line.textContent = content;
        } else {
            line.textContent = content;
        }
        
        container.appendChild(line);
    });

    container.scrollTop = container.scrollHeight;
}

/**
 * 触发AI生成开场白
 */
async function triggerVideoCallOpening() {
    const dossierId = appState.currentChattingDossierId;
    if (!dossierId) return;
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return;

    // 1. 显示“对方正在说话...”
    DOM.videoCallTypingIndicator.style.display = 'block';

    try {
        // 2. 调用AI获取开场白
        const messages = promptManager.createVideoCallPrompt(dossier, null); // userInput为null表示请求开场白
        const aiResponse = await apiHelper.getChatCompletion(messages);
        
        // 3. 解析并渲染剧本
       // vvv 【核心修复】增加JSON净化逻辑 vvv
        const startIndex = aiResponse.indexOf('[');
        const endIndex = aiResponse.lastIndexOf(']');
        if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
            throw new Error("AI response did not contain a valid JSON array.");
        }
        const jsonString = aiResponse.substring(startIndex, endIndex + 1);
        const script = JSON.parse(jsonString);
       appendVideoCallScript(script, dossier.character.name);

    } catch (error) {
        console.error("获取视频通话开场白失败:", error);
       appendVideoCallScript([{ type: 'dialogue', content: '“喂？...信号好像不太好...”' }], dossier.character.name);
    } finally {
        // 4. 隐藏“对方正在说话...”
        DOM.videoCallTypingIndicator.style.display = 'none';
    }
}

/**
 * 【V3.1 最终修复版】处理用户在视频通话中发送文字（已修复AI上下文重复问题）
 */
async function handleVideoCallSend() {
    const userInput = DOM.videoCallInput.value.trim();
    if (!userInput) return;

    const dossierId = appState.currentChattingDossierId;
    if (!dossierId) return;
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return;
    
    // --- 【核心修正】调整执行顺序 ---

    // 1. 立刻禁用输入，防止重复发送
    DOM.videoCallInput.disabled = true;
    DOM.videoCallSendBtn.disabled = true;
    DOM.videoCallTypingIndicator.style.display = 'block';

    try {
        // 2.【先】从当前的DOM中构建发送给AI的历史记录
        //    此时，用户的最新输入还没有被加到DOM里，所以历史是干净的
        const transcriptHistory = [];
        DOM.videoCallScriptContainer.querySelectorAll('.script-line.dialogue').forEach(line => {
            const speaker = line.dataset.speaker;
            const tempLine = line.cloneNode(true);
            const speakerSpan = tempLine.querySelector('.speaker-name');
            if (speakerSpan) {
                speakerSpan.remove();
            }
            let content = tempLine.textContent.trim();
            if (content.startsWith('“') && content.endsWith('”')) {
                content = content.slice(1, -1);
            }
            if (speaker && content) {
                transcriptHistory.push({
                    role: speaker === 'user' ? 'user' : 'assistant',
                    content: content
                });
            }
        });

        // 3.【后】更新UI，把用户的最新输入显示出来
        appendVideoCallScript([{ type: 'dialogue', content: `“${userInput}”` }], "我");
        DOM.videoCallInput.value = ''; // 清空输入框

        const divider = document.createElement('hr');
        divider.className = 'script-divider';
        DOM.videoCallScriptContainer.appendChild(divider);
        DOM.videoCallScriptContainer.scrollTop = DOM.videoCallScriptContainer.scrollHeight;
        
        // 4. 现在，带着“干净”的历史记录和最新的用户输入去请求AI
        const messages = promptManager.createVideoCallPrompt(dossier, userInput, transcriptHistory);
        const aiResponse = await apiHelper.getChatCompletion(messages);
        
        const startIndex = aiResponse.indexOf('[');
        const endIndex = aiResponse.lastIndexOf(']');
        if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
            throw new Error("AI response did not contain a valid JSON array.");
        }
        const jsonString = aiResponse.substring(startIndex, endIndex + 1);
        const script = JSON.parse(jsonString);

        appendVideoCallScript(script, dossier.character.name);

    } catch (error) {
        console.error("获取视频通话回复失败:", error);
        appendVideoCallScript([{ type: 'dialogue', content: '“嗯...你刚刚说什么？我没太听清。”' }], dossier.character.name);
    } finally {
        DOM.videoCallInput.disabled = false;
        DOM.videoCallSendBtn.disabled = false;
        DOM.videoCallTypingIndicator.style.display = 'none';
        DOM.videoCallInput.focus();
    }
}

// ====== 新增：“来电处理”核心函数 ======//

/**
 * 【电话调度员】处理到期的来电任务，并显示横幅
 * @param {number} dossierId - 来电角色的ID
 * @param {object} payload - 任务的载荷，包含开场白等信息
 */
async function handleIncomingCall(dossierId, payload) {
    // 安全检查：如果当前已经有一个电话正在打或正在通话中，则忽略新的来电
    if (document.getElementById('incoming-call-banner').classList.contains('visible') || 
        DOM.videoCallOverlay.classList.contains('visible')) {
        console.log(`[来电调度员] 已有一个通话正在进行，忽略了来自 dossierId: ${dossierId} 的新来电。`);
        return;
    }
    
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return;

    // 1. 填充横幅信息
    const banner = document.getElementById('incoming-call-banner');
    const avatarEl = document.getElementById('caller-avatar');
    const nameEl = document.getElementById('caller-name');
    
    nameEl.textContent = dossier.character.name;
    if (dossier.character.avatarAssetId) {
        const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
        if (asset?.file) {
            avatarEl.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`;
        }
    } else {
        avatarEl.style.backgroundImage = 'none';
    }

    // 2. 【关键】为按钮动态绑定【一次性】的点击事件
    const acceptBtn = document.getElementById('accept-call-btn');
    const declineBtn = document.getElementById('decline-call-btn');

    // 使用 .onclick 赋值可以轻松覆盖旧的监听器，确保不会重复绑定
    acceptBtn.onclick = () => handleAcceptCall(dossierId, payload);
    declineBtn.onclick = () => handleDeclineCall(dossierId);
    
    // 3. 显示横幅
    banner.classList.add('visible');
    
    // 4. (可选) 播放来电铃声
    // TODO: 如果有铃声音频文件，可以在这里播放
}

/**
 * 【接线员】处理“接听”操作
 * @param {number} dossierId - 来电角色的ID
 * @param {object} payload - 任务的载荷
 */

function handleAcceptCall(dossierId, payload) {
    const banner = document.getElementById('incoming-call-banner');
    banner.classList.remove('visible');

    // 1. 切换全局的聊天对象ID
    appState.currentChattingDossierId = dossierId;

    // 2. 为了确保通话界面能正常弹出，关闭所有可能打开的应用
    if (DOM.settingsNavigator.classList.contains('active')) closeNavigator(DOM.settingsNavigator);
    if (DOM.archiveApp.classList.contains('active')) closeNavigator(DOM.archiveApp);
    if (DOM.chatApp.classList.contains('active')) closeNavigator(DOM.chatApp);
    if (DOM.libraryApp.classList.contains('active')) closeNavigator(DOM.libraryApp);
    
    // 3. 【最终修正】调用我们早已做好的视频通话界面，并把“开场白”传进去
    startVideoCall(payload);
}

/**
 * 【接线员】处理“拒绝”操作
 * @param {number} dossierId - 来电角色的ID
 */
async function handleDeclineCall(dossierId) {
    const banner = document.getElementById('incoming-call-banner');
    banner.classList.remove('visible');

    // 在后台为对应的聊天记录添加一条系统消息
    await renderMessage({
        dossierId: dossierId,
        sender: 'system',
        content: `你未接通视频通话`
    });
    // 更新会话列表的最后消息
    await updateChatSession(dossierId, '[未接视频通话]');
    
    utils.showToast('已拒接');
}

/**
 * 【全新】处理AI对转账的回应任务
 * @param {object} payload - 任务载荷，包含目标消息ID和AI的决定
 */
async function handleTransferResponse(payload) {
    const { targetMessageId, decision } = payload;
    if (!targetMessageId || !decision) return;

    // 1. 在内存和数据库中找到并更新原始的转账消息
    const messageIndex = appState.currentChatHistory.findIndex(msg => msg.id === targetMessageId);
    if (messageIndex === -1) return;

    const messageToUpdate = appState.currentChatHistory[messageIndex];
    const newStatus = (decision === 'accept') ? 'accepted' : 'declined';
    
    if (!messageToUpdate.metadata) messageToUpdate.metadata = {};
    messageToUpdate.metadata.status = newStatus;
    
    await dbHelper.set(CONSTANTS.STORE_NAMES.CHAT_HISTORY, messageToUpdate);

    // 2. 实时更新UI上的卡片
    const messageEl = document.querySelector(`.chat-message[data-message-id="${targetMessageId}"]`);
    if (messageEl) {
        const cardEl = messageEl.querySelector('.transfer-card');
        const iconEl = messageEl.querySelector('.transfer-info i');
        const statusTextEl = messageEl.querySelector('.transfer-status-text');

        cardEl.className = `transfer-card status-${newStatus}`;
        if (newStatus === 'accepted') {
            iconEl.className = 'ri-check-line';
            statusTextEl.textContent = '对方已收款';
        } else { // declined
            iconEl.className = 'ri-close-line';
            statusTextEl.textContent = '对方已退回';
        }
    }

    // 3. 添加系统消息
    const dossier = appState.dossiers.find(d => d.id === messageToUpdate.dossierId);
    const characterName = dossier?.character.name || '对方';
    const { amount, currency } = messageToUpdate.content;

   let systemMessageContent = '';
if (newStatus === 'accepted') {
    // 角色接受了你的转账，这笔支出是有效的。
    // 支出已在发起时记录，此处无需操作钱包。
    systemMessageContent = `${characterName} 已收款 ${amount} ${currency}`;
} else { // newStatus === 'declined'
    // 【核心修正】角色退回了你的转账，你需要记录一笔“收入”来抵消之前的支出。
    systemMessageContent = `${characterName} 退回了你的转账`;
    // 为钱包添加一笔“转账退回”的收入记录！
    await addWalletTransaction('income', messageToUpdate.dossierId, messageToUpdate.content.amount, '转账退回');
}

    const systemMessage = {
        dossierId: messageToUpdate.dossierId,
        sender: 'system',
        content: `[${systemMessageContent}]`,
        timestamp: Date.now()
    };
    
    const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, systemMessage);
    systemMessage.id = savedId;
    appState.currentChatHistory.push(systemMessage);
    
    // 只在用户正在当前聊天页面时才实时渲染系统消息
    if (document.getElementById('chat-dialogue-page').classList.contains('active') && appState.currentChattingDossierId === messageToUpdate.dossierId) {
        await renderMessage(systemMessage);
    }
    
    // 更新会话列表
    await updateChatSession(messageToUpdate.dossierId, `[${systemMessageContent}]`);
}

/**
 * 【V2 - 浮窗+筛选版】打开并渲染钱包页面
 * @param {string} filter - 'all', 'income', or 'expense'
 */
async function renderWalletPage(filter = 'all') {
    const db = await dbHelper.dbPromise;
    const allTransactions = await db.getAllFromIndex(CONSTANTS.STORE_NAMES.WALLET_TRANSACTIONS, 'by_timestamp');
    allTransactions.reverse();

    // 1. 【核心】根据筛选器过滤交易记录
    let filteredTransactions = allTransactions;
    if (filter === 'income') {
        filteredTransactions = allTransactions.filter(tx => tx.type === 'income');
    } else if (filter === 'expense') {
        filteredTransactions = allTransactions.filter(tx => tx.type === 'expense');
    }

    // 2. 计算总余额 (永远基于所有交易)
    let totalBalance = 0;
    allTransactions.forEach(tx => {
        totalBalance += (tx.type === 'income' ? tx.amount : -tx.amount);
    });
    DOM.walletBalance.textContent = `¥ ${totalBalance.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;

    // 3. 渲染筛选后的列表
    DOM.transactionList.innerHTML = '';
    if (filteredTransactions.length === 0) {
        DOM.transactionList.innerHTML = `<li class="empty-placeholder">暂无${filter === 'income' ? '收入' : filter === 'expense' ? '支出' : ''}记录</li>`;
    } else {
        filteredTransactions.forEach(tx => {
            const item = document.createElement('li');
            item.className = `transaction-item ${tx.type}`;
            const sign = tx.type === 'income' ? '+' : '-';
            const iconClass = tx.type === 'income' ? 'ri-arrow-down-line' : 'ri-arrow-up-line';
            item.innerHTML = `
                <div class="transaction-icon"><i class="${iconClass}"></i></div>
                <div class="transaction-details">
                    <span class="counterparty">${tx.counterpartyName}</span>
                    <span class="timestamp">${formatRelativeTime(tx.timestamp)}</span>
                </div>
                <span class="transaction-amount">${sign} ${tx.amount.toFixed(2)}</span>
            `;
            DOM.transactionList.appendChild(item);
        });
    }
    
    // 4. 更新筛选标签的激活状态
    DOM.transactionFilterTabs.querySelectorAll('.filter-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.filter === filter);
    });

    // 5. 【核心】打开浮窗
    DOM.walletModal.classList.add('visible');
}

/**
 * 【全新】将一笔交易记录存入钱包数据库
 */
async function addWalletTransaction(type, dossierId, amount, memo) {
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return;

    const transaction = {
        dossierId: dossierId,
        type: type, // 'income' or 'expense'
        amount: amount,
        counterpartyName: (type === 'income') ? `来自 ${dossier.character.name}` : `转给 ${dossier.character.name}`,
        memo: memo,
        timestamp: Date.now()
    };
    await dbHelper.add(CONSTANTS.STORE_NAMES.WALLET_TRANSACTIONS, transaction);
}

 /**
         * 【V3】根据数据库中的 'secrets' 表，渲染心事列表的UI
         */
        async function renderSecretsList() { // <--- 关键：将函数改为 async
            const container = DOM.secretsListContainer;
            
            // 1. 【核心升级】从数据库读取所有心事
            const allSecrets = await dbHelper.getAll(CONSTANTS.STORE_NAMES.SECRETS);
            
            // 2. 只筛选出“主题帖”（即没有父ID的心事）
            const rootSecrets = allSecrets.filter(secret => secret.parentId === null);

            // 3. 后续的渲染逻辑保持不变...
            if (rootSecrets.length === 0) {
                container.innerHTML = `<p style="text-align:center; opacity:0.7; padding: 50px 20px;">你的秘密花园里还没有任何心事...<br>点击右上角的“+”号，写下第一条吧。</p>`;
                return;
            }

            container.innerHTML = ''; // 清空旧内容
            const sortedSecrets = rootSecrets.sort((a, b) => b.timestamp - a.timestamp);

            for (const secret of sortedSecrets) {
                const card = document.createElement('div');
                card.className = `secret-card ${secret.authorType}`;
                card.dataset.secretId = secret.id;

                const moodIcons = {
                    happy: 'ri-emotion-happy-line',
                    sad: 'ri-emotion-unhappy-line',
                    love: 'ri-heart-add-line',
                    thoughtful: 'ri-question-line',
                    normal: 'ri-emotion-normal-line'
             };
                const iconClass = moodIcons[secret.mood] || 'ri-emotion-normal-line';
                
                let titleHTML = '';
                if (secret.authorType === 'character') {
                    titleHTML = `<span class="secret-card-title">${secret.authorName || '角色'}</span>`;
                } else {
                    titleHTML = `<span class="secret-card-title">${secret.title}</span>`;
                }

               card.innerHTML = `
                    <div class="secret-card-header">
                        ${titleHTML}
                        <i class="${iconClass}"></i>
                    </div>
                    <p class="secret-card-preview">${secret.content}</p>
                    <div class="secret-card-footer">
                        <span>${formatRelativeTime(secret.timestamp)}</span>
                    </div>
                    
                    <!-- vvv 【【【 新增的删除按钮 】】】 vvv -->
                    <i class="delete-secret-btn ri-delete-bin-line" title="删除心事"></i>
                    <!-- ^^^ 新增结束 ^^^ -->
                `;
                container.appendChild(card);
            }
        }
        // ^^^ 替换到此结束 ^^^
  
        /**
         * 【V2】打开并填充心事详情页浮窗（包含所有回应）
         * @param {number} secretId - 要打开的主题帖心事的ID
         */
        async function openSecretDetails(secretId) { // <--- 确保函数是 async 异步的
            
            // 1. 从数据库获取所有心事数据
            const allSecrets = await dbHelper.getAll(CONSTANTS.STORE_NAMES.SECRETS);
            
            // 2. 找到我们点击的那条“主题帖”心事
            const secret = allSecrets.find(s => s.id === secretId);
            
            // 安全检查，如果找不到就提前退出
            if (!secret) {
                utils.showToast('无法找到该心事');
                return;
            }

            // 3. 将当前正在查看的 secretId 存入全局状态，方便后续发送回应时使用
            appState.currentViewingSecretId = secretId;

            // 4. 渲染顶部的“原始心事”内容 (这部分和您之前确认的逻辑一致)
            const container = DOM.originalSecretContainer;
            const moodIcons = {
                happy: 'ri-emotion-happy-line',
                sad: 'ri-emotion-unhappy-line',
                love: 'ri-heart-add-line',
                thoughtful: 'ri-question-line',
                normal: 'ri-emotion-normal-line'
            };
            const iconClass = moodIcons[secret.mood] || 'ri-emotion-normal-line';
            
            container.innerHTML = `
                <div class="secret-card-header" style="border-bottom-color: rgba(var(--text-color-rgb), 0.15);">
                    <span class="secret-card-title">${secret.title}</span>
                    <i class="${iconClass}"></i>
                </div>
                <p class="secret-card-preview" style="-webkit-line-clamp: unset; max-height: 200px; overflow-y: auto;">${secret.content}</p>
                <div class="secret-card-footer" style="border-top-color: rgba(var(--text-color-rgb), 0.15);">
                    <span>${formatRelativeTime(secret.timestamp)}</span>
                </div>
            `;
            
            // 5. 【核心】渲染所有的后续回应/评论
            const commentsContainer = DOM.secretCommentsContainer;
            commentsContainer.innerHTML = ''; // 每次打开都先清空旧内容
            
            // a. 从所有数据中，筛选出所有 parentId 是当前心事ID的回应
            const responses = allSecrets
                .filter(s => s.parentId === secretId)
                .sort((a, b) => a.timestamp - b.timestamp); // 按时间正序排列，确保对话顺序正确

            // b. 遍历筛选出的回应数组，并为每一条创建对应的HTML元素
            for (const response of responses) {
                const commentEl = document.createElement('div');
                // 根据作者类型，添加 'user' 或 'character' 类，以应用不同的边框颜色
                commentEl.className = `secret-comment-item ${response.authorType}`;
                
                // 决定显示的作者名字
                const authorName = response.authorType === 'user' ? '我' : response.authorName;
                
                // vvv 【【【 这是唯一新增的代码块 】】】 vvv
                let replyPrefixHTML = '';
                // 检查这条回应是否有 replyToId
                if (response.replyToId) {
                    // 如果有，就去所有数据里找到它回复的那条原始评论
                    const repliedToComment = allSecrets.find(s => s.id === response.replyToId);
                    if (repliedToComment) {
                        // 决定被回复者的名字
                        const repliedToAuthorName = repliedToComment.authorType === 'user' ? '我' : repliedToComment.authorName;
                        // 构建HTML前缀
                        replyPrefixHTML = `<span style="opacity: 0.7;">回复 ${repliedToAuthorName}: </span>`;
                    }
                }
                // ^^^ 新增结束 ^^^
                
                // 使用 innerHTML 构建我们之前设计的“批注”样式结构
               commentEl.innerHTML = `
    <div class="secret-comment-header">
        <span class="secret-comment-author">${authorName}</span>
        <div class="comment-actions">
            <!-- vvv 【【【 新增的回复按钮 】】】 vvv -->
            <i class="ri-reply-line reply-to-comment-btn" data-comment-id="${response.id}" title="回复这条"></i>
            <!-- ^^^ 新增结束 ^^^ -->
            <span class="secret-comment-timestamp">${formatRelativeTime(response.timestamp)}</span>
        </div>
    </div>
  <p class="secret-comment-text">${replyPrefixHTML}${response.content}</p>
`;
                commentsContainer.appendChild(commentEl);
            }

            // 6. 显示整个浮窗
            DOM.secretDetailsModal.classList.add('visible');

            // 7. 【体验优化】使用一个微小的延迟，确保DOM渲染完成后，再将评论区滚动到底部
            setTimeout(() => {
                // 获取可滚动的父容器
                const scrollableContent = commentsContainer.parentElement;
                if (scrollableContent) {
                    scrollableContent.scrollTop = scrollableContent.scrollHeight;
                }
            }, 100);
        }
        
        // ^^^ 函数到此结束 ^^^

        /**
         * 【V2 - 健壮版】使用 Promise.all 并行触发所有角色的AI决策
         * @param {object} userSecret - 用户发布的心事对象
         */
        async function triggerAiSecretResponseDecision(userSecret) {
            console.log(`[心事引擎] 已收到新心事 #${userSecret.id}，正在为所有角色【并行】触发AI决策...`);

            // 1. 创建一个数组，用来存放所有角色的“决策任务”
            const decisionPromises = appState.dossiers.map(dossier => {
                // 这个 return 返回的是一个 Promise，代表一个独立的、正在进行的决策流程
                return (async () => {
                    try {
                        const responsePrompt = promptManager.createSecretResponsePrompt(dossier, userSecret);
                        const aiResponse = await apiHelper.getChatCompletion(responsePrompt);
                        
                        const jsonStartIndex = aiResponse.indexOf('{');
                        const jsonEndIndex = aiResponse.lastIndexOf('}');
                        if (jsonStartIndex === -1 || jsonEndIndex === -1) throw new Error("AI未返回有效的JSON对象。");
                        const jsonString = aiResponse.substring(jsonStartIndex, jsonEndIndex + 1);
                        const decision = JSON.parse(jsonString);

                        if (decision.shouldRespond && decision.responseContent) {
                            const delay = (decision.delayInMinutes || 0) * 60 * 1000;
                            const executeAt = Date.now() + delay;
                            const newAction = {
                                dossierId: dossier.id,
                                type: 'secret_response',
                                payload: {
                                    userSecretId: userSecret.id,
                                    responseContent: decision.responseContent 
                                },
                                executeAt: executeAt,
                                status: 'pending'
                            };
                            await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newAction);
                            console.log(`[心事引擎] ✅ 角色 [${dossier.character.name}] 已决定在 ${decision.delayInMinutes} 分钟后回应。`);
                        } else {
                            console.log(`[心事引擎] 角色 [${dossier.character.name}] 决定暂不回应。`);
                        }
                    } catch (error) {
                        // 【关键】在 Promise.all 中，单个任务的失败必须在内部捕获，
                        // 否则会导致整个 Promise.all 立即失败。
                        console.error(`[心事引擎] ❌ 为角色 [${dossier.character.name}] 处理决策时失败:`, error);
                    }
                })(); // <--- 注意这个立即执行的函数表达式 (IIFE)
            });

            // 2. 【核心】使用 Promise.all 来“同时”执行所有这些任务，并等待它们全部完成
            await Promise.all(decisionPromises);

            console.log(`[心事引擎] 所有角色的决策流程已全部完成。`);
        }

/**
         * 【全新】触发AI对心事主题帖的“第一条评论”进行决策
         * @param {object} userComment - 用户刚刚发布的回应对象
         */
        async function triggerAiSecretInitialCommentResponse(userComment) {
            // 1. 检查这条评论是否有父级（也就是它评论的那个主题帖）
            if (!userComment.parentId) return;

            // 2. 找到那个被评论的主题帖
            const originalSecret = await dbHelper.get(CONSTANTS.STORE_NAMES.SECRETS, userComment.parentId);

            // 3. 【核心】检查主题帖是否真的是由角色发布的
            if (!originalSecret || originalSecret.authorType !== 'character') {
                console.log(`[心事引擎] 跳过AI决策：用户评论的目标不是角色的心事。`);
                return;
            }

            // 4. 找到发布主题帖的那个角色
            const dossier = appState.dossiers.find(d => d.id === originalSecret.authorId);
            if (!dossier) {
                console.error(`[心事引擎] 严重错误：找不到ID为 #${originalSecret.authorId} 的角色档案。`);
                return;
            }

            console.log(`[心事引擎] 检测到用户初次评论，正在为角色 [${dossier.character.name}] 触发AI决策...`);

            try {
                // 5. 调用我们刚刚创建的专属Prompt
                const decisionPrompt = promptManager.createSecretInitialCommentResponsePrompt(dossier, originalSecret, userComment);
                
                // 6. 后续的逻辑（调用API、创建待办任务）和“楼中楼”回复完全一样
                const aiResponse = await apiHelper.getChatCompletion(decisionPrompt);
                const jsonStartIndex = aiResponse.indexOf('{');
                const jsonEndIndex = aiResponse.lastIndexOf('}');
                if (jsonStartIndex === -1 || jsonEndIndex === -1) throw new Error("AI未返回有效的JSON对象。");
                const jsonString = aiResponse.substring(jsonStartIndex, jsonEndIndex + 1);
                const decision = JSON.parse(jsonString);

                if (decision.shouldRespond && decision.responseContent) {
                    const delay = (decision.delayInMinutes || 0) * 60 * 1000;
                    const executeAt = Date.now() + delay;

                    const newAction = {
                        dossierId: dossier.id,
                        type: 'secret_response',
                        payload: {
                            userSecretId: originalSecret.id,
                            responseContent: decision.responseContent,
                            replyToId: userComment.id // 【关键】AI的回应，是在“回复”用户的这条初次评论
                        },
                        executeAt: executeAt,
                        status: 'pending'
                    };
                    
                    await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newAction);
                    console.log(`[心事引擎] ✅ 角色 [${dossier.character.name}] 已决定在 ${decision.delayInMinutes} 分钟后回应你的评论。`);
                }

            } catch (error) {
                console.error(`[心事引擎] ❌ 为角色 [${dossier.character.name}] 处理初次评论决策时失败:`, error);
            }
        }

/**
         * 【全新】触发AI对用户的“回复”进行决策
         * @param {object} userReply - 用户刚刚发布的回应对象
         */
        async function triggerAiSecretReplyDecision(userReply) {
            if (!userReply.replyToId) return;

            const allSecrets = await dbHelper.getAll(CONSTANTS.STORE_NAMES.SECRETS);
            const repliedToComment = allSecrets.find(s => s.id === userReply.replyToId);
            const originalSecret = allSecrets.find(s => s.id === userReply.parentId);

            if (!repliedToComment || repliedToComment.authorType !== 'character' || !originalSecret) {
                console.log(`[心事引擎] 跳过AI决策：用户回复的目标不是角色的批注，或原始数据丢失。`);
                return;
            }

            // 【核心修正】我们现在可以正确地从角色的批注记录中读取 authorId 了
            const dossierId = repliedToComment.authorId; 
            const dossier = appState.dossiers.find(d => d.id === dossierId);
            
            // 【关键】现在这个判断将能正常通过！
            if (!dossier) {
                console.error(`[心事引擎] 严重错误：在角色批注中找到了dossierId #${dossierId}，但在内存中找不到对应的角色档案。`);
                return;
            }

            console.log(`[心事引擎] 检测到用户回复，正在为角色 [${dossier.character.name}] 触发AI决策...`);

            try {
                // 1. 调用我们为“回复回复”设计的专属Prompt
               const decisionPrompt = promptManager.createSecretReplyDecisionPrompt(dossier, originalSecret, repliedToComment, userReply);
                
                // 2. 后续逻辑与之前的“一步到位”方案完全一致
                const aiResponse = await apiHelper.getChatCompletion(decisionPrompt);
                const jsonStartIndex = aiResponse.indexOf('{');
                const jsonEndIndex = aiResponse.lastIndexOf('}');
                if (jsonStartIndex === -1 || jsonEndIndex === -1) throw new Error("AI未返回有效的JSON对象。");
                const jsonString = aiResponse.substring(jsonStartIndex, jsonEndIndex + 1);
                const decision = JSON.parse(jsonString);

                if (decision.shouldRespond && decision.responseContent) {
                    const delay = (decision.delayInMinutes || 0) * 60 * 1000;
                    const executeAt = Date.now() + delay;

                    // 3. 创建待办任务，但 payload 中包含了 replyToId
                    const newAction = {
                        dossierId: dossier.id,
                        type: 'secret_response', // 我们可以复用这个任务类型
                        payload: {
                            userSecretId: originalSecret.id,
                            responseContent: decision.responseContent,
                            replyToId: userReply.id // 【关键】告诉AI它要回复的是哪条用户评论
                        },
                        executeAt: executeAt,
                        status: 'pending'
                    };
                    
                    await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newAction);
                    console.log(`[心事引擎] ✅ 角色 [${dossier.character.name}] 已决定在 ${decision.delayInMinutes} 分钟后进行“楼中楼”回复。`);
                }

            } catch (error) {
                console.error(`[心事引擎] ❌ 为角色 [${dossier.character.name}] 处理“楼中楼”回复决策时失败:`, error);
            }
        }

/**
         * 【全新 V2 - 随机不重复版】在用户发布心事后，触发单个角色的创作决策
         * @param {object} userSecret - 用户刚刚发布的心事对象
         */
        async function triggerAiSecretCreationDecision(userSecret) {
            console.log(`[心事引擎] 已收到新心事 #${userSecret.id}，正在为角色触发“脆弱的回响”创作决策...`);

            if (appState.dossiers.length === 0) return; // 如果没有角色，直接退出

            try {
                // 1. 从数据库获取上一个发布者的ID
                const lastAuthor = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'last_ai_secret_author_id');
                const lastAuthorId = lastAuthor ? lastAuthor.value : null;

                // 2. 创建一个排除了上一个作者的“候选人列表”
                let eligibleDossiers = appState.dossiers.filter(d => d.id !== lastAuthorId);

                // 3. 如果排除后列表为空（比如只有一个角色），则使用完整的列表
                if (eligibleDossiers.length === 0) {
                    eligibleDossiers = appState.dossiers;
                }

                // 4. 从候选人中随机挑选一位“幸运儿”
                const randomDossier = eligibleDossiers[Math.floor(Math.random() * eligibleDossiers.length)];

                console.log(`[心事引擎] 已随机选中角色 [${randomDossier.character.name}] 进行创作决策。`);

                // 5. 为这位幸运儿执行决策流程 (这部分和之前的逻辑类似)
                const creationPrompt = promptManager.createSecretCreationPrompt(randomDossier, userSecret);
                const aiResponse = await apiHelper.getChatCompletion(creationPrompt);
                
                const jsonStartIndex = aiResponse.indexOf('{');
                const jsonEndIndex = aiResponse.lastIndexOf('}');
                if (jsonStartIndex === -1 || jsonEndIndex === -1) throw new Error("AI未返回有效的JSON对象。");
                const jsonString = aiResponse.substring(jsonStartIndex, jsonEndIndex + 1);
                const decision = JSON.parse(jsonString);

                if (decision.shouldPost && decision.content) {
                    const delay = (decision.delayInMinutes || 30) * 60 * 1000;
                    const executeAt = Date.now() + delay;
                    const newAction = {
                        dossierId: randomDossier.id,
                        type: 'create_secret', // <-- 一个全新的任务类型！
                        payload: {
                            title: decision.title || '',
                            content: decision.content,
                            mood: decision.mood || 'thoughtful'
                        },
                        executeAt: executeAt,
                        status: 'pending'
                    };
                    await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newAction);
                    
                    // 6. 【关键】将本次被选中的角色ID，存回数据库，供下次排除使用
                    await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, { value: randomDossier.id }, 'last_ai_secret_author_id');

                    console.log(`[心事引擎] ✅ 角色 [${randomDossier.character.name}] 已决定在 ${decision.delayInMinutes} 分钟后分享自己的心事。`);
                } else {
                    console.log(`[心事引擎] 角色 [${randomDossier.character.name}] 决定保持沉默。`);
                }
            } catch (error) {
                console.error(`[心事引擎] ❌ 在为角色创作心事时失败:`, error);
            }
        }

        /**
         * 【全新】处理“AI创建心事”类型的待办任务
         * @param {object} payload - 任务的载荷
         * @param {number} dossierId - 执行此任务的角色ID
         */
        async function handleSecretCreationAction(payload, dossierId) {
            const dossier = appState.dossiers.find(d => d.id === dossierId);
            if (!dossier) return;

            try {
                const { title, content, mood } = payload;
                
                const aiSecret = {
                    parentId: null,
                    title: title,
                    content: content,
                    mood: mood,
                    timestamp: Date.now(),
                    authorType: 'character',
                    authorId: dossierId,
                    authorName: dossier.character.name
                };

                await dbHelper.add(CONSTANTS.STORE_NAMES.SECRETS, aiSecret);
                console.log(`[心事引擎] ✅ 角色 [${dossier.character.name}] 已成功发布心事。`);
                
                const avatarAsset = dossier.character.avatarAssetId ? await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId) : null;
                const avatarUrl = avatarAsset?.file ? URL.createObjectURL(avatarAsset.file) : null;
                
                // 【核心修正】调用 notificationManager 时，不再提供 onClick 回调函数，实现“不跳转”
                notificationManager.show({
                    avatarUrl,
                    title: `你收到一封来自 ${dossier.character.name} 的心事`,
                    message: content
                });

                if (document.getElementById('secrets-pane').classList.contains('active')) {
                    await renderSecretsList();
                }

            } catch (error) {
                console.error(`[心事引擎] ❌ 角色 [${dossier.character.name}] 在保存心事时失败:`, error);
            }
        }

/**
     * 【V2 - 宝丽来版】渲染回忆板块的角色选择照片墙
     */
    async function renderMemoryCharacterList() {
        const gridContainer = document.getElementById('memory-polaroid-grid');
        if (!gridContainer) return;

        gridContainer.innerHTML = '';
        if (appState.dossiers.length === 0) {
            gridContainer.innerHTML = `<p style="text-align:center; opacity:0.7; padding: 50px 20px;">还没有任何角色档案...</p>`;
            return;
        }

        for (const dossier of appState.dossiers) {
            const card = document.createElement('div');
            card.className = 'polaroid-card';
            card.dataset.dossierId = dossier.id;

            let avatarUrl = '';
            if (dossier.character.avatarAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                if (asset?.file) avatarUrl = URL.createObjectURL(asset.file);
            }
            const avatarStyle = avatarUrl ? `style="background-image: url('${avatarUrl}')"` : '';

            // 【核心】生成全新的宝丽来HTML结构
            card.innerHTML = `
                <div class="polaroid-image" ${avatarStyle}></div>
                <span class="polaroid-caption">${dossier.character.name}</span>
            `;
            gridContainer.appendChild(card);
        }
    }

        /**
         * 【V2 - 垂直胶片版】为指定角色渲染其专属的回忆胶片带
         * @param {number} dossierId - 角色的ID
         */
        async function renderMemoriesForDossier(dossierId) {
    // 【最终修正】直接使用我们更正后的 DOM 常量引用
    const container = DOM.memoryScrapbookContainer;
    container.innerHTML = '加载回忆中...';
    
    const memories = await dbHelper.dbPromise.then(db => 
        db.getAllFromIndex(CONSTANTS.STORE_NAMES.MEMORIES, 'by_dossierId', dossierId)
    );
    
    if (memories.length === 0) {
        container.innerHTML = `<p style="text-align:center; opacity:0.7; padding: 50px 20px;">这里还没有任何与TA的回忆...</p>`;
        return;
    }
    
    container.innerHTML = '';
    const sortedMemories = memories.sort((a, b) => b.timestamp - a.timestamp);

    for (const memory of sortedMemories) {
        const card = document.createElement('div');
        // 【最终修正】这里使用的 class 已经是正确的 .memory-card
        card.className = 'memory-card'; 
        
        let iconClass = 'ri-question-mark';
        if (memory.type === 'video_call') iconClass = 'ri-vidicon-line';
        
       card.innerHTML = `
            <div class="memory-card-header">
                <span class="memory-card-title">${memory.title}</span>
                <div style="display: flex; align-items: center; gap: 15px;">
                    <i class="delete-memory-btn ri-delete-bin-line" data-memory-id="${memory.id}" title="删除此回忆"></i>
                    <i class="${iconClass}" style="opacity: 0.7;"></i>
                </div>
            </div>
            <span class="memory-card-timestamp">${formatRelativeTime(memory.timestamp)}</span>
            <p class="memory-card-summary">${memory.summary}</p>
        `;
        container.appendChild(card);
    }
}

/**
 * 【管家】AI 行为引擎
 */
const ActionEngine = {
    _intervalId: null,

    async processQueue() {
        console.log("AI行为引擎：正在检查待办任务...");
        const dueActions = await dbHelper.getDuePendingActions();

// “无风的思念”日记触发逻辑
        // 为了防止AI频繁写日记，我们增加一个概率锁
        if (Math.random() < 0.2) { // 每次检查时，有20%的几率进入日记触发流程
            for (const dossier of appState.dossiers) {
                // 每个角色，每12小时内，有15%的几率触发一次
                const lastDiaryKey = `last_diary_trigger_${dossier.id}`;
                const lastTriggerTime = (await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, lastDiaryKey))?.value || 0;
                
                if (Date.now() - lastTriggerTime > 12 * 60 * 60 * 1000 && Math.random() < 0.15) {
                    console.log(`[灵魂回响] 触发了角色 [${dossier.character.name}] 的自发日记创作。`);
                    
                    // 【关键】在后台静默执行，不阻塞主流程
                    (async () => {
                        try {
                            // 1. 获取最近的聊天记录作为上下文
                            const chatHistory = await dbHelper.getHistoryForDossier(dossier.id);
                            const recentHistory = chatHistory.slice(-10); // 获取最近10条

                            // 2. 将记录传入新的Prompt生成器
                            const prompt = promptManager.createSpontaneousDiaryPrompt(dossier, recentHistory);
                            
                            // 3. 调用AI
                            const response = await apiHelper.getChatCompletion(prompt);
                            const jsonString = response.substring(response.indexOf('{'), response.lastIndexOf('}') + 1);
                            const diaryData = JSON.parse(jsonString);

                            // 4. 如果AI返回了有效内容，则创建待办任务
                            if (diaryData.content) {
                                const newAction = {
                                    dossierId: dossier.id,
                                    type: 'create_diary', // 任务类型
                                    payload: diaryData,
                                    // 0-10分钟内随机延迟发布，增加真实感
                                    executeAt: Date.now() + (Math.floor(Math.random() * 11) * 60 * 1000), 
                                    status: 'pending'
                                };
                                await dbHelper.add(CONSTANTS.STORE_NAMES.PENDING_ACTIONS, newAction);
                                // 5. 更新触发时间戳，防止短期内重复触发
                                await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, { value: Date.now() }, lastDiaryKey);
                            }
                        } catch (e) {
                            console.error(`为 [${dossier.character.name}] 生成自发日记失败:`, e);
                        }
                    })(); // <-- 立即执行这个异步的后台任务
                }
            }
        }
        // ^^^ 新增逻辑结束 ^^^

        if (dueActions.length === 0) return;

        console.log(`发现了 ${dueActions.length} 个到期任务，正在处理...`);

        for (const action of dueActions) {
            try {
                // 根据任务类型，分发给不同的“专家”
                switch (action.type) {
                    case 'comment_reply':
                        await handleCommentReplyAction(action.payload, action.dossierId);
                        break;
                        // vvv 【核心新增】处理“主动评论”任务的 case vvv
                    case 'moment_comment':
                        // 这个任务类型和“回复评论”非常相似，我们可以复用大部分逻辑
                        // 我们直接创建一个新的处理器函数来应对
                        await handleMomentCommentAction(action.payload, action.dossierId);
                        break;
                  // vvv 【新增】处理视频通话任务 vvv
                    case 'video_call_initiate':
                        await handleIncomingCall(action.dossierId, action.payload);
                        break;
// vvv 【新增】处理转账回应任务 vvv
                    case 'transfer_response':
                        await handleTransferResponse(action.payload);
                        break;
// vvv 在这里新增一个 case vvv
                     case 'secret_response':                                        
                         await
handleSecretResponseAction(action.payload, action.dossierId);
                         break;
                   // vvv 【新增这个 case】 vvv
                    case 'create_secret':
                        await handleSecretCreationAction(action.payload, action.dossierId);
                        break;
                    case 'create_diary': // <-- 【新增】处理日记任务的case
                        await handleDiaryCreationAction(action.payload, action.dossierId);
                        break;
                }
                // 任务成功，更新状态
                await dbHelper.updatePendingActionStatus(action.id, 'completed');
            } catch (error) {
                console.error(`处理任务 #${action.id} 失败:`, error);
                await dbHelper.updatePendingActionStatus(action.id, 'failed');
            }
        }
    },

    start() {
        if (this._intervalId) return; // 防止重复启动
        // 立即执行一次，以处理离线期间到期的任务
        this.processQueue();
       // 设置一个更长的、更省电的轮询间隔
        this._intervalId = setInterval(() => this.processQueue(), 3 * 60 * 1000); 
},

    stop() {
        clearInterval(this._intervalId);
        this._intervalId = null;
    }
};
// ^^^ 新模块到此结束 ^^^

// 【全新】在 ActionEngine 下方，添加日记任务的处理器函数
async function handleDiaryCreationAction(payload, dossierId) {
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return;

    try {
        const { title, content, mood } = payload;
        
        const aiDiary = {
            authorType: 'character',
            authorId: dossierId,
            title: title || '',
            content: content,
            mood: mood || 'normal',
            timestamp: Date.now(),
        };

        await dbHelper.add(CONSTANTS.STORE_NAMES.DIARIES, aiDiary);
        
        // 发送全局通知
        const avatarAsset = dossier.character.avatarAssetId ? await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId) : null;
        const avatarUrl = avatarAsset?.file ? URL.createObjectURL(avatarAsset.file) : null;
        
        notificationManager.show({
            avatarUrl,
            title: `${dossier.character.name} 更新了TA的日记`,
            message: title || content.substring(0, 30) + '...',
            
        });

        // 如果用户正好开着日记列表，则实时刷新
        if (DOM.diaryListModal.classList.contains('visible')) {
            await renderDiaryList();
        }

    } catch (error) {
        console.error(`[灵魂回响] 保存角色 [${dossier.character.name}] 的日记时失败:`, error);
    }
}

/**
         * 【全新】处理“回应心事”类型的待办任务
         * @param {object} payload - 任务的载荷
         * @param {number} dossierId - 执行此任务的角色ID
         */
    
        async function handleSecretResponseAction(payload, dossierId) {
            // 1. 从 payload 中解构出所有可能的信息
            const { userSecretId, responseContent, replyToId } = payload;

            const dossier = appState.dossiers.find(d => d.id === dossierId);
            if (!userSecretId || !dossier) {
                console.error(`[心事引擎] 无法处理回应，缺少原始心事ID或角色信息`);
                return;
            }

            try {
                // 2. 【核心修正】创建回应对象时，增加 authorId 字段
                const aiSecretResponse = {
                    parentId: userSecretId,
                    authorType: 'character',
                    authorId: dossierId, // <-- 【【【 这就是我们缺失的关键信息！ 】】】
                    authorName: dossier.character.name,
                    content: responseContent,
                    timestamp: Date.now(),
                    replyToId: replyToId || null
                };

                await dbHelper.add(CONSTANTS.STORE_NAMES.SECRETS, aiSecretResponse);
                console.log(`[心事引擎] ✅ 角色 [${dossier.character.name}] 已成功回应心事 #${userSecretId}`);

                // 3. 后续的通知和UI更新逻辑保持不变...
                const avatarAsset = dossier.character.avatarAssetId ? await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId) : null;
                const avatarUrl = avatarAsset?.file ? URL.createObjectURL(avatarAsset.file) : null;
                
                notificationManager.show({
                    avatarUrl,
                    title: `你收到一封来自 ${dossier.character.name} 的私密回应`,
                    message: responseContent,
                    onClick: null
                });
                
                // 【UI实时更新】如果用户正好在【详情页】，则刷新它
                if (DOM.secretDetailsModal.classList.contains('visible') && appState.currentViewingSecretId === userSecretId) {
                    await openSecretDetails(userSecretId);
                } 
                // 如果用户在【列表页】，则刷新列表
                else if (document.getElementById('secrets-pane').classList.contains('active')) {
                    await renderSecretsList();
                }

            } catch (error) {
                console.error(`[心事引擎] ❌ 角色 [${dossier.character.name}] 在保存回应时失败:`, error);
            }
        }

/**
 * 【全新抽离】处理所有“缓冲发送”行为的核心函数
 * @param {string | null} textContent - 如果是发表情，则传入表情代码；如果是点击羽毛笔，则为null。
 */
async function sendBufferedMessage(textContent = null) {
    const dossierId = appState.currentChattingDossierId;
    
    // 智能决定最终要发送的内容：优先使用传入的textContent，否则从输入框获取。
    const contentToSend = textContent !== null ? textContent : (DOM.chatInput.value.trim());

    // 校验：如果既没有有效内容，也没有引用任何消息，则不允许发送。
    if (!contentToSend && !appState.quotedMessage) return;
    if (!dossierId) return;

    // 1. 创建基础的用户消息对象
    const userMessage = { 
        dossierId, 
        sender: 'user', 
        content: contentToSend, 
        timestamp: Date.now() 
    };

    // 2. 如果当前有引用，将其信息附加到消息对象上
    if (appState.quotedMessage) {
        const dossier = appState.dossiers.find(d => d.id === dossierId);
        const authorName = appState.quotedMessage.sender === 'user'
            ? (dossier?.user.name || '你')
            : (dossier?.character.name || '角色');
        
        userMessage.quote = {
    author: authorName,
    content: appState.quotedMessage.content,
    sender: appState.quotedMessage.sender // <-- 新增这一行
};
        // 发送后立即关闭并清除引用状态
        DOM.closeReplyBtn.click(); 
    }

    // 3. 将完整的消息对象存入数据库并更新内存状态
    const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, userMessage);
    userMessage.id = savedId;
    const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
    appState.currentChatHistory.push(userMessage);

    // 4. 调用渲染函数，将新消息显示在屏幕上
    await renderMessage(userMessage, prevMessage);
    
    // 5. 更新会话列表的最后一条消息预览
    let lastMessageText = contentToSend;
    if (contentToSend.startsWith('[sticker:')) {
        // 如果是表情包，预览显示为 "[表情]"
        lastMessageText = '[表情]'; 
    } else if (!contentToSend && userMessage.quote) {
        // 如果是纯引用回复，预览显示为 "[回复]..."
        lastMessageText = `[回复] ${userMessage.quote.content}`;
    }
    await updateChatSession(dossierId, lastMessageText);
    
    // 6. 【关键】只在从羽毛笔按钮触发时（即textContent为null时），才清空输入框
    if (textContent === null) {
        DOM.chatInput.value = '';
        DOM.chatInput.focus();
    }
}

/**
 * 【全新】渲染日记列表的核心函数
 */
async function renderDiaryList() {
    const container = DOM.diaryListContainer;
    container.innerHTML = '<p style="opacity: 0.7; text-align: center;">正在翻阅...</p>';

    const allDiaries = await dbHelper.getAll(CONSTANTS.STORE_NAMES.DIARIES);
    if (allDiaries.length === 0) {
        container.innerHTML = '<p style="opacity: 0.7; text-align: center;">日记本还是空的，点击右上角“+”写下第一篇吧。</p>';
        return;
    }

    // 按时间倒序排列
    allDiaries.sort((a, b) => b.timestamp - a.timestamp);
    container.innerHTML = '';

    const moodIcons = {
        happy: '☀️', sad: '🌧️', thoughtful: '☁️', love: '🌙', normal: '😊'
    };

    for (const diary of allDiaries) {
        let authorName = '', avatarUrl = '';

        if (diary.authorType === 'user') {
            authorName = '我';
            // 从数据库获取全局用户头像
            const avatarSetting = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'global_user_avatar_asset_id');
            if (avatarSetting?.value) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarSetting.value);
                if(asset?.file) avatarUrl = URL.createObjectURL(asset.file);
            }
        } else {
            const dossier = appState.dossiers.find(d => d.id === diary.authorId);
            if (dossier) {
                authorName = dossier.character.name;
                if (dossier.character.avatarAssetId) {
                    const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                    if(asset?.file) avatarUrl = URL.createObjectURL(asset.file);
                }
            }
        }
        
        const card = document.createElement('div');
        // 复用 settings-item 的样式，它自带了边距、背景和hover效果
        card.className = 'settings-item'; 
        card.dataset.diaryId = diary.id;
        card.style.flexDirection = 'column';
        card.style.alignItems = 'flex-start';
        card.style.gap = '8px';
        card.style.cursor = 'pointer'; // 明确鼠标样式

        card.innerHTML = `
    <div style="width: 100%; display: flex; justify-content: space-between; align-items: center;">
        
        <!-- 左侧部分：头像和名字 -->
        <div style="display: flex; align-items: center; gap: 10px;">
            <div class="chat-avatar" style="width: 32px; height: 32px; background-image: url(${avatarUrl}); background-size: cover; background-position: center;"></div>
            <span style="font-weight: 600;">${authorName}</span>
        </div>
        
        <!-- vvv 【核心修改】右侧部分现在包含删除按钮和心情图标 vvv -->
        <div style="display: flex; align-items: center; gap: 15px;">
            <i class="delete-diary-btn ri-delete-bin-line" data-diary-id="${diary.id}" title="删除日记" style="font-size: 18px; opacity: 0.5; cursor: pointer;"></i>
            <span style="font-size: 20px;">${moodIcons[diary.mood] || '😊'}</span>
        </div>
        <!-- ^^^ 修改结束 ^^^ -->

    </div>

    <strong style="font-size: 16px; margin-left: 5px; margin-top: 8px;">${diary.title || '无标题'}</strong>
    <p style="margin: 0 0 0 5px; opacity: 0.7; font-size: 14px; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">${diary.content}</p>
    <span style="font-size: 12px; opacity: 0.5; align-self: flex-end;">${new Date(diary.timestamp).toLocaleDateString()}</span>
`;
        container.appendChild(card);
    }
}

/**
 * 【全新 V2 - 已修复用户日记无法打开的问题】
 * 打开并渲染阅读日记的浮窗
 * @param {number} diaryId - 要阅读的日记的ID
 */
async function openDiaryReadModal(diaryId) {
    const diary = await dbHelper.get(CONSTANTS.STORE_NAMES.DIARIES, diaryId);
    if (!diary) {
        utils.showToast('找不到这篇日记');
        return;
    }

    let authorName = '未知作者';
    let avatarUrl = '';

    // 【核心修正】在这里补全了对 user 类型的处理
    if (diary.authorType === 'user') {
        authorName = '我';
        const avatarSetting = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'global_user_avatar_asset_id');
        if (avatarSetting?.value) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarSetting.value);
            if(asset?.file) avatarUrl = URL.createObjectURL(asset.file);
        }
    } else { // authorType === 'character'
        const dossier = appState.dossiers.find(d => d.id === diary.authorId);
        if (dossier) {
            authorName = dossier.character.name;
            if (dossier.character.avatarAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
                if(asset?.file) avatarUrl = URL.createObjectURL(asset.file);
            }
        }
    }

    DOM.readDiaryTitle.textContent = diary.title || '无标题';
    
    const avatarHTML = avatarUrl 
        ? `<div class="chat-avatar" style="width: 36px; height: 36px; background-image: url(${avatarUrl}); background-size: cover; background-position: center;"></div>` 
        : '';

    DOM.readDiaryMeta.innerHTML = `
        ${avatarHTML}
        <div style="display: flex; flex-direction: column; gap: 2px;">
            <span style="font-weight: 600;">${authorName}</span>
            <span style="font-size: 13px; opacity: 0.7;">${formatRelativeTime(diary.timestamp)}</span>
        </div>
    `;
    DOM.readDiaryContent.textContent = diary.content;
    
    DOM.diaryReadModal.classList.add('visible');
}

// =======================================================
// ============ 电影模式 - 核心功能函数 ==================
// =======================================================

/**
 * 渲染“选角大厅”的角色海报墙
 */
async function renderMovieCharacterSelection() {
    DOM.moviePosterGrid.innerHTML = '';
    if (appState.dossiers.length === 0) {
        DOM.moviePosterGrid.innerHTML = `<p style="text-align:center; opacity:0.7; grid-column: 1 / 3;">还没有任何角色档案...</p>`;
        return;
    }

    for (const dossier of appState.dossiers) {
        const card = document.createElement('div');
        card.className = 'movie-poster-card';
        card.dataset.dossierId = dossier.id;

        let avatarUrl = '';
        if (dossier.character.avatarAssetId) {
            const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, dossier.character.avatarAssetId);
            if (asset?.file) avatarUrl = URL.createObjectURL(asset.file);
        }
        const avatarStyle = avatarUrl ? `style="background-image: url('${avatarUrl}')"` : '';

        card.innerHTML = `
            <div class="poster-image" ${avatarStyle}></div>
            <div class="poster-title">${dossier.character.name}</div>
        `;
        DOM.moviePosterGrid.appendChild(card);
    }
}

/**
 * 【V2.1 - 最终修复版】保存设置并开始/进入电影
 */
async function startMovie() {
            if (!appState.currentMovieSession?.dossierId) return;
            const dossierId = appState.currentMovieSession.dossierId;
            const dossier = appState.dossiers.find(d => d.id === dossierId);
            if (!dossier) return;

            // 从浮窗收集设置
            const openingPrompt = DOM.movieOpeningPrompt.value.trim();
            const responseLength = parseInt(DOM.movieResponseLength.value, 10) || 150;
            const selectedBookIds = [];
            
            // 【核心修改】从查找checkbox改为查找带有.selected类的chip
            DOM.movieLibrarySelectContainer.querySelectorAll('.book-chip.selected').forEach(chip => {
                selectedBookIds.push(parseInt(chip.dataset.bookId, 10));
            });

            // 将设置保存到数据库
            const sessionSettings = {
                dossierId, openingPrompt, responseLength, libraryBookIds: selectedBookIds
            };
            await dbHelper.set(CONSTANTS.STORE_NAMES.MOVIE_SESSIONS, sessionSettings);

            // 将完整的设置信息加载到内存
            const allBooks = await dbHelper.getAll(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS);
            appState.currentMovieSession = {
                ...sessionSettings,
                dossier,
                libraryBooks: allBooks.filter(book => selectedBookIds.includes(book.id))
            };

            // 关闭浮窗并导航到“放映室”
            DOM.movieSettingsModal.classList.remove('visible');
            DOM.movieCharacterName.textContent = dossier.character.name;
            navigateToPage(DOM.movieApp, 'movie-story-page');

            // 加载并渲染历史剧情
            DOM.movieScreenContainer.innerHTML = '';
            const history = await dbHelper.dbPromise.then(db => db.getAllFromIndex(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, 'by_dossierId', dossierId));
            history.forEach((turn, index) => renderMovieTurn(turn, index + 1));

            // 处理开场白逻辑
            if (history.length === 0 && openingPrompt) {
                const openingTurn = { 
                    dossierId, 
                    author: 'ai', 
                    content: openingPrompt, 
                    timestamp: Date.now() 
                };
                dbHelper.add(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, openingTurn);
                renderMovieTurn(openingTurn, 1);
                DOM.movieInput.value = '';
                DOM.movieInput.focus();
            }
        }

/**
 * 【全新】在“放映室”打开导演设置浮窗
 */
async function openMovieSettingsModal() {
            // 安全检查
            if (!appState.currentMovieSession?.dossierId) return;

            const { dossierId, openingPrompt, responseLength, libraryBookIds } = appState.currentMovieSession;
            
            // 填充表单
            DOM.movieOpeningPrompt.value = openingPrompt || '';
            DOM.movieResponseLength.value = responseLength || 150;

            // 【核心修改区域】填充图书馆书籍选择区
            const container = DOM.movieLibrarySelectContainer;
            container.innerHTML = '加载书籍中...';
            const allBooks = await dbHelper.getAll(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS);
            const linkedBookIds = new Set(libraryBookIds || []);
            container.innerHTML = '';

            if (allBooks.length === 0) {
                container.innerHTML = '<p style="opacity:0.7;">图书馆是空的</p>';
            } else {
                allBooks.forEach(book => {
                    const isSelected = linkedBookIds.has(book.id);
                    const chip = document.createElement('div');
                    chip.className = 'book-chip';
                    if (isSelected) {
                        chip.classList.add('selected');
                    }
                    chip.dataset.bookId = book.id;
                    
                    const categoryName = CONSTANTS.BOOK_CATEGORIES[book.category] || book.category;
                    chip.title = `分类: ${categoryName}`;

                    chip.innerHTML = `
                        <i class="ri-check-line selection-icon"></i>
                        <span>${book.title}</span>
                    `;
                    container.appendChild(chip);
                });
            }
            // 显示浮窗
            DOM.movieSettingsModal.classList.add('visible');
        }

/**
 * 【全新 V2】点击角色海报后，直接进入电影模式的主页面
 * @param {number} dossierId 
 */
async function enterMovieMode(dossierId) {
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return utils.showToast('找不到该角色档案');

    const sessionSettings = await dbHelper.get(CONSTANTS.STORE_NAMES.MOVIE_SESSIONS, dossierId) || { dossierId };

    const allBooks = await dbHelper.getAll(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS);
    const linkedBookIds = new Set(sessionSettings.libraryBookIds || []);
    appState.currentMovieSession = {
        dossierId,
        dossier,
        openingPrompt: sessionSettings.openingPrompt || '',
        responseLength: sessionSettings.responseLength || 150,
        libraryBookIds: Array.from(linkedBookIds),
        libraryBooks: allBooks.filter(book => linkedBookIds.has(book.id)),
        wallpaperAssetId: sessionSettings.wallpaperAssetId,
        styleSettings: sessionSettings.styleSettings || {} // <-- 【新增】加载风格设置
    };

    DOM.movieCharacterName.textContent = dossier.character.name;
    navigateToPage(DOM.movieApp, 'movie-story-page');

// vvv 【【【 全新的壁纸应用逻辑 】】】 vvv
            applyMovieStyles(appState.currentMovieSession.styleSettings); // 应用颜色风格
            
            const storyPage = DOM.movieStoryPage;
            storyPage.style.removeProperty('--movie-bg-image');
            if (appState.currentMovieSession.wallpaperAssetId) {
                const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, appState.currentMovieSession.wallpaperAssetId);
                if (asset?.file) {
                    const imageUrl = URL.createObjectURL(asset.file);
                    storyPage.style.setProperty('--movie-bg-image', `url('${imageUrl}')`);
                }
            }
    DOM.movieScreenContainer.innerHTML = '';
    const history = await dbHelper.dbPromise.then(db => db.getAllFromIndex(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, 'by_dossierId', dossierId));
    history.forEach((turn, index) => renderMovieTurn(turn, index + 1));

    if (history.length === 0 && appState.currentMovieSession.openingPrompt) {
        const openingTurn = { 
            dossierId, 
            author: 'ai', 
            content: appState.currentMovieSession.openingPrompt, 
            timestamp: Date.now() 
        };
        dbHelper.add(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, openingTurn);
        renderMovieTurn(openingTurn, 1);
        DOM.movieInput.value = '';
        DOM.movieInput.focus();
    }
}

/**
 * 渲染一轮剧情到屏幕上
 * @param {object} turn - { author: 'user'/'ai', content: '...' }
 */
function renderMovieTurn(turn, turnIndex) {
    const container = DOM.movieScreenContainer;
    
    // --- 步骤2: 创建卡片本身 ---
    const card = document.createElement('div');
    card.className = 'story-card';
    card.dataset.turnId = turn.id; // 将数据库ID存起来，方便操作

    // --- 步骤3: 创建卡片头部 ---
    const cardHeader = document.createElement('div');
    cardHeader.className = 'card-header';
    
    const headerInfo = `
        <div class="header-info">
            <span>#${turnIndex}</span>
            <span>${new Date(turn.timestamp).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'})}</span>
        </div>
    `;
    
    let headerActions = '';
    if (turn.author === 'ai') {
        headerActions = `
            <div class="header-actions">
                <i class="ri-pencil-line" title="编辑"></i>
                <i class="ri-refresh-line" title="重投"></i>
                <i class="ri-delete-bin-line" title="删除"></i>
            </div>
        `;
    } else { // 用户的回合
        headerActions = `
            <div class="header-actions">
                <i class="ri-pencil-line" title="编辑"></i>
                <i class="ri-delete-bin-line" title="删除"></i>
            </div>
        `;
    }
    cardHeader.innerHTML = headerInfo + headerActions;
    
    // --- 步骤4: 创建卡片主体 (包含颜色区分逻辑) ---
    const cardBody = document.createElement('div');
    cardBody.className = 'card-body';

    let processedContent = turn.content.replace(/\n/g, '<br>');
    processedContent = processedContent.replace(/\*([^*]+)\*/g, '<span class="thought">$1</span>'); // 不再保留星号
    processedContent = processedContent.replace(/“([^”]+)”/g, '<span class="dialogue">“$1”</span>');
    cardBody.innerHTML = processedContent;

    // --- 步骤5: 组装并渲染 ---
    card.append(cardHeader, cardBody);
    container.appendChild(card);
    container.scrollTop = container.scrollHeight;
}

/**
         * 【V2 - 支持呼吸灯】处理用户输入，推动剧情
         */
        async function handleMovieSend() {
            const userInput = DOM.movieInput.value.trim();
            if (!userInput || !appState.currentMovieSession) return;

            const { dossierId } = appState.currentMovieSession;

            // 1. 禁用输入，防止重复发送
            DOM.movieInput.disabled = true;
            DOM.movieSendBtn.disabled = true;
            DOM.movieInput.value = '';
            DOM.movieInput.placeholder = '导演正在思考...';
            
            // vvv 【【【 呼吸灯效果：开始 】】】 vvv
            DOM.movieInputCard.classList.add('waiting-for-reply');
            // ^^^ 效果开始 ^^^

            // 2. 保存并渲染用户的回合
            const userTurn = { dossierId, author: 'user', content: userInput, timestamp: Date.now() };
            const userTurnId = await dbHelper.add(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, userTurn);
            userTurn.id = userTurnId;
            
            const historyForCount = await dbHelper.dbPromise.then(db => db.getAllFromIndex(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, 'by_dossierId', dossierId));
            renderMovieTurn(userTurn, historyForCount.length);

            try {
                // 3. 准备AI的上下文...
                const history = await dbHelper.dbPromise.then(db => db.getAllFromIndex(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, 'by_dossierId', dossierId));
                const prompt = promptManager.createMoviePrompt(appState.currentMovieSession, history, userInput);
                
                // 4. 调用API...
                const aiResponse = await apiHelper.getChatCompletion(prompt);
                
                // 5. 保存并渲染AI的回合...
                const aiTurn = { dossierId, author: 'ai', content: aiResponse, timestamp: Date.now() };
                const aiTurnId = await dbHelper.add(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, aiTurn);
                aiTurn.id = aiTurnId;
                renderMovieTurn(aiTurn, historyForCount.length + 1);

            } catch (error) {
                console.error("电影模式AI回复失败:", error);
                utils.showToast(`导演罢工了: ${error.message}`);
                renderMovieTurn({ author: 'system', content: `[系统错误: ${error.message}]`});
            } finally {
                // 6. 恢复输入
                DOM.movieInput.disabled = false;
                DOM.movieSendBtn.disabled = false;
                DOM.movieInput.placeholder = '输入你的行动或对话...';
                DOM.movieInput.focus();
                
                // vvv 【【【 呼吸灯效果：结束 】】】 vvv
                DOM.movieInputCard.classList.remove('waiting-for-reply');
                // ^^^ 效果结束 ^^^
            }
        }

/**
 * 清空当前角色的电影剧情
 */
async function clearMovieHistory() {
    if (!appState.currentMovieSession?.dossierId) return;
    const dossierId = appState.currentMovieSession.dossierId;
    
    if (confirm("您确定要清空这部电影的所有剧情吗？此操作无法撤销。")) {
        try {
            const db = await dbHelper.dbPromise;
            const tx = db.transaction(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, 'readwrite');
            const index = tx.store.index('by_dossierId');
            let cursor = await index.openCursor(dossierId);
            while (cursor) {
                cursor.delete();
                cursor = await cursor.continue();
            }
            await tx.done;

            // 清空屏幕
            DOM.movieScreenContainer.innerHTML = '';
            
            utils.showToast('剧情已清空');
            
            // 【关键】清空后，重新执行开始逻辑，以应用可能的开场白
            startMovie();
            
        } catch (error) {
            console.error("清空剧情失败:", error);
            utils.showToast('清空失败');
        }
    }
}

/**
         * 【新增辅助】重新渲染整个电影屏幕
         * @param {number} dossierId 
         */
        async function rerenderMovieScreen(dossierId) {
            DOM.movieScreenContainer.innerHTML = ''; // 清空屏幕
            // 重新从数据库获取最新的、完整的历史记录
            const history = await dbHelper.dbPromise.then(db => db.getAllFromIndex(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, 'by_dossierId', dossierId));
            
            // 按照正确的顺序和楼层号重新渲染每一张卡片
            history.forEach((turn, index) => {
                renderMovieTurn(turn, index + 1);
            });
        }

        /**
         * 【新增逻辑】处理删除一个剧情回合
         * @param {number} turnId - 要删除的回合ID
         */
        async function handleMovieDelete(turnId) {
            if (!turnId || !confirm("您确定要删除这个剧情片段吗？")) return;

            try {
                // 1. 从数据库删除
                await dbHelper.delete(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, turnId);
                
                // 2. 重新渲染整个屏幕以更新楼层号和内容
                await rerenderMovieScreen(appState.currentMovieSession.dossierId);
                
                utils.showToast('剧情片段已删除');
            } catch (error) {
                console.error("删除剧情失败:", error);
                utils.showToast('删除失败');
            }
        }

        /**
         * 【V2 - 浮窗版】处理编辑一个剧情回合
         * @param {number} turnId - 要编辑的回合ID
         */
        async function handleMovieEdit(turnId) {
            if (!turnId) return;

            try {
                const turnToEdit = await dbHelper.get(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, turnId);
                if (!turnToEdit) return utils.showToast('找不到该剧情片段');

                // 1. 将要编辑的回合ID存入全局状态
                appState.currentEditingMovieTurnId = turnId;
                
                // 2. 将原始内容填入浮窗的文本域
                DOM.movieEditTextarea.value = turnToEdit.content;
                
                // 3. 显示浮窗
                DOM.movieEditModal.classList.add('visible');
                DOM.movieEditTextarea.focus(); // 自动聚焦

            } catch (error) {
                console.error("打开编辑浮窗失败:", error);
                utils.showToast('操作失败');
            }
        }

        /**
         * 【V2 - 支持呼吸灯】处理重投最新的AI剧情
         * @param {number} turnId - 要重投的AI回合ID
         */
        async function handleMovieRetry(turnId) {
            if (!turnId) return;

            DOM.movieInput.disabled = true;
            DOM.movieInput.placeholder = '导演正在紧急重拍...';
            utils.showToast('正在重新生成剧情...');
            
            // vvv 【【【 呼吸灯效果：开始 】】】 vvv
            DOM.movieInputCard.classList.add('waiting-for-reply');
            // ^^^ 效果开始 ^^^

            try {
                const history = await dbHelper.dbPromise.then(db => db.getAllFromIndex(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, 'by_dossierId', appState.currentMovieSession.dossierId));
                
                if (history.length === 0 || history[history.length - 1].id !== turnId) {
                    throw new Error("只能对最新的剧情进行重投。");
                }

                // 1. 删除最后一条AI的回复
                await dbHelper.delete(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, turnId);
                
                // 2. 获取新的历史记录
                const newHistory = history.slice(0, -1);
                const lastUserTurn = newHistory[newHistory.length - 1];
                
                // 3. 重新请求AI
                const prompt = promptManager.createMoviePrompt(appState.currentMovieSession, newHistory, lastUserTurn.content);
                const aiResponse = await apiHelper.getChatCompletion(prompt);
                
                // 4. 保存新的AI回合
                const aiTurn = { 
                    dossierId: appState.currentMovieSession.dossierId, 
                    author: 'ai', 
                    content: aiResponse, 
                    timestamp: Date.now() 
                };
                await dbHelper.add(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, aiTurn);

                // 5. 重新渲染整个屏幕
                await rerenderMovieScreen(appState.currentMovieSession.dossierId);

            } catch (error) {
                console.error("重投失败:", error);
                utils.showToast(`重投失败: ${error.message}`);
            } finally {
                DOM.movieInput.disabled = false;
                DOM.movieInput.placeholder = '输入你的行动或对话...';

                // vvv 【【【 呼吸灯效果：结束 】】】 vvv
                DOM.movieInputCard.classList.remove('waiting-for-reply');
                // ^^^ 效果结束 ^^^
            }
        }

/**
         * 【全新工具】将十六进制颜色码转换为 "R,G,B" 字符串
         * @param {string} hex - 例如 "#ff0000"
         * @returns {string} - 例如 "255,0,0"
         */
        function hexToRgbString(hex) {
            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? 
                `${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)}` 
                : '70,70,70'; // 如果转换失败，返回一个默认的灰色
        }

/**
         * 【全新核心】应用电影风格设置
         * @param {object} styles - 包含颜色值的样式对象
         */
        function applyMovieStyles(styles = {}) {
            // 【核心修正】从正确的 CONSTANTS 对象中读取默认值
            const s = { ...CONSTANTS.DEFAULT_MOVIE_STYLES, ...styles };
            const root = document.documentElement;
            root.style.setProperty('--movie-color-normal', s.normal);
            root.style.setProperty('--movie-color-thought', s.thought);
            root.style.setProperty('--movie-color-dialogue', s.dialogue);
            root.style.setProperty('--movie-color-user-input', s.userInput);
            root.style.setProperty('--movie-bg-input-bar-rgb', hexToRgbString(s.inputBarBg));
            root.style.setProperty('--movie-bg-send-btn', s.sendBtnBg);
            root.style.setProperty('--movie-color-send-btn', s.sendBtnText);
        }

        /**
         * 【全新核心】打开并填充导演风格设置浮窗
         */
        function openMovieStyleModal() {
            const currentStyles = appState.currentMovieSession?.styleSettings || {};
            // 【核心修正】从正确的 CONSTANTS 对象中读取默认值
            const styles = { ...CONSTANTS.DEFAULT_MOVIE_STYLES, ...currentStyles };

            // 将当前样式填充到颜色选择器中
            DOM.styleInputs.normal.value = styles.normal;
            DOM.styleInputs.thought.value = styles.thought;
            DOM.styleInputs.dialogue.value = styles.dialogue;
            DOM.styleInputs.userInput.value = styles.userInput;
            DOM.styleInputs.inputBarBg.value = styles.inputBarBg;
            DOM.styleInputs.sendBtnBg.value = styles.sendBtnBg;
            DOM.styleInputs.sendBtnText.value = styles.sendBtnText;

            DOM.movieStyleModal.classList.add('visible');
        }
        // =======================================================
        // ============== 4. 初始化和事件监听 (完整版) ===========
        // =======================================================
        
        function initializeEventListeners() {
           // 【新代码 1/3】点击爱心图标，现在只负责“打开/关闭”浮窗
DOM.themeToggle.addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡，这是避免浮窗立即关闭的关键
    DOM.themePopover.classList.toggle('visible');
});

// 【新代码 2/3】监听浮窗内部的点击，以执行真正的主题切换
DOM.themePopover.addEventListener('click', (e) => {
    const item = e.target.closest('.popover-item');
    if (!item) return; // 如果点的不是选项，则忽略

    const theme = item.dataset.theme;
    const isLight = theme === 'light';

    // 调用您已有的函数来应用主题
    applyTheme(isLight);
    // 保存用户的选择到本地存储
    localStorage.setItem('theme', isLight ? 'light' : 'dark');

    // 选择后，关闭浮窗
    DOM.themePopover.classList.remove('visible');
});

// 【新代码 3/3】监听整个页面的点击，实现“点击外部关闭浮窗”的功能
document.addEventListener('click', (e) => {
    // 如果浮窗是可见的，并且点击的目标不是浮窗自身，也不是打开浮窗的爱心图标
    if (DOM.themePopover.classList.contains('visible') && !DOM.themePopover.contains(e.target) && !DOM.themeToggle.contains(e.target)) {
        // 就关闭浮窗
        DOM.themePopover.classList.remove('visible');
    }
});
            let startX = 0, diffX = 0;
            DOM.swipeArea.addEventListener('touchstart', (e) => { startX = e.touches[0].clientX; }, { passive: true });
            DOM.swipeArea.addEventListener('touchmove', (e) => { diffX = e.touches[0].clientX - startX; }, { passive: true });
            DOM.swipeArea.addEventListener('touchend', () => {
                let newPageIndex = appState.desktopPageIndex;
                if (Math.abs(diffX) > 50) {
                    if (diffX < 0 && appState.desktopPageIndex < DOM.paginationDots.length - 1) newPageIndex++;
                    else if (diffX > 0 && appState.desktopPageIndex > 0) newPageIndex--;
                }
                goToDesktopPage(newPageIndex);
                diffX = 0;
            });
            DOM.playPauseBtn.addEventListener('click', () => {
                if (DOM.audioPlayer.paused) { DOM.audioPlayer.src ? DOM.audioPlayer.play() : playSong(appState.currentTrackIndex); } 
                else { DOM.audioPlayer.pause(); }
            });
            DOM.nextBtn.addEventListener('click', () => playSong((appState.currentTrackIndex + 1) % appState.playlist.length));
            DOM.prevBtn.addEventListener('click', () => playSong((appState.currentTrackIndex - 1 + appState.playlist.length) % appState.playlist.length));
            DOM.audioPlayer.addEventListener('play', updatePlayUI);
            DOM.audioPlayer.addEventListener('pause', updatePlayUI);
            DOM.audioPlayer.addEventListener('ended', () => {
                if (appState.loopMode === 'all') DOM.nextBtn.click();
                else if (appState.loopMode === 'none' && appState.currentTrackIndex < appState.playlist.length - 1) DOM.nextBtn.click();
                else { updatePlayUI(); resetToCustomSubtitle(); }
            });
            DOM.audioPlayer.addEventListener('timeupdate', () => {
                const { currentTime, duration } = DOM.audioPlayer;
                if (duration) {
                    DOM.progressFill.style.width = `${(currentTime / duration) * 100}%`;
                    DOM.currentTime.textContent = utils.formatTime(currentTime);
                    DOM.totalTime.textContent = utils.formatTime(duration);
                }
            });
            DOM.progressBar.addEventListener('click', (e) => { if (DOM.audioPlayer.duration) DOM.audioPlayer.currentTime = (e.offsetX / DOM.progressBar.clientWidth) * DOM.audioPlayer.duration; });
            DOM.loopBtn.addEventListener('click', () => {
                const modes = ['none', 'all', 'one'];
                const icons = ['ri-prohibited-line', 'ri-repeat-2-line', 'ri-repeat-one-line'];
                const nextModeIndex = (modes.indexOf(appState.loopMode) + 1) % modes.length;
                appState.loopMode = modes[nextModeIndex];
                DOM.loopBtn.className = icons[nextModeIndex];
                DOM.audioPlayer.loop = (appState.loopMode === 'one');
                dbHelper.set(CONSTANTS.STORE_NAMES.PLAYER_STATE, appState.loopMode, 'loop_mode');
            });
            DOM.shuffleBtn.addEventListener('click', () => {
                appState.isShuffle = !appState.isShuffle;
                DOM.shuffleBtn.style.color = appState.isShuffle ? '#1DB954' : '';
                const currentSongId = appState.playlist[appState.currentTrackIndex]?.id;
                if (appState.isShuffle) {
                    let current = appState.playlist[appState.currentTrackIndex];
                    let rest = appState.playlist.filter((_, i) => i !== appState.currentTrackIndex);
                    appState.playlist = [current, ...rest.sort(() => Math.random() - 0.5)];
                    appState.currentTrackIndex = 0;
                } else {
                    appState.playlist = [...appState.originalPlaylist];
                    appState.currentTrackIndex = currentSongId ? appState.playlist.findIndex(s => s.id === currentSongId) : 0;
                }
                dbHelper.set(CONSTANTS.STORE_NAMES.PLAYER_STATE, appState.isShuffle, 'is_shuffle');
            });
            DOM.addMusicBtn.addEventListener('click', () => DOM.addMusicModal.classList.add('visible'));
            DOM.closeMusicModalBtn.addEventListener('click', () => DOM.addMusicModal.classList.remove('visible'));
            DOM.addUrlBtn.addEventListener('click', async () => {
                const url = DOM.songUrlInput.value.trim();
                if (!url) return;
                const title = decodeURIComponent(url.split('/').pop()) || 'Untitled Track';
                await dbHelper.add(CONSTANTS.STORE_NAMES.PLAYLIST, { title, url, file: null });
                await renderPlaylist(); DOM.songUrlInput.value = '';
            });
            DOM.uploadLocalFileBtn.addEventListener('click', () => DOM.audioFileUploader.click());
            DOM.audioFileUploader.addEventListener('change', async e => {
                const file = e.target.files[0];
                if (file) await dbHelper.add(CONSTANTS.STORE_NAMES.PLAYLIST, { title: file.name, url: null, file: file });
                await renderPlaylist(); e.target.value = '';
            });
            DOM.playlistContainer.addEventListener('click', async e => {
                if (!e.target.matches('.ri-delete-bin-line')) return;
                const id = parseInt(e.target.dataset.id, 10);
                const isDeletingCurrent = appState.playlist[appState.currentTrackIndex]?.id === id;
                await dbHelper.delete(CONSTANTS.STORE_NAMES.PLAYLIST, id);
                if (isDeletingCurrent) {
                    DOM.audioPlayer.src = ''; updatePlayUI(); await resetToCustomSubtitle();
                    DOM.progressFill.style.width = '0%'; DOM.currentTime.textContent = '0:00'; DOM.totalTime.textContent = '0:00';
                }
                const currentId = !isDeletingCurrent ? appState.playlist[appState.currentTrackIndex]?.id : null;
                await renderPlaylist();
                appState.currentTrackIndex = currentId ? appState.playlist.findIndex(s => s.id === currentId) : 0;
            });
            DOM.playerAvatar.addEventListener('click', () => DOM.playerAvatarUploader.click());
            DOM.playerAvatarUploader.addEventListener('change', async e => {
                const file = e.target.files[0]; if (!file) return;
                try {
                    const compressedFile = await imageCompression(file, { maxSizeMB: 0.5, maxWidthOrHeight: 400 });
                    const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });
                    await dbHelper.set(CONSTANTS.STORE_NAMES.PLAYER_STATE, assetId, 'avatar_id');
                    DOM.playerAvatar.style.backgroundImage = `url(${URL.createObjectURL(compressedFile)})`;
                } catch (err) { console.error(err); }
            });
            DOM.playerCustomText.addEventListener('blur', () => dbHelper.set(CONSTANTS.STORE_NAMES.PLAYER_STATE, DOM.playerCustomText.textContent, 'custom_text'));
            DOM.playerSongTitle.addEventListener('blur', () => { if (DOM.playerSongTitle.isContentEditable) { dbHelper.set(CONSTANTS.STORE_NAMES.PLAYER_STATE, DOM.playerSongTitle.textContent, 'custom_subtitle'); } });
            DOM.calendarPrevBtn.addEventListener('click', () => { appState.calendarDate.setMonth(appState.calendarDate.getMonth() - 1); renderCalendar(); });
            DOM.calendarNextBtn.addEventListener('click', () => { appState.calendarDate.setMonth(appState.calendarDate.getMonth() + 1); renderCalendar(); });
            DOM.todoForm.addEventListener('submit', async (e) => {
                e.preventDefault(); const text = DOM.todoInput.value.trim();
                if (text) { appState.todos.push({ id: Date.now(), text, completed: false }); DOM.todoInput.value = ''; await saveTodos(); renderTodos(); }
            });
            DOM.todoList.addEventListener('click', async (e) => {
                const li = e.target.closest('.todo-item'); if (!li) return;
                const id = Number(li.dataset.id);
                if (e.target.type === 'checkbox') {
                    const todo = appState.todos.find(t => t.id === id);
                    if (todo) todo.completed = e.target.checked;
                    li.classList.toggle('completed', e.target.checked);
                } else if (e.target.classList.contains('delete-todo-btn')) {
                    appState.todos = appState.todos.filter(t => t.id !== id); li.remove();
                } else return;
                await saveTodos();
            });
            DOM.iconSettings.addEventListener('click', () => navigateToPage(DOM.settingsNavigator, 'settings-main-page'));
            DOM.gotoApiSettings.addEventListener('click', () => { navigateToPage(DOM.settingsNavigator, 'api-settings-page'); loadActiveApiPresetIntoForm(); });
            DOM.gotoAppearanceSettings.addEventListener('click', () => navigateToPage(DOM.settingsNavigator, 'appearance-settings-page'));
            DOM.settingsBackBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const target = e.target.closest('.back-button').dataset.target;
                    target === 'desktop' ? closeNavigator(DOM.settingsNavigator) : navigateToPage(DOM.settingsNavigator, target);
                });
            });
            DOM.fetchModelsButton.addEventListener('click', async () => {
                const url = DOM.apiUrlInput.value.trim(), key = DOM.apiKeyInput.value.trim(), name = DOM.apiNameInput.value.trim();
                if (!url || !key) return utils.showToast('请先输入 URL 和 Key。');
                if (!name) return utils.showToast('请先输入一个配置名称才能保存模型。');
                DOM.fetchModelsButton.textContent = '拉取中...'; DOM.fetchModelsButton.disabled = true;
                try {
                    let fetchUrl = url; if (!/^https?:\/\//i.test(fetchUrl)) fetchUrl = 'https://' + fetchUrl;
                    fetchUrl = fetchUrl.replace(/\/$/, "");
                    const modelsUrl = fetchUrl.endsWith('/v1') ? fetchUrl + '/models' : fetchUrl + '/v1/models';
                    const response = await fetch(modelsUrl, { headers: { 'Authorization': `Bearer ${key}` } });
                    if (!response.ok) throw new Error(`API 错误: ${response.statusText || response.status}`);
                    const { data } = await response.json();
                    const fetchedModels = data.map(m => ({ id: m.id }));
                    DOM.apiModelSelect.innerHTML = ''; fetchedModels.forEach(m => DOM.apiModelSelect.innerHTML += `<option value="${m.id}">${m.id}</option>`);
                    if (appState.loadedPresetModel) DOM.apiModelSelect.value = appState.loadedPresetModel;
                    const presetToUpdate = { name, url, key, model: DOM.apiModelSelect.value, models: fetchedModels };
                    await dbHelper.set(CONSTANTS.STORE_NAMES.API_PRESETS, presetToUpdate);
                    utils.showToast('模型已拉取并保存！');
                } catch (error) { utils.showToast(`拉取模型失败: ${error.message}`); DOM.apiModelSelect.innerHTML = '<option value="">拉取失败</option>'; } finally { DOM.fetchModelsButton.textContent = '拉取'; DOM.fetchModelsButton.disabled = false; }
            });
            DOM.saveApiSettingsButton.addEventListener('click', async () => {
                const name = DOM.apiNameInput.value.trim(), url = DOM.apiUrlInput.value.trim(), key = DOM.apiKeyInput.value.trim(), model = DOM.apiModelSelect.value;
                if (!name || !url || !key) return utils.showToast('请填写所有字段！');
                const existingPreset = await dbHelper.get(CONSTANTS.STORE_NAMES.API_PRESETS, name) || {};
                const presetToSave = { ...existingPreset, name, url, key, model };
                await dbHelper.set(CONSTANTS.STORE_NAMES.API_PRESETS, presetToSave);
                await populateApiPresets(); utils.showToast(`配置 "${name}" 已保存！`);
            });
            DOM.setActiveApiButton.addEventListener('click', async () => {
                const name = DOM.apiNameInput.value.trim(); if(!name) return utils.showToast("配置名称不能为空！");
                const preset = await dbHelper.get(CONSTANTS.STORE_NAMES.API_PRESETS, name);
                if(!preset) return utils.showToast(`配置 "${name}" 不存在，请先保存。`);
                await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, name, 'active_api_preset');
                appState.activeApiPreset = preset;
                await populateApiPresets(); utils.showToast(`"${name}" 已设为当前 API 配置。`);
            });
            DOM.loadPresetButton.addEventListener('click', async () => {
                const preset = await dbHelper.get(CONSTANTS.STORE_NAMES.API_PRESETS, DOM.apiPresetSelect.value);
                if (preset) {
                    DOM.apiNameInput.value = preset.name; DOM.apiUrlInput.value = preset.url; DOM.apiKeyInput.value = preset.key;
                    DOM.apiModelSelect.innerHTML = '<option value="">-- 先拉取模型 --</option>'; appState.loadedPresetModel = preset.model || null;
                }
            });
            DOM.deletePresetButton.addEventListener('click', async () => {
                const name = DOM.apiPresetSelect.value; if (!name || !confirm(`确定删除 "${name}" 吗？`)) return;
                const activePreset = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'active_api_preset');
                if (activePreset === name) { await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, null, 'active_api_preset'); appState.activeApiPreset = null; }
                await dbHelper.delete(CONSTANTS.STORE_NAMES.API_PRESETS, name);
                if (DOM.apiNameInput.value === name) {
                    DOM.apiNameInput.value = ''; DOM.apiUrlInput.value = ''; DOM.apiKeyInput.value = '';
                    DOM.apiModelSelect.innerHTML = '<option>-- 先拉取模型 --</option>';
                }
                await populateApiPresets(); utils.showToast(`配置 "${name}" 已删除。`);
            });
            DOM.iconArchive.addEventListener('click', () => { navigateToPage(DOM.archiveApp, 'main-archive-page'); renderDossiers(); });
            DOM.archiveBackBtns.forEach(btn => { btn.addEventListener('click', e => { const target = e.target.closest('.back-button').dataset.target; target === 'desktop' ? closeNavigator(DOM.archiveApp) : navigateToPage(DOM.archiveApp, target); }); });
            DOM.addDossierBtn.addEventListener('click', () => { resetCreationForm(); navigateToPage(DOM.archiveApp, 'creation-page'); });
            DOM.charAvatarArea.addEventListener('click', () => DOM.charAvatarUploader.click());
            DOM.charAvatarUploader.addEventListener('change', async (e) => { const assetId = await handleAvatarUpload(e.target.files[0], DOM.charAvatarArea); if (assetId) appState.currentCharacterAvatarAssetId = assetId; e.target.value = ''; });
            DOM.userAvatarArea.addEventListener('click', () => DOM.userAvatarUploader.click());
            DOM.userAvatarUploader.addEventListener('change', async (e) => { const assetId = await handleAvatarUpload(e.target.files[0], DOM.userAvatarArea); if (assetId) appState.currentUserAvatarAssetId = assetId; e.target.value = ''; });
            DOM.saveDossierBtn.addEventListener('click', async () => {
                const characterName = DOM.charNameInput.value.trim(); const characterBackground = DOM.charBgInput.value.trim();
                if (!characterName || !characterBackground) return utils.showToast('角色的姓名和人设背景不能为空！');
                DOM.saveDossierBtn.disabled = true;
                try {
                    if (appState.currentEditingDossierId) {
                        DOM.saveDossierBtn.textContent = '保存中...';
                        const originalDossier = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, appState.currentEditingDossierId);
                        const updatedDossier = {
                            ...originalDossier, id: appState.currentEditingDossierId,
                            character: { name: characterName, background: characterBackground, avatarAssetId: appState.currentCharacterAvatarAssetId },
                            user: { name: DOM.userNameInput.value.trim(), background: DOM.userBgInput.value.trim(), avatarAssetId: appState.currentUserAvatarAssetId }
                        };
                        await dbHelper.set(CONSTANTS.STORE_NAMES.DOSSIERS, updatedDossier); utils.showToast('档案已更新！');
                    } else {
                        DOM.saveDossierBtn.textContent = '生成中...';
                        const generatedData = await apiHelper.generateDossierDetails(characterName, characterBackground);
                        const newDossier = {
                            character: { name: characterName, background: characterBackground, avatarAssetId: appState.currentCharacterAvatarAssetId },
                            user: { name: DOM.userNameInput.value.trim(), background: DOM.userBgInput.value.trim(), avatarAssetId: appState.currentUserAvatarAssetId },
                            aiGenerated: generatedData,
libraryBookIds: [] // <-- 【新增】为新档案初始化一个空数组
                        };
                        await dbHelper.add(CONSTANTS.STORE_NAMES.DOSSIERS, newDossier); utils.showToast('档案已生成！');
                    }
                    navigateToPage(DOM.archiveApp, 'main-archive-page'); renderDossiers();
                } catch (error) { utils.showToast(`操作失败: ${error.message}`); } finally { DOM.saveDossierBtn.disabled = false; }
            });
            DOM.deleteDossierBtn.addEventListener('click', async () => {
                if (!appState.currentEditingDossierId) return;
                const dossierToDelete = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, appState.currentEditingDossierId);
                const characterName = dossierToDelete?.character?.name || '该档案';
                if (confirm(`您确定要删除 "${characterName}" 的档案吗？此操作无法撤销。`)) {
                    await dbHelper.delete(CONSTANTS.STORE_NAMES.DOSSIERS, appState.currentEditingDossierId);
                    utils.showToast(`档案 "${characterName}" 已删除。`);
                    navigateToPage(DOM.archiveApp, 'main-archive-page'); renderDossiers();
                }
            });
            DOM.archiveList.addEventListener('click', e => { const folder = e.target.closest('.dossier-folder'); if (folder) openDossierModal(Number(folder.dataset.id)); });
            DOM.closeDossierBtn.addEventListener('click', () => DOM.dossierModalOverlay.classList.remove('visible'));
            DOM.dossierModalOverlay.addEventListener('click', e => { if (e.target === DOM.dossierModalOverlay) DOM.dossierModalOverlay.classList.remove('visible'); });
            DOM.editDossierBtn.addEventListener('click', () => { if (appState.currentEditingDossierId) { DOM.dossierModalOverlay.classList.remove('visible'); loadDossierForEditing(appState.currentEditingDossierId); } });
            DOM.iconChat.addEventListener('click', () => { renderChatList(); navigateToPage(DOM.chatApp, 'chat-main-page'); });
           // vvv 用这个【增加了“心事”分支】的最终版，替换旧的 chatTabItems 监听器 vvv
        DOM.chatTabItems.forEach(tab => {
            tab.addEventListener('click', async () => { // <--- 关键：将函数改为 async
                DOM.chatTabItems.forEach(item => item.classList.remove('active'));
                DOM.chatContentPanes.forEach(pane => pane.classList.remove('active'));
                
                tab.classList.add('active');
                const targetPaneId = tab.dataset.target;
                document.getElementById(targetPaneId).classList.add('active');
                DOM.chatHeaderTitle.textContent = tab.dataset.title;

                // --- 【核心修正】在这里添加 else if 分支 ---
                if (targetPaneId === 'moments-pane') {
                    await renderMoments();
                } else if (targetPaneId === 'secrets-pane') {
    await renderSecretsList();
                } else if (targetPaneId === 'memories-pane') { 
    await renderMemoryCharacterList();
              }
                // --- 修正结束 ---
            });
        });
// ^^^ 替换到此结束 ^^^
            // vvv 用这个【增加了“心事”分支】的升级版，替换旧的 newChatBtn 监听器 vvv
        DOM.newChatBtn.addEventListener('click', () => {
            const activeTab = document.querySelector('#app-chat .tab-item.active');
            const activePaneId = activeTab?.dataset.target;

            if (activePaneId === 'moments-pane') {
                // 如果在动态页，则打开动态发布器
                navigateToPage(DOM.momentCreatorApp, 'moment-creation-page');
            } else if (activePaneId === 'dialogue-pane') {
                // 如果在对话页，则打开新建聊天窗口
                populateCharacterSelectModal();
                DOM.newChatModal.classList.add('visible');
            } else if (activePaneId === 'secrets-pane') {
                // 【核心新增】如果是在心事页，则打开写心事页面
                navigateToPage(DOM.chatApp, 'secrets-creation-page');
            } else if (activePaneId === 'memories-pane') {
        // 当在回忆主页时，点击全局+号，显示我们新的提示语
        utils.showToast('请进入具体角色的回忆页进行添加');
        // 使用 return; 确保后续代码不会执行
        return; 
    // ^^^ 修改结束 ^^^

    } else { 
        // 保留这个最后的else，用于处理未来可能新增的其他页面
        utils.showToast("该功能正在施工中...");
            }
        });
        // ^^^ 替换到此结束 ^^^
            DOM.closeChatModalBtn.addEventListener('click', () => DOM.newChatModal.classList.remove('visible'));
            DOM.newChatModal.addEventListener('click', (e) => { if (e.target === DOM.newChatModal) DOM.newChatModal.classList.remove('visible'); });
            DOM.characterSelectList.addEventListener('click', (e) => { const selectedCharacter = e.target.closest('.character-select-item'); if (selectedCharacter) { const dossierId = parseInt(selectedCharacter.dataset.dossierId, 10); startNewChat(dossierId); } });
            DOM.chatList.addEventListener('click', (e) => { const targetItem = e.target.closest('.chat-list-item'); if(targetItem) { const dossierId = parseInt(targetItem.dataset.dossierId, 10); openChatWindow(dossierId); } });
            // vvv 用这个【全新的】sendBufferBtn监听器，完整替换旧版本 vvv
    DOM.sendBufferBtn.addEventListener('click', () => {
        // 调用我们全新的、强大的核心函数，不传入任何参数
        sendBufferedMessage(); 
    });
            DOM.sendFinalBtn.addEventListener('click', handleSendMessage);
            DOM.chatMoreBtn.addEventListener('click', () => {
    const dossier = appState.dossiers.find(d => d.id === appState.currentChattingDossierId);
    updateLinkedBooksDisplay(dossier);
    navigateToPage(DOM.chatApp, 'chat-details-page');
});
            DOM.uploadWidgets.forEach(target => {
                target.addEventListener('click', (e) => {
                    if (e.target.closest('.music-player-controls') || e.target.closest('.music-player-info') || e.target.closest('.todo-container')) return;
                    appState.currentWidgetUploadTarget = target; appState.currentIconUploadTargetId = null;
                    DOM.imageUploader.click();
                });
            });
            DOM.setWallpaperItem.addEventListener('click', () => DOM.wallpaperUploader.click());
            DOM.wallpaperUploader.addEventListener('change', async (e) => {
                const file = e.target.files[0]; if (!file) return;
                try {
                    const compressedFile = await imageCompression(file, { maxSizeMB: 8, initialQuality: 0.95 });
                    const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });
                    await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, assetId, 'wallpaper_asset_id');
                    DOM.body.style.backgroundImage = `url('${URL.createObjectURL(compressedFile)}')`;
                } catch (err) { console.error('Wallpaper processing failed', err); }
                e.target.value = '';
            });
            DOM.gotoIconSettings.addEventListener('click', () => { navigateToPage(DOM.settingsNavigator, 'icon-settings-page'); populateIconGrid(); });
            DOM.iconSettingsGrid.addEventListener('click', (e) => {
                const targetItem = e.target.closest('.icon-setting-item');
                if (targetItem) { appState.currentIconUploadTargetId = targetItem.dataset.iconId; appState.currentWidgetUploadTarget = null; DOM.imageUploader.click(); }
            });
            DOM.gotoFontSettings.addEventListener('click', () => { navigateToPage(DOM.settingsNavigator, 'font-settings-page'); populateFontPresets(); });
            DOM.applyFontButton.addEventListener('click', async () => {
                const name = DOM.fontNameInput.value.trim(), url = DOM.fontUrlInput.value.trim();
                if (!name || !url) return utils.showToast('请填写字体名称和 URL！');
                try { new URL(url); } catch { return utils.showToast('请输入有效的 URL！'); }
                applyFont(url);
                const presets = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'font_presets') || {};
                presets[name] = url;
                await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, presets, 'font_presets');
                await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, { name, url }, 'active_font_config');
                await populateFontPresets(); DOM.fontPresetSelect.value = name;
                utils.showToast(`字体 "${name}" 已应用并保存！`);
            });
            DOM.clearFontButton.addEventListener('click', async () => {
                applyFont(null); await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, null, 'active_font_config');
                DOM.fontNameInput.value = ''; DOM.fontUrlInput.value = ''; DOM.fontPresetSelect.value = '';
                utils.showToast('已清除自定义字体。');
            });
            DOM.loadFontButton.addEventListener('click', async () => {
                const selectedName = DOM.fontPresetSelect.value; if (!selectedName) return;
                const presets = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'font_presets') || {};
                const url = presets[selectedName];
                if (url) { DOM.fontNameInput.value = selectedName; DOM.fontUrlInput.value = url; }
            });
            DOM.deleteFontButton.addEventListener('click', async () => {
                const selectedName = DOM.fontPresetSelect.value;
                if (!selectedName || !confirm(`确定要删除字体 "${selectedName}" 吗？`)) return;
                const presets = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'font_presets') || {};
                delete presets[selectedName];
                await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, presets, 'font_presets');
                const activeFont = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'active_font_config');
                if (activeFont && activeFont.name === selectedName) { await DOM.clearFontButton.click(); }
                if (DOM.fontNameInput.value === selectedName) { DOM.fontNameInput.value = ''; DOM.fontUrlInput.value = ''; }
                await populateFontPresets(); utils.showToast(`字体 "${selectedName}" 已删除。`);
            });
            DOM.fontSizeSlider.addEventListener('input', () => applyFontSize(DOM.fontSizeSlider.value));
            DOM.fontSizeSlider.addEventListener('change', () => dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, DOM.fontSizeSlider.value, 'font_size'));
            DOM.imageUploader.addEventListener('change', async (event) => {
                const file = event.target.files[0]; if (!file) return;
                if (appState.currentWidgetUploadTarget) {
                    const widget = appState.currentWidgetUploadTarget;
                    try {
                        const compressedFile = await imageCompression(file, { maxSizeMB: 1, maxWidthOrHeight: 1920 });
                        const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });
                        const backgrounds = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'widget_backgrounds') || {};
                        backgrounds[widget.id] = assetId;
                        await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, backgrounds, 'widget_backgrounds');
                        widget.style.backgroundImage = `url('${URL.createObjectURL(compressedFile)}')`; widget.classList.add('has-bg-image');
                    } catch (error) { utils.showToast('图片处理失败！'); }
                    appState.currentWidgetUploadTarget = null;
                } else if (appState.currentIconUploadTargetId) {
                    const iconId = appState.currentIconUploadTargetId;
                    try {
                        const compressedFile = await imageCompression(file, { maxSizeMB: 0.2, maxWidthOrHeight: 200 });
                        const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });
                        const iconOverrides = await dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'icon_overrides') || {};
                        iconOverrides[iconId] = assetId;
                        await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, iconOverrides, 'icon_overrides');
                        document.getElementById(iconId).style.backgroundImage = `url(${URL.createObjectURL(compressedFile)})`;
                        document.getElementById(iconId).classList.add('has-bg-image');
                        const previewEl = DOM.iconSettingsGrid.querySelector(`.icon-setting-item[data-icon-id="${iconId}"] .icon-preview`);
                        if (previewEl) { previewEl.innerHTML = ''; previewEl.style.backgroundImage = `url(${URL.createObjectURL(compressedFile)})`; }
                        utils.showToast("图标已更新！");
                    } catch (error) { utils.showToast("图标更新失败！"); }
                    appState.currentIconUploadTargetId = null;
                }
                event.target.value = '';
            });
// vvv 在这里新增一个事件监听 vvv
    DOM.setChatWallpaperItem.addEventListener('click', () => {
    // 修改为触发我们新增的、专用的聊天壁纸上传器
    DOM.chatWallpaperUploader.click();
});

// vvv 在下面添加全新的事件监听逻辑 vvv
            DOM.chatWallpaperUploader.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // 获取当前正在聊天的角色ID
                const currentDossierId = appState.currentChattingDossierId;
                if (!currentDossierId) {
                    utils.showToast('错误：没有活动的聊天窗口！');
                    return; // 如果不知道是为哪个聊天设置壁纸，则无法保存
                }

                try {
                    // 像之前一样压缩图片
                    const compressedFile = await imageCompression(file, { maxSizeMB: 2, initialQuality: 0.9 });
                    // 将图片文件存入 assets 表，以获取一个唯一的 assetId
                    const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });

                    // 【核心改动】
                    // 从数据库获取当前角色的具体档案
                    const dossierToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, currentDossierId);
                    if (dossierToUpdate) {
                        // 直接在档案对象上添加/更新 wallpaperAssetId 属性
                        dossierToUpdate.wallpaperAssetId = assetId; 
                        // 将整个修改后的档案对象存回数据库
                        await dbHelper.set(CONSTANTS.STORE_NAMES.DOSSIERS, dossierToUpdate); 
// vvv 在这里添加新的同步逻辑 vvv
                        // 找到当前角色在内存数组 appState.dossiers 中的位置
                        const dossierIndexInState = appState.dossiers.findIndex(d => d.id === currentDossierId);
                        if (dossierIndexInState > -1) {
                            // 用包含了壁纸信息的新数据，更新内存中的旧数据
                            appState.dossiers[dossierIndexInState] = dossierToUpdate;
                        }
                        // ^^^ 新逻辑结束 ^^^

                    } else {
                        throw new Error('在数据库中找不到当前角色的档案。');
                    }
                    
                    // 立即将新壁纸应用到当前的聊天窗口
                   const imageUrl = URL.createObjectURL(compressedFile);
DOM.chatDialoguePage.style.backgroundImage = `url('${imageUrl}')`; // <-- 修改目标
DOM.chatDialoguePage.style.backgroundSize = 'cover'; // <-- 修改目标
DOM.chatDialoguePage.style.backgroundPosition = 'center'; // <-- 修改目标
                    
                    utils.showToast('聊天壁纸已更新！');

                } catch (err) {
                    console.error('Chat wallpaper processing failed', err);
                    utils.showToast(`壁纸处理失败: ${err.message}`);
                }
                // 重置上传器
                e.target.value = '';
            });

// 监听“记忆轮数”按钮点击，用于打开浮窗
    DOM.setMemoryRoundsItem.addEventListener('click', () => {
        const dossierId = appState.currentChattingDossierId;
        if (!dossierId) return;

        const dossier = appState.dossiers.find(d => d.id === dossierId);
        if (dossier) {
            // 读取已保存的轮数，如果没有则默认为20
            const currentRounds = dossier.memoryRounds || 20;
            DOM.memoryRoundsSlider.value = currentRounds;
            DOM.memoryRoundsValue.textContent = currentRounds;
            DOM.memoryRoundsModal.classList.add('visible');
        }
    });

    // 实时更新滑块数值显示
    DOM.memoryRoundsSlider.addEventListener('input', () => {
        DOM.memoryRoundsValue.textContent = DOM.memoryRoundsSlider.value;
    });

    // 保存按钮的逻辑
    DOM.saveMemoryRoundsBtn.addEventListener('click', async () => {
        const dossierId = appState.currentChattingDossierId;
        const newRounds = parseInt(DOM.memoryRoundsSlider.value, 10);

        if (!dossierId) return;

        try {
            // 1. 从数据库获取最新的档案
            const dossierToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, dossierId);
            if (dossierToUpdate) {
                // 2. 更新轮数
                dossierToUpdate.memoryRounds = newRounds;
                // 3. 保存回数据库
                await dbHelper.set(CONSTANTS.STORE_NAMES.DOSSIERS, dossierToUpdate);

                // 4. 【重要】同步更新内存中的数据
                const dossierIndexInState = appState.dossiers.findIndex(d => d.id === dossierId);
                if (dossierIndexInState > -1) {
                    appState.dossiers[dossierIndexInState] = dossierToUpdate;
                }

                utils.showToast(`记忆轮数已保存为 ${newRounds}！`);
                DOM.memoryRoundsModal.classList.remove('visible');
            }
        } catch (error) {
            utils.showToast(`保存失败: ${error.message}`);
        }
    });

    // 关闭浮窗的逻辑
    const closeMemoryModal = () => DOM.memoryRoundsModal.classList.remove('visible');
    DOM.closeMemoryRoundsBtn.addEventListener('click', closeMemoryModal);
    DOM.memoryRoundsModal.addEventListener('click', (e) => {
        if (e.target === DOM.memoryRoundsModal) {
            closeMemoryModal();
        }
    });

// vvv 在这里添加全新的开关监听逻辑 vvv
    DOM.timePerceptionToggle.addEventListener('change', async () => {
        const dossierId = appState.currentChattingDossierId;
        const isEnabled = DOM.timePerceptionToggle.checked;

        if (!dossierId) return;

        try {
            const dossierToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, dossierId);
            if (dossierToUpdate) {
                dossierToUpdate.timePerceptionEnabled = isEnabled;
                await dbHelper.set(CONSTANTS.STORE_NAMES.DOSSIERS, dossierToUpdate);

                const dossierIndexInState = appState.dossiers.findIndex(d => d.id === dossierId);
                if (dossierIndexInState > -1) {
                    appState.dossiers[dossierIndexInState] = dossierToUpdate;
                }

                utils.showToast(`时间感知已${isEnabled ? '开启' : '关闭'}`);
            }
        } catch (error) {
            utils.showToast(`设置失败: ${error.message}`);
            // 如果保存失败，把开关拨回原样
            DOM.timePerceptionToggle.checked = !isEnabled;
        }
    });

 // vvv 在这里添加全新的置顶开关监听逻辑 vvv
    DOM.pinChatToggle.addEventListener('change', async () => {
        const dossierId = appState.currentChattingDossierId;
        const isPinned = DOM.pinChatToggle.checked;

        if (!dossierId) return;

        try {
            const dossierToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, dossierId);
            if (dossierToUpdate) {
                dossierToUpdate.isPinned = isPinned;
                await dbHelper.set(CONSTANTS.STORE_NAMES.DOSSIERS, dossierToUpdate);

                const dossierIndexInState = appState.dossiers.findIndex(d => d.id === dossierId);
                if (dossierIndexInState > -1) {
                    appState.dossiers[dossierIndexInState] = dossierToUpdate;
                }

                // 【关键】立即重新渲染聊天列表，让置顶/取消置顶的效果马上可见
                await renderChatList();

                utils.showToast(`聊天已${isPinned ? '置顶' : '取消置顶'}`);
            }
        } catch (error) {
            utils.showToast(`设置失败: ${error.message}`);
            DOM.pinChatToggle.checked = !isPinned;
        }
    });

// vvv 用这个修正后的版本，替换掉旧的 clearHistoryBtn 监听器 vvv
        DOM.clearHistoryBtn.addEventListener('click', async () => {
            const dossierId = appState.currentChattingDossierId;
            if (!dossierId) return;

            const dossier = appState.dossiers.find(d => d.id === dossierId);
            const characterName = dossier?.character.name || '该角色';

            // 弹出原生确认框
            if (confirm(`您确定要清空与“${characterName}”的所有聊天记录吗？此操作无法撤销。`)) {
                try {
                    // 1. 从数据库删除这个角色的所有历史记录
                    await dbHelper.deleteHistoryForDossier(dossierId);

                    // 2. 清空内存中的当前聊天历史
                    appState.currentChatHistory = [];

                    // 3. 【核心修正】清空屏幕上的消息容器
                    DOM.messagesContainer.innerHTML = '';
                    
                    // 4. 在屏幕上显示一条系统提示
                    await renderMessage({ content: '聊天记录已清空', sender: 'system' });

                    // 5. 更新会话列表的最后一条消息为提示语（这会在后台完成，不影响当前页面）
                    await updateChatSession(dossierId, '聊天记录已清空');
                    
                    utils.showToast(`与“${characterName}”的聊天记录已清空`);

                 // 6. 【核心修正】在所有操作完成后，导航返回到聊天对话页面
                    navigateToPage(DOM.chatApp, 'chat-dialogue-page');


                } catch (error) {
                    utils.showToast(`清空失败: ${error.message}`);
                }
            }
        });

// vvv 用这个【更新了警告语】的最终版本，替换掉旧的监听器 vvv
        DOM.deleteConversationBtn.addEventListener('click', async () => {
            const dossierId = appState.currentChattingDossierId;
            if (!dossierId) return;

            const dossier = appState.dossiers.find(d => d.id === dossierId);
            const characterName = dossier?.character.name || '该角色';

            // 【核心修正】使用更准确、更清晰的警告语
            if (confirm(`【警告】您确定要永久删除与“${characterName}”的对话吗？\n\n这将导致：\n- 从对话列表中移除该角色\n- 彻底清空所有聊天记录\n- 重置您为此对话设置的壁纸、记忆轮数等所有个性化选项\n\n角色档案本身【不会】被删除，您之后可以重新发起对话。此操作无法撤销。`)) {
                try {
                    // 1. 调用数据库函数，删除会话和历史记录
                    await dbHelper.deleteConversationData(dossierId);

                    // 2. 从内存中只移除【会话】
                    appState.chatSessions = appState.chatSessions.filter(s => s.dossierId !== dossierId);
                    
                    // 3. 更新档案本身，移除个性化设置
                    const dossierToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.DOSSIERS, dossierId);
                    if (dossierToUpdate) {
                        delete dossierToUpdate.wallpaperAssetId;
                        delete dossierToUpdate.memoryRounds;
                        delete dossierToUpdate.timePerceptionEnabled;
                        delete dossierToUpdate.isPinned;
                        await dbHelper.set(CONSTANTS.STORE_NAMES.DOSSIERS, dossierToUpdate);
                        
                        const dossierIndexInState = appState.dossiers.findIndex(d => d.id === dossierId);
                        if (dossierIndexInState > -1) {
                            appState.dossiers[dossierIndexInState] = dossierToUpdate;
                        }
                    }

                    // 4. 重新渲染聊天列表
                    await renderChatList();
                    
                    utils.showToast(`与“${characterName}”的对话已删除`);

                    // 5. 立即返回到聊天列表页面
                    navigateToPage(DOM.chatApp, 'chat-main-page');

                } catch (error) {
                    utils.showToast(`删除失败: ${error.message}`);
                }
            }
        });

// vvv 用下面的完整代码块，替换所有旧的菜单监听逻辑 vvv
        DOM.messagesContainer.addEventListener('click', (e) => {
            const targetMessage = e.target.closest('.chat-message');
            
            // 如果在多选模式下，单击任何消息（或其内部的复选框）都视为“切换选中状态”
            if (appState.isMultiSelectMode) {
                if (targetMessage) {
                    const messageId = parseInt(targetMessage.dataset.messageId, 10);
                    if (messageId) {
                        toggleMessageSelection(messageId);
                    }
                }
                return; // 在多选模式下，不执行后续的菜单逻辑
            }

            // --- 以下是正常的、非多选模式下的单击出菜单逻辑 ---
            const targetBubble = e.target.closest('.bubble');
            if (!targetBubble) {
                return;
            }
            
            openBubbleMenu(targetBubble);
            e.stopPropagation(); 
        });

        // --- 菜单关闭逻辑 (保持不变) ---
        document.addEventListener('click', (e) => {
            if (appState.longPressedBubble && !DOM.bubblePopoverMenu.contains(e.target)) {
                closeBubbleMenu();
            }
        });
        DOM.messagesContainer.addEventListener('scroll', closeBubbleMenu);

        // --- 菜单项点击逻辑 (新增“多选”分支) ---
        // vvv 用这个【包含了“编辑”和“撤回”逻辑】的最终版，替换旧的菜单点击监听器 vvv
    DOM.bubblePopoverMenu.addEventListener('click', async (e) => {
        const targetItem = e.target.closest('.popover-item');
        if (!targetItem) return;
        const action = targetItem.dataset.action;
        const targetBubble = appState.longPressedBubble;
        if (!targetBubble) { closeBubbleMenu(); return; }

        const messageEl = targetBubble.closest('.chat-message');
        const messageId = parseInt(messageEl.dataset.messageId, 10);
        const messageData = appState.currentChatHistory.find(msg => msg.id === messageId);

        if (!messageData) {
            utils.showToast('无法操作该消息');
            closeBubbleMenu();
            return;
        }

        if (action === '复制') {
            const textToCopy = targetBubble.dataset.messageContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
                utils.showToast('已复制到剪贴板');
            }).catch(err => {
                console.error('复制失败: ', err);
                utils.showToast('复制失败，请检查浏览器权限');
            });

        } else if (action === '引用') {
            appState.quotedMessage = messageData;
            const authorName = messageData.sender === 'user' ?
                (appState.dossiers.find(d => d.id === messageData.dossierId)?.user.name || '你') :
                (appState.dossiers.find(d => d.id === messageData.dossierId)?.character.name || '角色');
            DOM.replyAuthor.textContent = `回复 ${authorName}`;
            DOM.replyText.textContent = messageData.content;
            DOM.replyPreviewContainer.classList.add('visible');
            DOM.chatInput.focus();

        } else if (action === '多选') {
            enterMultiSelectMode(messageId);

        } else if (action === '编辑') { // vvv 这是新增的逻辑 vvv
            // 1. 记录下我们正在编辑哪条消息
            appState.currentEditingMessageId = messageId;
            // 2. 将原始消息内容填入编辑框
            //    注意：对于AI的引用消息，我们需要获取纯净的回复文本
            const rawContent = messageData.content;
            const isAIQuote = messageData.sender === 'character' && rawContent.includes('\n') && rawContent.startsWith('> ');
            const editableContent = isAIQuote ? rawContent.split('\n').slice(1).join('\n') : rawContent;
            DOM.editMessageTextarea.value = editableContent;
            // 3. 显示编辑浮窗
            DOM.editMessageModal.classList.add('visible');
            DOM.editMessageTextarea.focus();
            // ^^^ 新逻辑结束 ^^^

        } else if (action === '撤回') {
            messageData.status = 'withdrawn';
            await dbHelper.set(CONSTANTS.STORE_NAMES.CHAT_HISTORY, messageData);
            messageEl.remove();
            await renderMessage(messageData);
            utils.showToast('消息已撤回');
        } else if (action === '重试') { // vvv 这是新增的逻辑 vvv
            // 安全检查：只允许对角色的消息进行重试
            if (messageData.sender !== 'character') {
                utils.showToast('只能对角色的回复进行重试');
            } else {
                await handleRetry(messageId);
                     }

            }else {
            utils.showToast(`你点击了：“${action}”`);
        }
        closeBubbleMenu();
    });
        
        // --- 引用预览关闭按钮 (保持不变) ---
        DOM.closeReplyBtn.addEventListener('click', () => {
            DOM.replyPreviewContainer.classList.remove('visible');
            appState.quotedMessage = null;
        });

        // --- 【新增】多选删除按钮的监听器 ---
        DOM.deleteSelectedBtn.addEventListener('click', async () => {
    const idsToDelete = new Set(appState.selectedMessageIds); // 复制一份ID
    if (idsToDelete.size === 0) return;

    if (confirm(`确定要删除所选的 ${idsToDelete.size} 条消息吗？`)) {
        try {
            // 1. 从数据库批量删除
            await dbHelper.deleteMessagesByIds(idsToDelete);

            // 2. 从UI上移除这些元素
            idsToDelete.forEach(id => {
                document.querySelector(`.chat-message[data-message-id="${id}"]`)?.remove();
            });

            // 3. 从内存中过滤掉这些消息
            appState.currentChatHistory = appState.currentChatHistory.filter(msg => !idsToDelete.has(msg.id));
            
            // 4. 更新会话列表的最后一条消息 (可选但推荐)
            const lastMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
            if (lastMessage) {
                await updateChatSession(lastMessage.dossierId, lastMessage.content);
            } else {
                 await updateChatSession(appState.currentChattingDossierId, '聊天记录已清空');
            }

            utils.showToast('已删除所选消息');

            // 5. 退出多选模式
            exitMultiSelectMode();

        } catch (error) {
            utils.showToast(`删除失败: ${error.message}`);
        }
    }
});

// --- 【新增】退出多选按钮的监听器 ---
        DOM.exitMultiSelectBtn.addEventListener('click', () => {
            // 直接调用我们现有的退出多选函数即可
            exitMultiSelectMode();
        });
        
        // --- 【最终简化版】聊天返回按钮的唯一事件监听器 ---
        DOM.chatBackBtns.forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const currentPage = e.target.closest('.app-page');
                if (!currentPage) return; // 安全检查

                // 返回按钮现在只负责常规的页面导航
                const targetId = e.target.closest('.back-button').dataset.target;

                if (targetId === 'desktop') {
                    // 返回到桌面
                    closeNavigator(DOM.chatApp);
                } else {
                    // 如果是从聊天对话页返回到列表页
                    if (currentPage.id === 'chat-dialogue-page') {
                        // 【保留】执行数据同步，解决角色重复的bug
                        appState.currentChattingDossierId = null;
                        appState.dossiers = await dbHelper.getAll(CONSTANTS.STORE_NAMES.DOSSIERS);
                        appState.chatSessions = await dbHelper.getAll(CONSTANTS.STORE_NAMES.CHAT_SESSIONS);
                        await renderChatList();
                    }
                    // 执行页面跳转
                    navigateToPage(DOM.chatApp, targetId);
                }
            });
        });

    // vvv 在这里添加全新的事件监听器，用于处理点击“撤回提示条” vvv
    DOM.messagesContainer.addEventListener('click', e => {
        // 如果是多选模式，则不触发这个逻辑
        if (appState.isMultiSelectMode) return;
        
        const targetNotice = e.target.closest('.withdrawn-notice');
        if (!targetNotice) return;
        
        const messageId = parseInt(targetNotice.dataset.messageId, 10);
        const messageData = appState.currentChatHistory.find(m => m.id === messageId);
        
        if (messageData) {
            const dossier = appState.dossiers.find(d => d.id === messageData.dossierId);
            const speaker = messageData.sender === 'user' ? '你' : (dossier?.character.name || '对方');

            DOM.withdrawnModalTitle.textContent = `${speaker} 的内心活动`;
            DOM.withdrawnOriginalText.textContent = messageData.content;
            DOM.withdrawnInnerThought.textContent = messageData.innerThought || '(没有记录内心想法)';
            
            DOM.withdrawnDetailsModal.classList.add('visible');
        }
    });

    // --- 新增：关闭内心独白浮窗的逻辑 ---
    DOM.closeWithdrawnModalBtn.addEventListener('click', () => DOM.withdrawnDetailsModal.classList.remove('visible'));
    DOM.withdrawnDetailsModal.addEventListener('click', e => {
        if (e.target === DOM.withdrawnDetailsModal) DOM.withdrawnDetailsModal.classList.remove('visible');
    });
    // ^^^ 新监听器结束 ^^^   

 // vvv 在这里添加全新的事件监听器，用于处理“编辑消息”浮窗 vvv
    const closeEditModal = () => {
        DOM.editMessageModal.classList.remove('visible');
        appState.currentEditingMessageId = null; // 清理状态
        DOM.editMessageTextarea.value = ''; // 清空文本域
    };

    DOM.closeEditModalBtn.addEventListener('click', closeEditModal);
    DOM.cancelEditBtn.addEventListener('click', closeEditModal);
    DOM.editMessageModal.addEventListener('click', e => {
        if (e.target === DOM.editMessageModal) closeEditModal();
    });

    // --- 【核心】保存修改的逻辑 ---
    DOM.saveEditBtn.addEventListener('click', async () => {
        const messageId = appState.currentEditingMessageId;
        const newText = DOM.editMessageTextarea.value.trim();

        if (!messageId || newText === '') {
            utils.showToast('内容不能为空！');
            return;
        }

        try {
            // 1. 在内存中找到并更新消息
            const messageIndex = appState.currentChatHistory.findIndex(msg => msg.id === messageId);
            if (messageIndex === -1) throw new Error('在内存中找不到该消息');

            const messageToUpdate = appState.currentChatHistory[messageIndex];
            const originalContent = messageToUpdate.content;
            
            // 特殊处理AI的引用消息，保持引用部分不变
            const isAIQuote = messageToUpdate.sender === 'character' && originalContent.includes('\n') && originalContent.startsWith('> ');
            if (isAIQuote) {
                const quotePart = originalContent.split('\n')[0];
                messageToUpdate.content = `${quotePart}\n${newText}`;
            } else {
                messageToUpdate.content = newText;
            }

            // 2. 将更新后的整个消息对象存回数据库
            await dbHelper.set(CONSTANTS.STORE_NAMES.CHAT_HISTORY, messageToUpdate);

            // 3. 直接更新UI上的气泡内容，避免整个页面重绘
            const messageBubble = document.querySelector(`.chat-message[data-message-id="${messageId}"] .bubble`);
            if (messageBubble) {
                messageBubble.textContent = newText;
                messageBubble.dataset.messageContent = messageToUpdate.content; // 更新data属性
            }
            
            // 4. 更新会话列表的最后一条消息（如果是最后一条的话）
            if (messageIndex === appState.currentChatHistory.length - 1) {
                await updateChatSession(messageToUpdate.dossierId, newText);
                // 可以在这里决定是否需要重新渲染chatList，但通常影响不大
            }

            utils.showToast('消息已修改');
            closeEditModal();

        } catch (error) {
            console.error('编辑消息失败:', error);
            utils.showToast(`保存失败: ${error.message}`);
        }
    });
 // ^^^ 新监听器结束 ^^^

    // 【全新】使用事件委托，监听对动态添加的“加载更多”按钮的点击
    DOM.messagesContainer.addEventListener('click', (e) => {
        if (e.target.id === 'load-more-btn') {
            loadMoreMessages();
        }
    });

// vvv 在这里【新增】所有图书馆相关的事件监听 vvv

DOM.openLibraryApp.addEventListener('click', () => {
    renderLibraryList();
    navigateToPage(DOM.libraryApp, 'library-main-page');
});

DOM.libraryBackBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
        const target = e.target.closest('.back-button').dataset.target;
        target === 'desktop' ? closeNavigator(DOM.libraryApp) : navigateToPage(DOM.libraryApp, target);
    });
});

DOM.addBookBtn.addEventListener('click', () => {
    resetCreationForm_Library();
    navigateToPage(DOM.libraryApp, 'library-creation-page');
});

DOM.saveNewBookBtn.addEventListener('click', async () => {
    const title = DOM.createBookTitle.value.trim();
    if (!title) return utils.showToast('书名不能为空！');

    const newBook = {
        title,
        isGlobal: DOM.createBookIsGlobal.checked,
        category: DOM.createBookCategory.value,
        content: DOM.createBookContent.value.trim()
    };

    await dbHelper.add(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS, newBook);
    utils.showToast(`《${title}》已存入图书馆。`);
    
    await renderLibraryList();
    navigateToPage(DOM.libraryApp, 'library-main-page');
});

DOM.libraryListContainer.addEventListener('click', (e) => {
    const card = e.target.closest('.settings-item[data-book-id]');
    if (card) {
        openBookEditModal(parseInt(card.dataset.bookId, 10));
    }
});

const closeEditBookModal = () => {
    DOM.bookEditModal.classList.remove('visible');
    appState.currentEditingBookId = null;
};
DOM.closeBookEditModalBtn.addEventListener('click', closeEditBookModal);
DOM.bookEditModal.addEventListener('click', (e) => {
    if (e.target === DOM.bookEditModal) closeEditBookModal();
});

DOM.saveBookChangesBtn.addEventListener('click', async () => {
    const bookId = appState.currentEditingBookId;
    if (!bookId) return;

    const title = DOM.editBookTitle.value.trim();
    if (!title) return utils.showToast('书名不能为空！');
    
    const updatedBook = {
        id: bookId,
        title,
        isGlobal: DOM.editBookIsGlobal.checked,
        category: DOM.editBookCategory.value,
        content: DOM.editBookContent.value.trim()
    };

    await dbHelper.set(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS, updatedBook);
    utils.showToast(`《${title}》已更新。`);
    
    closeEditBookModal();
    await renderLibraryList();
});

DOM.deleteBookBtn.addEventListener('click', async () => {
    const bookId = appState.currentEditingBookId;
    if (!bookId) return;

    if (confirm(`您确定要永久删除《${DOM.editBookTitle.value}》这本书吗？`)) {
        await dbHelper.delete(CONSTANTS.STORE_NAMES.LIBRARY_BOOKS, bookId);
        utils.showToast('书籍已删除。');
        closeEditBookModal();
        await renderLibraryList();
    }
});

// vvv 在这里【新增】所有“书籍链接”相关的事件监听 vvv
    DOM.manageExclusiveBooksItem.addEventListener('click', openBookLinkModal);

    const closeBookLinkModal = () => DOM.bookLinkModal.classList.remove('visible');
    DOM.closeBookLinkModalBtn.addEventListener('click', closeBookLinkModal);
    DOM.bookLinkModal.addEventListener('click', e => {
        if (e.target === DOM.bookLinkModal) closeBookLinkModal();
    });

    DOM.saveBookLinksBtn.addEventListener('click', async () => {
        const dossierId = appState.currentChattingDossierId;
        const dossierIndex = appState.dossiers.findIndex(d => d.id === dossierId);
        if (dossierIndex === -1) return utils.showToast('保存失败，找不到当前角色！');

        const selectedIds = [];
        DOM.bookLinkList.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
            selectedIds.push(parseInt(checkbox.dataset.bookId, 10));
        });

        // 更新内存和数据库
        const dossierToUpdate = appState.dossiers[dossierIndex];
        dossierToUpdate.libraryBookIds = selectedIds;
        
        await dbHelper.set(CONSTANTS.STORE_NAMES.DOSSIERS, dossierToUpdate);

        // 更新UI显示
        updateLinkedBooksDisplay(dossierToUpdate);
        
        utils.showToast('专属书设置已保存！');
        closeBookLinkModal();
    });

// vvv 【新增】快拍查看器相关的事件监听 vvv
DOM.closeStoryViewerBtn.addEventListener('click', closeStoryViewer);
DOM.storyNavLeft.addEventListener('click', prevStory);
DOM.storyNavRight.addEventListener('click', nextStory);

// 【新增】监听评论输入框的状态变化，以控制发送按钮的显隐
DOM.storyCommentInput.addEventListener('input', () => {
    if (DOM.storyCommentInput.value.trim() !== '') {
        DOM.storyViewerFooter.classList.add('input-active');
    } else {
        DOM.storyViewerFooter.classList.remove('input-active');
    }
});
// ^^^ 新监听器到此结束 ^^^



// vvv 【新增】监听“日常”卡片评论按钮的点击 (事件委托) vvv
document.body.addEventListener('click', async (e) => {
    const commentBtn = e.target.closest('.comment-btn');
    if (!commentBtn) return;

    const momentId = parseInt(commentBtn.dataset.momentId, 10);
    const dossierId = parseInt(commentBtn.dataset.dossierId, 10);
    if (!momentId || !dossierId) return;

    const commentText = prompt("请输入您的评论：");
    if (commentText && commentText.trim() !== '') {
        await handlePostComment(momentId, dossierId, commentText.trim());
        utils.showToast("评论已发布！");
        // 为了未来显示评论，我们在这里刷新一下
        if (document.getElementById('moments-pane').classList.contains('active')) {
            renderMoments(); 
        }
    }
});

// vvv 【新增】全局点赞事件监听器 (事件委托) vvv
    document.body.addEventListener('click', async (e) => {
        const likeBtn = e.target.closest('.like-btn');
        if (!likeBtn) return;

        let momentId, dossierId; // 【修复】同时声明 momentId 和 dossierId

        // 【修复】根据不同情况，确保 dossierId 也被正确获取
        if (likeBtn.dataset.momentId && likeBtn.dataset.dossierId) {
            // 情况1：点击的是“日常”卡片上的按钮
            momentId = parseInt(likeBtn.dataset.momentId, 10);
            dossierId = parseInt(likeBtn.dataset.dossierId, 10);
        } 
        else if (DOM.storyViewerOverlay.classList.contains('visible')) {
            // 情况2：点击的是“快拍”查看器里的按钮
            const currentStory = appState.currentViewingStories[appState.currentStoryIndex];
            if (currentStory) {
                momentId = currentStory.id;
                dossierId = currentStory.dossierId; // 从当前快拍状态中获取 dossierId
            }
        }

        // 如果两个ID中任何一个没找到，则不执行操作
        if (!momentId || !dossierId) return;

        // 【修复】调用“大脑”函数时，传入两个必需的参数
        const isNowLiked = await handleLikeToggle(momentId, dossierId);

        // 统一更新UI (这部分逻辑原先就是正确的)
        if (isNowLiked) {
            likeBtn.classList.add('liked', 'ri-heart-fill');
            likeBtn.classList.remove('ri-heart-line');
        } else {
            likeBtn.classList.remove('liked', 'ri-heart-fill');
            likeBtn.classList.add('ri-heart-line');
        }
    });

// vvv 【新增】监听“快拍查看器”内的发送按钮点击 vvv
DOM.storySendCommentBtn.addEventListener('click', async () => {
    const commentText = DOM.storyCommentInput.value.trim();
    if (commentText === '') return;

    const currentStory = appState.currentViewingStories[appState.currentStoryIndex];
    if (!currentStory) return;

    const momentId = currentStory.id;
    const dossierId = currentStory.dossierId;

    // 1. 【核心升级】我们先构造一个临时的评论对象用于立即显示
    const tempComment = {
        momentId: momentId,
        authorType: 'user',
        content: commentText
    };
    const bubble = await createStoryCommentBubble(tempComment);
    DOM.storyCommentsContainer.appendChild(bubble);
    // 滚动到底部，确保能看到新评论
    DOM.storyCommentsContainer.scrollTop = DOM.storyCommentsContainer.scrollHeight;

    // 2. 清空输入框，UI反馈先行
    DOM.storyCommentInput.value = '';
    DOM.storyViewerFooter.classList.remove('input-active');

    // 3. 在后台，默默地把完整的评论存入数据库
    await handlePostComment(momentId, dossierId, commentText);
    
    resumeStoryPlayback();
});

// vvv 【新增】动态发布页面的全套事件监听 vvv
        
        // 返回按钮
        DOM.momentCreatorBackBtn.addEventListener('click', (e) => {
            closeNavigator(DOM.momentCreatorApp);
        });

        // 全局头像上传
        DOM.userMomentAvatarUploader.addEventListener('click', () => {
            DOM.globalUserAvatarInput.click();
        });
        DOM.globalUserAvatarInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                handleGlobalAvatarUpload(e.target.files[0]);
            }
            e.target.value = ''; // 重置
        });

        // 动态类型切换
        DOM.momentTypeSelector.addEventListener('click', (e) => {
            if (e.target.classList.contains('type-btn')) {
                DOM.momentTypeSelector.querySelectorAll('.type-btn').forEach(btn => {
                    btn.classList.remove('active');
                    btn.style.background = 'transparent';
                    btn.style.opacity = '0.7';
                });
                e.target.classList.add('active');
                e.target.style.background = 'var(--button-bg-color)';
                e.target.style.opacity = '1';
                // 更改输入框提示
                DOM.momentContentInput.placeholder = e.target.dataset.type === 'post' ? '分享新鲜事...' : '分享此刻...';
            }
        });

        // 动态图片上传
        DOM.momentImageUploader.addEventListener('click', () => {
            DOM.momentImageFileInput.click();
        });
        DOM.momentImageFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // 将选择的文件暂存到全局状态中
                appState.pendingMomentImageFile = file;
                const url = URL.createObjectURL(file);
                DOM.momentImageUploader.style.backgroundImage = `url(${url})`;
                DOM.momentImageUploader.innerHTML = '';
            }
            e.target.value = ''; // 重置
        });

        // 发布按钮
        DOM.publishMomentBtn.addEventListener('click', handlePostUserMoment);
        
        // vvv 【新增】监听所有“回复评论”按钮的点击 (事件委托) vvv
document.body.addEventListener('click', async (e) => {
    const replyBtn = e.target.closest('.comment-actions');
    if (!replyBtn) return;

    const repliedToCommentId = parseInt(replyBtn.dataset.commentId, 10);
    const commentItemEl = replyBtn.closest('.comment-item');
    const postCardEl = replyBtn.closest('.post-card');
    if (!postCardEl || !commentItemEl) return;

    // 从DOM中获取必要的信息
    const momentId = parseInt(postCardEl.querySelector('.comment-btn').dataset.momentId, 10);
    const repliedToAuthorName = commentItemEl.querySelector('.comment-author-name').textContent;
    
    const replyText = prompt(`回复 ${repliedToAuthorName}:`);

   if (replyText && replyText.trim() !== '') {
    // 【核心修正】从动态卡片上重新获取原始作者的 dossierId
    const momentAuthorDossierId = postCardEl.querySelector('.comment-btn').dataset.dossierId;

    // 【核心修正】在调用时，将正确的 ID 传递过去
    await handlePostComment(momentId, momentAuthorDossierId, replyText.trim(), repliedToCommentId);
    
    utils.showToast("回复已发布！");
    if (document.getElementById('moments-pane').classList.contains('active')) {
        await renderMoments(); 
    }
}
});

    // vvv 【新增】使用事件委托监听所有删除动态按钮的点击 vvv
    document.body.addEventListener('click', async (e) => {
        const deleteBtn = e.target.closest('.delete-moment-btn');
        if (!deleteBtn) return; // 如果点击的不是删除按钮，则忽略

        const momentId = parseInt(deleteBtn.dataset.momentId, 10);
        if (!momentId) return;

        // 弹出确认框，防止误删
        if (confirm("您确定要永久删除这条动态吗？相关的评论和点赞也会一并消失。")) {
            try {
                // 调用我们新创建的数据库函数来执行删除
                await dbHelper.deleteMomentAndAssociations(momentId);
                utils.showToast('动态已删除');

                // 【关键】删除成功后，重新渲染整个动态列表
                await renderMoments();

            } catch (error) {
                console.error("删除动态失败:", error);
                utils.showToast(`删除失败: ${error.message}`);
            }
        }
    });

// 【全新】监听快拍评论输入框的聚焦和失焦事件
    DOM.storyCommentInput.addEventListener('focus', () => {
        // 如果没有计时器在跑，就什么都不做
        if (!appState.storyTimerId) return;

        // 1. 暂停JS计时器
        clearTimeout(appState.storyTimerId);

        // 2. 计算并存储剩余时间
        appState.storyPauseTimestamp = Date.now();
        const elapsed = appState.storyPauseTimestamp - appState.storyStartTime;
        appState.storyTimeRemaining = Math.max(0, 10000 - elapsed);
        
        // 3. 暂停CSS动画
        const fill = DOM.storyProgressBars.querySelector('.active .progress-bar-fill');
        if (fill) {
            // 获取当前进度条的实际宽度
            const computedWidth = window.getComputedStyle(fill).width;
            // “冻结”宽度
            fill.style.transition = 'none';
            fill.style.width = computedWidth;
        }
    });

    DOM.storyCommentInput.addEventListener('blur', () => {
        // 当输入框失去焦点时，恢复播放
        resumeStoryPlayback();
    });

DOM.emojiBtn.addEventListener('click', toggleStickerPanel);

    // 【全新】使用事件委托，监听对表情面板中所有表情图片的点击
    DOM.stickerPanel.addEventListener('click', (e) => {
        // 确保点击的是一个带有 data-description 属性的 IMG 标签
        if (e.target.tagName === 'IMG' && e.target.dataset.description) {
            const description = e.target.dataset.description;
            
            // 1. 构建标准的表情包代码
            const stickerContent = `[sticker:${description}]`;
            
            // 2. 调用我们抽离出的核心函数来发送
            sendBufferedMessage(stickerContent);
            
            // 3. 发送后，可以自动关闭表情面板，提升体验
            toggleStickerPanel();
        }
    });
    
    // --- 【全新】表情包管理弹窗的事件监听 ---

    // 1. 点击表情面板的“管理”按钮，打开管理弹窗
    DOM.manageStickersBtn.addEventListener('click', openStickerManager);

    // 2. 点击管理弹窗右上角的“x”，关闭弹窗
    DOM.closeStickerManagerBtn.addEventListener('click', closeStickerManager);

    // 3. 点击弹窗的灰色背景区域，同样关闭弹窗
    DOM.stickerManagerModal.addEventListener('click', (e) => {
        if (e.target === DOM.stickerManagerModal) {
            closeStickerManager();
        }
    });
    
    // --- 【全新】管理弹窗内部按钮的事件监听 ---

    // 4. 使用事件委托，监听对动态添加的“x”删除按钮的点击
    DOM.stickerManagerGrid.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-sticker-btn')) {
            const description = e.target.dataset.description;
            if (description) {
                // a. 只在内存中删除
                appState.userStickersForManager.delete(description);
                // b. 从UI上移除元素
                e.target.closest('.sticker-manager-item').remove();
                
                // c. 如果删完了，显示空状态提示
                if (appState.userStickersForManager.size === 0) {
                    DOM.stickerManagerGrid.innerHTML = '<p class="empty-placeholder">这里空空如也~</p>';
                }
            }
        }
    });

    // 5. “清空全部”按钮的逻辑
    DOM.clearAllStickersBtn.addEventListener('click', () => {
        if (confirm("您确定要清空所有收藏的表情包吗？此操作在点击“完成”前仍可撤销。")) {
            // a. 清空内存
            appState.userStickersForManager.clear();
            // b. 更新UI
            DOM.stickerManagerGrid.innerHTML = '<p class="empty-placeholder">这里空空如也~</p>';
        }
    });

    // 6. 【核心】“完成”按钮的逻辑，负责将内存中的最终状态写入数据库
    DOM.saveStickerChangesBtn.addEventListener('click', async () => {
        try {
            // a. 将内存中的 Map 转换回多行文本格式
            let newStickerText = '';
            const entries = [];
            for (const [desc, url] of appState.userStickersForManager) {
                entries.push(`${desc}: ${url}`);
            }
            newStickerText = entries.join('\n');

            // b. 将新的文本字符串存回数据库
            await dbHelper.set(CONSTANTS.STORE_NAMES.USER_SETTINGS, newStickerText, 'user_sticker_collection');
            
            utils.showToast('表情包已保存！');
            closeStickerManager();

            // c. 【关键】检查表情发送面板是否正开着，如果是，则刷新它
            if (DOM.stickerPanel.style.display === 'flex') {
                await toggleStickerPanel(); // 关闭
                await toggleStickerPanel(); // 再次打开以刷新内容
            }

        } catch (error) {
            console.error("保存表情包失败:", error);
            utils.showToast(`保存失败: ${error.message}`);
        }
    });
  
    // --- 【全新】二级导入弹窗的事件监听 ---

    // 7. 点击“批量导入”按钮，打开二级弹窗
    DOM.batchImportStickersBtn.addEventListener('click', openStickerImportModal);

    // 8. 点击二级弹窗的“取消”按钮或背景，关闭它
    DOM.cancelStickerImportBtn.addEventListener('click', closeStickerImportModal);
    DOM.stickerImportModal.addEventListener('click', (e) => {
        if (e.target === DOM.stickerImportModal) {
            closeStickerImportModal();
        }
    });

    // 9. 【核心】点击“确认导入”按钮的逻辑
    DOM.confirmStickerImportBtn.addEventListener('click', () => {
        const textToImport = DOM.stickerImportTextarea.value;
        if (!textToImport.trim()) {
            utils.showToast('请输入要导入的内容');
            return;
        }

        try {
            // a. 使用我们强大的解析器来解析新输入的文本
            const newStickersMap = utils.parseStickerText(textToImport);
            
            if (newStickersMap.size === 0) {
                utils.showToast('没有解析到有效的表情包格式');
                return;
            }

            // b. 将新解析出的表情，合并到我们内存中的“工作副本”里
            let importCount = 0;
            newStickersMap.forEach((url, desc) => {
                // 如果已存在相同的描述，则覆盖；否则新增
                if (!appState.userStickersForManager.has(desc)) {
                    importCount++;
                }
                appState.userStickersForManager.set(desc, url);
            });

            // c. 立即重新渲染管理的网格UI，让用户看到新加入的表情
            renderStickerManagerGrid();

            utils.showToast(`成功导入/更新了 ${newStickersMap.size} 个表情！`);
            closeStickerImportModal();

        } catch (error) {
            console.error("批量导入表情失败:", error);
            utils.showToast(`导入失败: ${error.message}`);
        }
    });

DOM.chatFunctionBtn.addEventListener('click', toggleFunctionPanel);
// vvv 【全新】“+”号面板中“发送图片”功能的完整逻辑 vvv
            const funcSendImage = document.getElementById('func-send-image');
            
            // 1. 当用户点击功能面板中的“图片”图标时
            funcSendImage.addEventListener('click', () => {
                DOM.chatImageUploader.click(); // 触发隐藏的文件选择器
            });

            // 2. 当用户选择了图片文件后
            DOM.chatImageUploader.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return; // 如果用户取消了选择，则不执行任何操作

                // 2a. 【需求满足】自动关闭功能面板
                toggleFunctionPanel();
                
                const dossierId = appState.currentChattingDossierId;
                if (!dossierId) return;

                try {
                    // 2b. 压缩图片以优化性能和成本
                    const compressedFile = await compressImageForAI(file);
                    
                    // 2c. 将压缩后的图片转换为 Base64 Data URL (使用我们修正后的函数)
                    const base64Image = await utils.fileToBase64(compressedFile);

                    // 2d. 【核心】构建符合多模态AI标准的图片消息体
                    //      content 是一个数组，这正是你的 apiHelper 所期望的格式！
                    const userMessage = {
                        dossierId,
                        sender: 'user',
                        content: [{
                            type: 'image_url',
                            image_url: { url: base64Image }
                        }],
                        timestamp: Date.now()
                    };
                    
                    // 2e. 将这条特殊的消息存入数据库并更新内存
                    const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, userMessage);
                    userMessage.id = savedId;
                    const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
                    appState.currentChatHistory.push(userMessage);

                    // 2f. 【需求满足】立刻在聊天窗口中渲染这张图片
                    await renderMessage(userMessage, prevMessage);
                    
                    // 2g. 更新会话列表的预览
                    await updateChatSession(dossierId, '[图片]');
                    
                    // 2h. 【需求满足】此处【不】调用 handleSendMessage()，等待用户后续操作

                } catch (error) {
                    console.error("发送图片失败:", error);
                    utils.showToast(`图片发送失败: ${error.message}`);
                } finally {
                    // 2i. 无论成功与否，都重置文件选择器，以便用户可以再次选择同一张图片
                    e.target.value = ''; 
                }
            });

// 监听“+”号面板中的“视频通话”按钮
            DOM.funcSendVideo.addEventListener('click', () => {
                // 点击后先收起面板
                if (DOM.chatFunctionPanel.style.display === 'flex') {
                    toggleFunctionPanel();
                }
                // 然后启动视频通话
                startVideoCall();
            });

            // 监听视频通话界面中的“取消/挂断”按钮
            DOM.videoCallActionBtn.addEventListener('click', endVideoCall);

// 监听视频通话中的发送按钮
            DOM.videoCallSendBtn.addEventListener('click', handleVideoCallSend);

            // 监听视频通话输入框的回车键
            DOM.videoCallInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); // 防止回车换行
                    handleVideoCallSend();
                }
            });

// 1. 监听“+”号面板中的“语音”图标
            DOM.funcVoiceInput.addEventListener('click', () => {
                toggleFunctionPanel(); // 关闭功能面板
                DOM.voiceTextInput.value = ''; // 清空输入框
                DOM.voiceMessageModal.classList.add('visible'); // 显示浮窗
                DOM.voiceTextInput.focus();
            });

            // 2. 关闭浮窗的两种方式
            const closeVoiceModal = () => DOM.voiceMessageModal.classList.remove('visible');
            DOM.closeVoiceModalBtn.addEventListener('click', closeVoiceModal);
            DOM.cancelVoiceMessageBtn.addEventListener('click', closeVoiceModal);
            DOM.voiceMessageModal.addEventListener('click', (e) => {
                if (e.target === DOM.voiceMessageModal) closeVoiceModal();
            });

            // 3. 监听“发送”按钮
            DOM.sendVoiceMessageBtn.addEventListener('click', async () => {
                const text = DOM.voiceTextInput.value.trim();
                if (!text) {
                    utils.showToast('语音内容不能为空哦');
                    return;
                }

                const dossierId = appState.currentChattingDossierId;
                if (!dossierId) return;

                // a. 计算虚拟时长 (每秒3个字)
                const duration = Math.max(1, Math.ceil(text.length / 3));

                // b. 构建新的语音消息对象
                const voiceMessage = {
                    dossierId,
                    sender: 'user',
                    type: 'voice', // <-- 新类型！
                    content: text,
                    metadata: { duration },
                    timestamp: Date.now()
                };

                // c. 存入数据库并更新内存
                const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, voiceMessage);
                voiceMessage.id = savedId;
                const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
                appState.currentChatHistory.push(voiceMessage);

                // d. 渲染到屏幕
                await renderMessage(voiceMessage, prevMessage);
                
                // e. 更新会话列表
                await updateChatSession(dossierId, '[语音消息]');

                // f. 关闭浮窗
                closeVoiceModal();
            });

            // 4. 【核心】使用事件委托，监听对所有语音条的点击
            DOM.messagesContainer.addEventListener('click', (e) => {
                const voiceBubble = e.target.closest('.voice-bubble');
                if (!voiceBubble) return; // 如果点的不是语音条，则忽略

                const wrapper = voiceBubble.parentElement;
                const transcriptionEl = wrapper.querySelector('.transcription-text');
                const timestampEl = wrapper.querySelector('.message-timestamp');
                const playIcon = voiceBubble.querySelector('.play-icon');

                if (transcriptionEl) {
                    // 切换显示状态
                    const isVisible = transcriptionEl.style.display === 'block';
                    transcriptionEl.style.display = isVisible ? 'none' : 'block';
                    
                    // 切换播放图标
                    playIcon.className = isVisible ? 'ri-play-fill play-icon' : 'ri-pause-fill play-icon';

                    // 【关键】根据显示状态，决定时间戳是气泡的一部分还是独立的一部分
                    if (isVisible) {
                        // 文字收起 -> 把时间戳移回 wrapper 的末尾
                        if (timestampEl) wrapper.appendChild(timestampEl); // <--- 核心修正
                    } else {
                        // 文字展开 -> 同样是把时间戳移到 wrapper 的末尾
                        if (timestampEl) wrapper.appendChild(timestampEl); // <--- 逻辑统一
                    }
                }
            });

// 新增：“模拟转账”事件监听
            DOM.messagesContainer.addEventListener('click', async (e) => {
                const transferCard = e.target.closest('.transfer-card.status-pending');
                if (!transferCard) return;

                const messageEl = transferCard.closest('.chat-message');
                const messageId = parseInt(messageEl.dataset.messageId, 10);
                if (!messageId) return;

                const messageIndex = appState.currentChatHistory.findIndex(msg => msg.id === messageId);
                if (messageIndex === -1) return;

                const messageToUpdate = appState.currentChatHistory[messageIndex];
                
                // 安全检查：只允许用户“接收”角色发来的转账
                if (messageToUpdate.sender !== 'character') return;

                try {
                    // 1. 更新数据库和内存中的状态
                    if (!messageToUpdate.metadata) messageToUpdate.metadata = {};
                    messageToUpdate.metadata.status = 'accepted';
                    await dbHelper.set(CONSTANTS.STORE_NAMES.CHAT_HISTORY, messageToUpdate);

                    // 2. 更新UI
                    transferCard.classList.remove('status-pending');
                    transferCard.classList.add('status-accepted');
                    const icon = transferCard.querySelector('.transfer-info i');
                    if (icon) icon.className = 'ri-check-line';

                    // 3. 添加“你已收款”的系统消息
                    const systemMessageContent = `你已收款 ${messageToUpdate.content.amount} ${messageToUpdate.content.currency}`;
                    const systemMessage = {
                        dossierId: messageToUpdate.dossierId,
                        sender: 'system',
                        content: systemMessageContent,
                        timestamp: Date.now()
                    };
                    const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, systemMessage);
                    systemMessage.id = savedId;
                    appState.currentChatHistory.push(systemMessage);
                    await renderMessage(systemMessage);

                    // 4. 更新会话列表预览
                    await updateChatSession(messageToUpdate.dossierId, `[已收账] ${systemMessageContent}`);
// vvv 新增下面这行，记录收入 vvv
await addWalletTransaction('income', messageToUpdate.dossierId, messageToUpdate.content.amount, messageToUpdate.content.memo);

                } catch (error) {
                    console.error("收款失败:", error);
                    utils.showToast('收款操作失败');
                }
            });

// 1. 监听“+”号面板中的“转账”图标
            DOM.funcTransfer.addEventListener('click', () => {
                toggleFunctionPanel(); // 关闭功能面板
                DOM.transferAmountInput.value = ''; // 清空输入
                DOM.transferMemoInput.value = '';
                DOM.transferModal.classList.add('visible'); // 显示浮窗
                DOM.transferAmountInput.focus();
            });

            // 2. 关闭浮窗的两种方式
            const closeTransferModal = () => DOM.transferModal.classList.remove('visible');
            DOM.closeTransferModalBtn.addEventListener('click', closeTransferModal);
            DOM.cancelTransferBtn.addEventListener('click', closeTransferModal);
            DOM.transferModal.addEventListener('click', (e) => {
                if (e.target === DOM.transferModal) closeTransferModal();
            });

            // 3. 监听“确认转账”按钮
            DOM.confirmTransferBtn.addEventListener('click', async () => {
                const amount = parseFloat(DOM.transferAmountInput.value);
                if (isNaN(amount) || amount <= 0) {
                    utils.showToast('请输入有效的转账金额');
                    return;
                }
                
                const memo = DOM.transferMemoInput.value.trim() || `转账 ${amount} 信用点`;
                const dossierId = appState.currentChattingDossierId;
                if (!dossierId) return;

                // a. 构建新的转账消息对象
                const transferMessage = {
                    dossierId,
                    sender: 'user',
                    type: 'transfer',
                    content: { amount, currency: '信用点', memo },
                    metadata: { status: 'pending' }, // 用户发起的转账，初始状态也是 pending
                    timestamp: Date.now()
                };

                // b. 存入数据库并更新内存
                const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, transferMessage);
                transferMessage.id = savedId;
                const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
                appState.currentChatHistory.push(transferMessage);

                // c. 渲染到屏幕
                await renderMessage(transferMessage, prevMessage);
                
                // d. 更新会话列表
                await updateChatSession(dossierId, '[转账]');

                // e. 关闭浮窗
                closeTransferModal();
// vvv 新增下面这行，记录支出 vvv
await addWalletTransaction('expense', dossierId, amount, memo);
                
            });

// --- 【V2】钱包应用相关的事件监听 ---
DOM.funcWallet.addEventListener('click', () => {
    toggleFunctionPanel(); // <-- 新增：先关闭功能面板
    // 点击“+”号菜单中的钱包，默认显示全部明细
    renderWalletPage('all');
});

// 关闭浮窗的两种方式
const closeWalletModal = () => DOM.walletModal.classList.remove('visible');
DOM.closeWalletModalBtn.addEventListener('click', closeWalletModal);
DOM.walletModal.addEventListener('click', e => {
    if (e.target === DOM.walletModal) closeWalletModal();
});

// 【核心】为筛选标签绑定事件委托
DOM.transactionFilterTabs.addEventListener('click', e => {
    const targetTab = e.target.closest('.filter-tab');
    if (targetTab && !targetTab.classList.contains('active')) {
        const filter = targetTab.dataset.filter;
        // 重新渲染列表，但不重新计算总额，提升效率
        renderWalletPage(filter);
    }
});

// --- 【新增】星座运势相关的事件监听 ---
DOM.funcHoroscope.addEventListener('click', () => {
    toggleFunctionPanel(); // 关闭功能面板
    
    // 重置浮窗状态
    DOM.horoscopePreviewContainer.innerHTML = '点击“查询运势”以生成';
    appState.pendingHoroscopeData = null;
    DOM.sendHoroscopeCardBtn.disabled = true;
    
    DOM.horoscopeModal.classList.add('visible'); // 显示浮窗
});

// 关闭浮窗的逻辑
const closeHoroscopeModal = () => DOM.horoscopeModal.classList.remove('visible');
DOM.closeHoroscopeModalBtn.addEventListener('click', closeHoroscopeModal);
DOM.cancelHoroscopeBtn.addEventListener('click', closeHoroscopeModal);
DOM.horoscopeModal.addEventListener('click', e => {
    if (e.target === DOM.horoscopeModal) closeHoroscopeModal();
});

// 点击“查询运势”按钮
DOM.queryHoroscopeBtn.addEventListener('click', async () => {
    const dossierId = appState.currentChattingDossierId;
    if (!dossierId) return utils.showToast('请先选择一个聊天对象');
    
    const dossier = appState.dossiers.find(d => d.id === dossierId);
    if (!dossier) return utils.showToast('找不到角色档案');

    const zodiacSign = DOM.horoscopeSelect.value;
    
    DOM.queryHoroscopeBtn.textContent = '生成中...';
    DOM.queryHoroscopeBtn.disabled = true;
    DOM.horoscopePreviewContainer.innerHTML = '正在与星辰沟通...';

    try {
    const messages = promptManager.createHoroscopePrompt(dossier, zodiacSign);
    const aiResponse = await apiHelper.getChatCompletion(messages);
    
    // vvv 【核心修正】在这里增加“智能净化器” vvv
    // 1. 寻找JSON的起始 { 和结束 } 符号的位置
    const jsonStartIndex = aiResponse.indexOf('{');
    const jsonEndIndex = aiResponse.lastIndexOf('}');

    // 2. 检查是否找到了看似JSON的结构
    if (jsonStartIndex === -1 || jsonEndIndex === -1 || jsonEndIndex < jsonStartIndex) {
        // 如果连 { 和 } 都找不到，说明AI返回的内容完全错误
        throw new Error("AI did not return a valid JSON object.");
    }

    // 3. 提取出从 { 到 } 的这部分字符串
    const jsonString = aiResponse.substring(jsonStartIndex, jsonEndIndex + 1);
    
    // 4. 尝试解析这个“净化”过的字符串
    const horoscopeData = JSON.parse(jsonString);
    // ^^^ 修正结束 ^^^

    horoscopeData.zodiacSign = zodiacSign; // 把星座信息也存进去
    
    // 暂存数据
    appState.pendingHoroscopeData = horoscopeData;

    // 【核心】渲染预览卡片
    const previewCardHTML = createHoroscopeCardHTML(horoscopeData);
    DOM.horoscopePreviewContainer.innerHTML = previewCardHTML;
    
    // 激活发送按钮
    DOM.sendHoroscopeCardBtn.disabled = false;

    } catch (error) {
        console.error("生成运势失败:", error);
        DOM.horoscopePreviewContainer.innerHTML = '运势生成失败，请稍后重试。';
        utils.showToast(`生成失败: ${error.message}`);
    } finally {
        DOM.queryHoroscopeBtn.textContent = '查询运势';
        DOM.queryHoroscopeBtn.disabled = false;
    }
});

// 【辅助函数】创建一个可复用的HTML生成器
function createHoroscopeCardHTML(cardData) {
    let starsHTML = '';
    const rating = cardData.overall_rating || 0;
    for (let i = 0; i < 5; i++) {
        starsHTML += (i < rating) ? '<span class="filled">★</span>' : '☆';
    }
    return `
        <div class="horoscope-card">
            <div class="horoscope-header">
                <span class="horoscope-title">今日运势</span>
                <span class="horoscope-zodiac">${cardData.zodiacSign}</span>
            </div>
            <div class="horoscope-rating">${starsHTML}</div>
            <div class="horoscope-details">
                <div class="fortune-item"><span class="label">爱情:</span> <span>${cardData.love_fortune}</span></div>
                <div class="fortune-item"><span class="label">事业:</span> <span>${cardData.work_fortune}</span></div>
                <div class="fortune-item"><span class="label">财运:</span> <span>${cardData.wealth_fortune}</span></div>
            </div>
            <div class="horoscope-charm">${cardData.lucky_charm}</div>
            <div class="horoscope-quote">${cardData.character_quote}</div>
        </div>
    `;
}

// 点击“发送”按钮
DOM.sendHoroscopeCardBtn.addEventListener('click', async () => {
    const horoscopeData = appState.pendingHoroscopeData;
    const dossierId = appState.currentChattingDossierId;
    if (!horoscopeData || !dossierId) return;

    // 1. 构建新的消息对象
    const horoscopeMessage = {
        dossierId,
        sender: 'user', // 由用户行为触发，但显示为中立卡片
        type: 'horoscope',
        content: horoscopeData,
        timestamp: Date.now()
    };
    
    // 2. 存入数据库并更新内存
    const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.CHAT_HISTORY, horoscopeMessage);
    horoscopeMessage.id = savedId;
    const prevMessage = appState.currentChatHistory[appState.currentChatHistory.length - 1];
    appState.currentChatHistory.push(horoscopeMessage);

    // 3. 在聊天界面渲染
    await renderMessage(horoscopeMessage, prevMessage);
    
    // 4. 更新会话列表
    await updateChatSession(dossierId, `[运势] ${horoscopeData.zodiacSign}今日运势`);

    // 5. 关闭浮窗
    closeHoroscopeModal();
});

       // vvv 用这个【V4 - 最终优化版】，完整替换旧的 publishSecretBtn 监听器 vvv

        DOM.publishSecretBtn.addEventListener('click', async () => {
            // 1. 从输入框获取数据 (这部分逻辑不变)
            const title = DOM.secretTitleInput.value.trim();
            const content = DOM.secretContentInput.value.trim();
            const activeMoodEl = DOM.moodSelector.querySelector('.mood-item.active');
            const mood = activeMoodEl ? activeMoodEl.dataset.mood : 'normal';

            // 2. 校验内容是否为空 (这部分逻辑不变)
            if (!content) {
                utils.showToast('心事内容不能为空哦');
                return;
            }

            // 3. 创建一个准备写入数据库的心事对象 (这部分逻辑不变)
            const newSecret = {
                parentId: null,
                title: title || '无标题心事',
                content: content,
                mood: mood,
                timestamp: Date.now(),
                authorType: 'user'
            };

           try {
                const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.SECRETS, newSecret);
                newSecret.id = savedId;
                
                utils.showToast('心事已发布');

                // --- 【核心修正】在这里，我们同时触发两种不冲突的决策！ ---

                // 决策1 (评论): 所有角色都有可能对你的心事进行“评论”
                triggerAiSecretResponseDecision(newSecret).catch(error => {
                    console.error("[心事引擎] 后台AI【回应】决策流程发生未捕获的错误:", error);
                });
                
                // 决策2 (创作): 随机挑选一位角色，被你的心事“触动”，自己也去“发心事”
                triggerAiSecretCreationDecision(newSecret).catch(error => {
                    console.error("[心事引擎] 后台AI【创作】决策流程发生未捕获的错误:", error);
                });

                // 6. 【后】执行所有前台的导航和UI渲染
                navigateToPage(DOM.chatApp, 'chat-main-page');
                const secretsTab = document.querySelector('.tab-item[data-target="secrets-pane"]');
                if (secretsTab) {
                    DOM.chatTabItems.forEach(item => item.classList.remove('active'));
                    secretsTab.classList.add('active');
                    DOM.chatContentPanes.forEach(pane => pane.classList.remove('active'));
                    document.getElementById('secrets-pane').classList.add('active');
                    DOM.chatHeaderTitle.textContent = '心事';
                }
                
                // 确保在导航完成后，再渲染列表
                await renderSecretsList();
                
                // 7. 最后执行清理工作，为下一次发布做准备
                DOM.secretTitleInput.value = '';
                DOM.secretContentInput.value = '';
                DOM.moodSelector.querySelectorAll('.mood-item').forEach(item => item.classList.remove('active'));
                
            } catch (error) {
                console.error("保存或触发心事失败:", error);
                utils.showToast('发布失败，请检查控制台');
            }
        });
        
        // ^^^ 函数到此结束 ^^^

        // --- 使用事件委托，监听对心事列表区域的所有点击 ---
       DOM.secretsListContainer.addEventListener('click', async (e) => { // <--- 关键：将函数改为 async
            const deleteBtn = e.target.closest('.delete-secret-btn');
            const card = e.target.closest('.secret-card');

            if (deleteBtn && card) {
                // --- 情况1: 用户点击的是删除按钮 ---
                e.stopPropagation(); // 【重要】阻止事件冒泡，防止触发下面的“打开详情页”逻辑

                const secretId = parseInt(card.dataset.secretId, 10);
                if (!secretId) return;
                
                // a. 弹出原生确认框，防止误删
                if (confirm("您确定要永久删除这条心事吗？相关的回应也会一并消失。")) {
                    try {
                        // b. 调用我们强大的数据库删除工具
                        await dbHelper.deleteSecretAndResponses(secretId);
                        
                        // c. 在UI上直接移除这张卡片，实现“即时反馈”
                        card.style.transition = 'opacity 0.3s, transform 0.3s';
                        card.style.opacity = '0';
                        card.style.transform = 'scale(0.9)';
                        setTimeout(() => card.remove(), 300);
                        
                        utils.showToast('心事已删除');

                    } catch (error) {
                        console.error("删除心事失败:", error);
                        utils.showToast('删除失败，请检查控制台');
                    }
                }
                
            } else if (card) {
                // --- 情况2: 用户点击的是卡片的其他区域 (和之前一样，打开详情页) ---
                const secretId = parseInt(card.dataset.secretId, 10);
                if (secretId) {
                    openSecretDetails(secretId);
                }
            }
        });

        // --- 负责关闭详情页浮窗的逻辑 ---
       const closeSecretDetailsModal = () => {
            DOM.secretDetailsModal.classList.remove('visible');
            
            // 【核心修正】在这里，彻底重置所有与本次查看相关的状态
            appState.currentViewingSecretId = null; // 清空正在查看的主题ID
            appState.replyingToCommentId = null;    // 清空正在回复的批注ID
            DOM.secretCommentInput.placeholder = '输入你的回应...'; // 恢复输入框的默认提示
        };
        DOM.closeSecretDetailsBtn.addEventListener('click', closeSecretDetailsModal);
        DOM.secretDetailsModal.addEventListener('click', (e) => {
            if (e.target === DOM.secretDetailsModal) {
                closeSecretDetailsModal();
            }
        });
        
        // --- 【全新】发送评论的逻辑 ---
     const handleSendSecretComment = async () => {
            const text = DOM.secretCommentInput.value.trim();
            if (!text) return;
            const parentId = appState.currentViewingSecretId;
            if (!parentId) return;

            const newResponse = {
                parentId: parentId,
                authorType: 'user',
                content: text,
                timestamp: Date.now(),
                replyToId: appState.replyingToCommentId 
            };

            try {
                const savedId = await dbHelper.add(CONSTANTS.STORE_NAMES.SECRETS, newResponse);
                newResponse.id = savedId;

                await openSecretDetails(parentId);
                
                DOM.secretCommentInput.value = '';
                appState.replyingToCommentId = null;
                DOM.secretCommentInput.placeholder = '输入你的回应...';

                // --- 【核心修正：智能分流】 ---
                if (newResponse.replyToId) {
                    // 情况1: 如果是“楼中楼”回复，调用旧的、正确的决策函数
                    triggerAiSecretReplyDecision(newResponse);
                } else {
                    // 情况2: 如果是“第一条评论”，调用我们刚刚创建的新决策函数！
                    triggerAiSecretInitialCommentResponse(newResponse);
                }
                // --- 修正结束 ---

            } catch (error) {
                console.error("保存心事回应失败:", error);
                utils.showToast('发送失败');
            }
        };
        
        // 点击发送按钮
        DOM.sendSecretCommentBtn.addEventListener('click', handleSendSecretComment);
        
        // 按回车发送
        DOM.secretCommentInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // 阻止默认的回车换行行为
                handleSendSecretComment();
            }
        });
        
        // --- 【全新】使用事件委托，监听“写心事”页面内的所有点击 ---
        DOM.secretsCreationPage.addEventListener('click', (e) => {
            // 我们只关心点击的是不是心情选择器里的图标
            const targetItem = e.target.closest('.mood-item');
            
            if (targetItem) {
                // 找到了被点击的心情图标
                
                // 1. 先移除所有图标的 'active' 状态
                DOM.moodSelector.querySelectorAll('.mood-item').forEach(item => item.classList.remove('active'));
                
                // 2. 只给当前被点击的图标添加 'active' 状态
                targetItem.classList.add('active');
            }
        });
        
        // --- 【全新】使用事件委托，监听详情页内部所有“回复”按钮的点击 ---
        DOM.secretDetailsModal.addEventListener('click', (e) => {
            const replyBtn = e.target.closest('.reply-to-comment-btn');
            if (replyBtn) {
                const commentIdToReply = parseInt(replyBtn.dataset.commentId, 10);
                if (!commentIdToReply) return;

                // 1. 【关键】将要回复的批注ID存入全局状态
                appState.replyingToCommentId = commentIdToReply;

                // 2. 更新输入框的placeholder，给用户明确的反馈
                const commentItem = replyBtn.closest('.secret-comment-item');
                const authorName = commentItem.querySelector('.secret-comment-author').textContent;
                DOM.secretCommentInput.placeholder = `回复 ${authorName}:`;

                // 3. 自动聚焦到输入框，方便用户直接输入
                DOM.secretCommentInput.focus();
            }
        });

 // vvv 【新增】使用事件委托，监听对回忆胶片框的点击 vvv
            document.getElementById('memories-pane').addEventListener('click', (e) => {
                // 【核心修正】将监听的目标从旧的胶片框，改为新的宝丽来卡片！
                const card = e.target.closest('.polaroid-card'); 
                if (card) {
                    const dossierId = parseInt(card.dataset.dossierId, 10);
                    const dossier = appState.dossiers.find(d => d.id === dossierId);
                    if (dossier) {
appState.currentChattingDossierId = dossierId;
                        // 1. 更新详情页的标题
                        DOM.memoryDetailsHeaderTitle.textContent = `${dossier.character.name} 的回忆`;
                        // 2. 渲染该角色的剪贴簿
                        renderMemoriesForDossier(dossierId);
                        // 3. 导航到详情页
                        navigateToPage(DOM.chatApp, 'memory-details-page');
                    }
                }
            });
   
// vvv 【新增】使用事件委托，监听回忆详情页中所有删除按钮的点击 vvv
        DOM.memoryScrapbookContainer.addEventListener('click', async (e) => {
            // 检查点击的是否是删除按钮
            const deleteBtn = e.target.closest('.delete-memory-btn');
            if (!deleteBtn) {
                return; // 如果不是，则忽略
            }

            // 从按钮的 data 属性中获取回忆的ID
            const memoryId = parseInt(deleteBtn.dataset.memoryId, 10);
            if (!memoryId) return;

            // 弹出确认框，防止用户误操作
            if (confirm("您确定要永久删除这条珍贵的回忆吗？")) {
                try {
                    // 1. 从数据库中删除记录
                    await dbHelper.delete(CONSTANTS.STORE_NAMES.MEMORIES, memoryId);
                    
                    // 2. 在UI上播放一个移除动画，然后移除卡片
                    const cardToRemove = deleteBtn.closest('.memory-card');
                    if (cardToRemove) {
                        cardToRemove.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        cardToRemove.style.opacity = '0';
                        cardToRemove.style.transform = 'scale(0.95)';
                        
                        setTimeout(() => {
                            cardToRemove.remove();
                            // 如果删除后列表为空，显示提示语
                            if (DOM.memoryScrapbookContainer.children.length === 0) {
                                DOM.memoryScrapbookContainer.innerHTML = `<p style="text-align:center; opacity:0.7; padding: 50px 20px;">这里还没有任何与TA的回忆...</p>`;
                            }
                        }, 300);
                    }
                    
                    // 3. 显示成功提示
                    utils.showToast('回忆已删除');

                } catch (error) {
                    console.error("删除回忆失败:", error);
                    utils.showToast(`删除失败: ${error.message}`);
                }
            }
        }); 

// --- 【全新】处理“添加回忆”功能的事件监听 ---

// 2. 监听回忆详情页的“+”号，用于打开浮窗
DOM.addMemoryBtn.addEventListener('click', () => {
    // 每次打开都清空输入框
    DOM.memoryTitleInput.value = '';
    DOM.memorySummaryInput.value = '';
    DOM.addMemoryModal.classList.add('visible');
    DOM.memoryTitleInput.focus();
});

// 3. 处理浮窗的关闭逻辑
const closeAddMemoryModal = () => DOM.addMemoryModal.classList.remove('visible');
DOM.closeMemoryModalBtn.addEventListener('click', closeAddMemoryModal);
DOM.cancelMemoryBtn.addEventListener('click', closeAddMemoryModal);
DOM.addMemoryModal.addEventListener('click', (e) => {
    if (e.target === DOM.addMemoryModal) {
        closeAddMemoryModal();
    }
});

// 4. 【核心】处理“珍藏回忆”按钮的点击事件
DOM.saveMemoryBtn.addEventListener('click', async () => {
    const title = DOM.memoryTitleInput.value.trim();
    const summary = DOM.memorySummaryInput.value.trim();

    // a. 校验输入
    if (!summary) {
        utils.showToast('回忆纪要不能为空哦');
        return;
    }
    
    // b. 从全局状态获取当前正在查看的角色ID
    const dossierId = appState.currentChattingDossierId;
    if (!dossierId) {
        utils.showToast('保存失败，角色信息丢失');
        return;
    }

    // c. 构建新的回忆对象
    const newMemory = {
        dossierId: dossierId,
        type: 'user_added', // 一个新的类型，用于区分用户手动添加的回忆
        timestamp: Date.now(),
        title: title || '一段难忘的时光', // 如果标题为空，给一个默认值
        summary: summary
    };

    try {
        // d. 将回忆存入数据库
        await dbHelper.add(CONSTANTS.STORE_NAMES.MEMORIES, newMemory);
        
        // e. 关闭浮窗
        closeAddMemoryModal();
        
        // f. 【关键】重新渲染当前角色的回忆列表，实现即时刷新！
        await renderMemoriesForDossier(dossierId);
        
        // g. 给予用户成功反馈
        utils.showToast('一段新的回忆已被珍藏 ✨');

    } catch (error) {
        console.error("保存手动添加的回忆失败:", error);
        utils.showToast('保存失败，请稍后重试');
    }
}); 

// --- 【全新】灵魂回响/日记功能 事件监听 ---

// 点击Dock栏图标，打开日记全屏应用
DOM.soulEchoIcon.addEventListener('click', () => {
    renderDiaryList(); 
    navigateToPage(DOM.diaryApp, 'diary-main-page');
});

// 为日记应用的返回按钮添加监听
DOM.diaryBackBtn.addEventListener('click', (e) => {
    const target = e.target.closest('.back-button').dataset.target;
    if (target === 'desktop') {
        closeNavigator(DOM.diaryApp);
    }
});

// 在日记列表里，点击“+”号，打开写作浮窗
DOM.addUserDiaryBtn.addEventListener('click', () => {
    DOM.diaryTitleInput.value = '';
    DOM.diaryContentInput.value = '';
    DOM.diaryWriteModal.classList.add('visible');
    DOM.diaryTitleInput.focus();
});

// 在日记列表里，点击某一篇日记，打开阅读浮窗
DOM.diaryListContainer.addEventListener('click', async (e) => {
    // 1. 优先检查是否点击了删除按钮
    const deleteBtn = e.target.closest('.delete-diary-btn');
    if (deleteBtn) {
        // 如果点击的是删除按钮，则执行删除逻辑

        // a. 阻止事件冒泡，这是最关键的一步！它会防止点击事件继续传递给卡片
        e.stopPropagation();

        const diaryId = parseInt(deleteBtn.dataset.diaryId, 10);
        if (!diaryId) return;

        if (confirm("您确定要永久删除这篇日记吗？此操作无法撤销。")) {
            try {
                await dbHelper.delete(CONSTANTS.STORE_NAMES.DIARIES, diaryId);
                
                const cardToRemove = deleteBtn.closest('.settings-item[data-diary-id]');
                if (cardToRemove) {
                    cardToRemove.style.transition = 'opacity 0.3s, transform 0.3s';
                    cardToRemove.style.opacity = '0';
                    cardToRemove.style.transform = 'scale(0.95)';
                    
                    setTimeout(() => {
                        cardToRemove.remove();
                        if (DOM.diaryListContainer.children.length === 0) {
                            DOM.diaryListContainer.innerHTML = '<p style="opacity: 0.7; text-align: center;">日记本还是空的，点击右上角“+”写下第一篇吧。</p>';
                        }
                    }, 300);
                }
                utils.showToast('日记已删除');
            } catch (error) {
                console.error("删除日记失败:", error);
                utils.showToast(`删除失败: ${error.message}`);
            }
        }
        
    } else {
        // 2. 如果点击的不是删除按钮，再检查是否点击了卡片本身
        const card = e.target.closest('.settings-item[data-diary-id]');
        if (card) {
            // 如果点击的是卡片，则执行打开阅读浮窗的逻辑
            openDiaryReadModal(parseInt(card.dataset.diaryId, 10));
        }
    }
});

// 关闭写作浮窗
DOM.closeDiaryWriteModalBtn.addEventListener('click', () => DOM.diaryWriteModal.classList.remove('visible'));

// 在写作浮窗里，选择心情
DOM.diaryMoodSelector.addEventListener('click', (e) => {
    const targetItem = e.target.closest('.mood-item');
    if (targetItem) {
        DOM.diaryMoodSelector.querySelectorAll('.mood-item').forEach(item => item.classList.remove('active'));
        targetItem.classList.add('active');
    }
});

// 在写作浮窗里，点击“存入日记本”
DOM.saveUserDiaryBtn.addEventListener('click', async () => {
    const title = DOM.diaryTitleInput.value.trim();
    const content = DOM.diaryContentInput.value.trim();
    const mood = DOM.diaryMoodSelector.querySelector('.mood-item.active')?.dataset.mood || 'normal';

    if (!content) return utils.showToast('日记正文不能为空哦');

    const userDiary = {
        authorType: 'user',
        authorId: 'global_user',
        title, content, mood,
        timestamp: Date.now()
    };
    
    await dbHelper.add(CONSTANTS.STORE_NAMES.DIARIES, userDiary);
    utils.showToast('日记已保存');
    
    DOM.diaryWriteModal.classList.remove('visible');
    await renderDiaryList();
});

// 关闭阅读浮窗
DOM.closeDiaryReadModalBtn.addEventListener('click', () => DOM.diaryReadModal.classList.remove('visible'));
DOM.diaryReadModal.addEventListener('click', (e) => {
    if (e.target === DOM.diaryReadModal) DOM.diaryReadModal.classList.remove('visible');
});                   

// vvv 【【【 全新：点击“电影”图标，打开电影模式应用 】】】 vvv
// 点击桌面“电影”图标，打开选角大厅
DOM.iconMovie.addEventListener('click', () => {
    renderMovieCharacterSelection(); 
    navigateToPage(DOM.movieApp, 'movie-character-select-page');
});

// 处理电影应用内所有返回按钮的逻辑
DOM.movieBackBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
        const target = e.target.closest('.back-button').dataset.target;
        if (target === 'desktop') {
            closeNavigator(DOM.movieApp);
        } else {
            navigateToPage(DOM.movieApp, target);
        }
    });
});

// 在“选角大厅”点击角色海报
DOM.moviePosterGrid.addEventListener('click', (e) => {
    const card = e.target.closest('.movie-poster-card');
    if (card) {
        // 【核心修改】现在调用新的、直接进入电影的函数
        enterMovieMode(parseInt(card.dataset.dossierId, 10));
    }
});

// 在“放映室”点击右上角的设置按钮
DOM.movieSettingsBtn.addEventListener('click', () => {
    // 【核心修改】调用我们刚刚创建的、专门用于在放映室打开设置的函数
    openMovieSettingsModal();
});

// 在“放映室”点击发送按钮
DOM.movieSendBtn.addEventListener('click', handleMovieSend);
DOM.movieInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleMovieSend();
    }
});

// --- 导演设置浮窗的事件监听 ---
const closeMovieSettings = () => DOM.movieSettingsModal.classList.remove('visible');
DOM.closeMovieSettingsBtn.addEventListener('click', closeMovieSettings);
DOM.movieSettingsModal.addEventListener('click', (e) => {
    if (e.target === DOM.movieSettingsModal) closeMovieSettings();
});

// 为书籍选择容器添加点击事件委托
        DOM.movieLibrarySelectContainer.addEventListener('click', (e) => {
            const chip = e.target.closest('.book-chip');
            if (chip) {
                chip.classList.toggle('selected');
            }
        });

// 点击“保存并开始”
DOM.saveMovieSettingsBtn.addEventListener('click', startMovie);

// 点击“清空剧情”
DOM.movieClearHistoryBtn.addEventListener('click', clearMovieHistory);

        // vvv 【【【 全新：电影模式卡片操作的事件委托 】】】 vvv
        DOM.movieScreenContainer.addEventListener('click', async (e) => {
            const target = e.target;
            const card = target.closest('.story-card');
            if (!card) return;

            const turnId = parseInt(card.dataset.turnId, 10);
            
            // 判断点击的是哪个按钮
            if (target.classList.contains('ri-delete-bin-line')) {
                // 点击了删除按钮
                handleMovieDelete(turnId);
            } else if (target.classList.contains('ri-pencil-line')) {
                // 点击了编辑按钮
                handleMovieEdit(turnId);
            } else if (target.classList.contains('ri-refresh-line')) {
                // 点击了重投按钮
                handleMovieRetry(turnId);
            }
        });

// vvv 【【【 全新：电影编辑浮窗的事件监听 】】】 vvv
        
        // 辅助函数：用于关闭浮窗并重置状态
        const closeMovieEditModal = () => {
            DOM.movieEditModal.classList.remove('visible');
            appState.currentEditingMovieTurnId = null;
            DOM.movieEditTextarea.value = '';
        };

        // 为三种关闭方式绑定事件
        DOM.closeMovieEditBtn.addEventListener('click', closeMovieEditModal);
        DOM.cancelMovieEditBtn.addEventListener('click', closeMovieEditModal);
        DOM.movieEditModal.addEventListener('click', (e) => {
            if (e.target === DOM.movieEditModal) {
                closeMovieEditModal();
            }
        });

        // 【核心】为“保存修改”按钮绑定事件
        DOM.saveMovieEditBtn.addEventListener('click', async () => {
            const turnId = appState.currentEditingMovieTurnId;
            const newContent = DOM.movieEditTextarea.value.trim();

            if (!turnId) return;
            if (newContent === '') return utils.showToast('剧情内容不能为空！');

            try {
                const turnToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, turnId);
                if (!turnToUpdate) throw new Error('在数据库中找不到该剧情回合');

                // 1. 更新内容
                turnToUpdate.content = newContent;
                
                // 2. 保存回数据库
                await dbHelper.set(CONSTANTS.STORE_NAMES.MOVIE_HISTORY, turnToUpdate);

                // 3. 重新渲染整个屏幕
                await rerenderMovieScreen(appState.currentMovieSession.dossierId);

                utils.showToast('剧情已更新');
                closeMovieEditModal(); // 操作成功后关闭浮窗

            } catch (error) {
                console.error("保存编辑失败:", error);
                utils.showToast(`保存失败: ${error.message}`);
            }
        });

// vvv 【【【 全新：电影模式上传背景壁纸的事件监听 】】】 vvv
        
        // 1. 点击输入栏的“图片”图标，触发文件选择器
       DOM.movieWallpaperUploadBtn.addEventListener('click', () => { // <--- 修改为新的变量名
            DOM.movieWallpaperUploader.click();
        });

        // 2. 当用户选择了文件后，执行上传和应用逻辑
        DOM.movieWallpaperUploader.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file || !appState.currentMovieSession?.dossierId) {
                e.target.value = ''; // 即使不处理，也要重置
                return;
            }
            
            const dossierId = appState.currentMovieSession.dossierId;

            try {
                utils.showToast('正在处理壁纸...');
                // a. 压缩图片
                const compressedFile = await compressImageForDisplay(file);
                
                // b. 将图片存入数据库，获取 assetId
                const assetId = await dbHelper.add(CONSTANTS.STORE_NAMES.ASSETS, { file: compressedFile });

                // c. 【核心】将 assetId 与当前电影的 dossierId 关联并保存
                const sessionToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.MOVIE_SESSIONS, dossierId) || { dossierId };
                sessionToUpdate.wallpaperAssetId = assetId;
                await dbHelper.set(CONSTANTS.STORE_NAMES.MOVIE_SESSIONS, sessionToUpdate);
                
                // d. 同步更新内存中的状态
                appState.currentMovieSession.wallpaperAssetId = assetId;

                // e. 将图片应用到背景伪元素上
                const imageUrl = URL.createObjectURL(compressedFile);
                const storyPage = DOM.movieStoryPage;
                if (storyPage) {
                    // 我们通过设置CSS变量来改变伪元素的背景
                    storyPage.style.setProperty('--movie-bg-image', `url('${imageUrl}')`);
                }
                
                utils.showToast('背景已更新！');

            } catch (error) {
                console.error("电影壁纸处理失败:", error);
                utils.showToast('壁纸设置失败');
            } finally {
                // f. 重置文件选择器
                e.target.value = '';
            }
        });

// vvv 【【【 全新：电影导演风格设置的事件监听 】】】 vvv
        
        // 1. 点击附件按钮，打开风格设置浮窗
       DOM.movieStyleBtn.addEventListener('click', openMovieStyleModal); // <--- 修改为新的变量名

        // 2. 关闭浮窗的逻辑
        const closeMovieStyleModal = () => DOM.movieStyleModal.classList.remove('visible');
        DOM.closeMovieStyleBtn.addEventListener('click', closeMovieStyleModal);
        DOM.cancelMovieStyleBtn.addEventListener('click', () => {
            // 取消时，要恢复到保存前的样式
            applyMovieStyles(appState.currentMovieSession.styleSettings);
            closeMovieStyleModal();
        });

        // 3. 实时预览：当任何颜色选择器变化时，立即应用样式
        DOM.movieStyleSettingsGrid.addEventListener('input', (e) => {
            if (e.target.type === 'color') {
                const tempStyles = {
                    normal: DOM.styleInputs.normal.value,
                    thought: DOM.styleInputs.thought.value,
                    dialogue: DOM.styleInputs.dialogue.value,
                    userInput: DOM.styleInputs.userInput.value,
                    inputBarBg: DOM.styleInputs.inputBarBg.value,
                    sendBtnBg: DOM.styleInputs.sendBtnBg.value,
                    sendBtnText: DOM.styleInputs.sendBtnText.value,
                };
                applyMovieStyles(tempStyles);
            }
        });

        // 4. 恢复默认按钮
        DOM.resetMovieStyleBtn.addEventListener('click', () => {
            if (confirm("确定要将所有颜色恢复为默认设置吗？")) {
                // vvv 【【【 在这里做修改 】】】 vvv
                applyMovieStyles(CONSTANTS.DEFAULT_MOVIE_STYLES); // 应用默认样式
                // 同时更新浮窗内的颜色选择器
                DOM.styleInputs.normal.value = CONSTANTS.DEFAULT_MOVIE_STYLES.normal;
                DOM.styleInputs.thought.value = CONSTANTS.DEFAULT_MOVIE_STYLES.thought;
                DOM.styleInputs.dialogue.value = CONSTANTS.DEFAULT_MOVIE_STYLES.dialogue;
                DOM.styleInputs.userInput.value = CONSTANTS.DEFAULT_MOVIE_STYLES.userInput;
                DOM.styleInputs.inputBarBg.value = CONSTANTS.DEFAULT_MOVIE_STYLES.inputBarBg;
                DOM.styleInputs.sendBtnBg.value = CONSTANTS.DEFAULT_MOVIE_STYLES.sendBtnBg;
                DOM.styleInputs.sendBtnText.value = CONSTANTS.DEFAULT_MOVIE_STYLES.sendBtnText;
            }
        });

        // 5. 【核心】保存风格按钮
        DOM.saveMovieStyleBtn.addEventListener('click', async () => {
            const dossierId = appState.currentMovieSession?.dossierId;
            if (!dossierId) return;

            // a. 从颜色选择器收集最新的样式
            const newStyles = {
                normal: DOM.styleInputs.normal.value,
                thought: DOM.styleInputs.thought.value,
                dialogue: DOM.styleInputs.dialogue.value,
                userInput: DOM.styleInputs.userInput.value,
                inputBarBg: DOM.styleInputs.inputBarBg.value,
                sendBtnBg: DOM.styleInputs.sendBtnBg.value,
                sendBtnText: DOM.styleInputs.sendBtnText.value,
            };

            try {
                // b. 更新数据库
                const sessionToUpdate = await dbHelper.get(CONSTANTS.STORE_NAMES.MOVIE_SESSIONS, dossierId) || { dossierId };
                sessionToUpdate.styleSettings = newStyles;
                await dbHelper.set(CONSTANTS.STORE_NAMES.MOVIE_SESSIONS, sessionToUpdate);

                // c. 更新内存
                appState.currentMovieSession.styleSettings = newStyles;

                utils.showToast('导演风格已保存！');
                closeMovieStyleModal();

            } catch (error) {
                console.error("保存风格失败:", error);
                utils.showToast('保存失败');
            }
        });        
            
}
        async function initializeApp() {
            try {
                await dbHelper.init();
                const [activePresetName, todos, dossiers, chatSessions] = await Promise.all([
                    dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'active_api_preset'),
                    dbHelper.get(CONSTANTS.STORE_NAMES.USER_SETTINGS, 'todo_list'),
                    dbHelper.getAll(CONSTANTS.STORE_NAMES.DOSSIERS),
                    dbHelper.getAll(CONSTANTS.STORE_NAMES.CHAT_SESSIONS)
                ]);
                if (activePresetName) { appState.activeApiPreset = await dbHelper.get(CONSTANTS.STORE_NAMES.API_PRESETS, activePresetName); }
                appState.todos = todos || [];
                appState.dossiers = dossiers || [];
                appState.chatSessions = chatSessions || [];
                setupClock();
                applyTheme(localStorage.getItem('theme') === 'light');
                await renderPlaylist();
                const [lastIdx, lMode, iShuffle, avatarId, cText, cSub] = await Promise.all([
                    dbHelper.get(CONSTANTS.STORE_NAMES.PLAYER_STATE, 'last_song_index'), dbHelper.get(CONSTANTS.STORE_NAMES.PLAYER_STATE, 'loop_mode'),
                    dbHelper.get(CONSTANTS.STORE_NAMES.PLAYER_STATE, 'is_shuffle'), dbHelper.get(CONSTANTS.STORE_NAMES.PLAYER_STATE, 'avatar_id'),
                    dbHelper.get(CONSTANTS.STORE_NAMES.PLAYER_STATE, 'custom_text'), dbHelper.get(CONSTANTS.STORE_NAMES.PLAYER_STATE, 'custom_subtitle')
                ]);
                appState.currentTrackIndex = (lastIdx != null && lastIdx < appState.playlist.length) ? lastIdx : 0;
                if (lMode) {
                    appState.loopMode = lMode;
                    const icons = {'none':'ri-prohibited-line', 'one':'ri-repeat-one-line', 'all':'ri-repeat-2-line'};
                    DOM.loopBtn.className = icons[lMode] || 'ri-repeat-2-line';
                    DOM.audioPlayer.loop = (lMode === 'one');
                }
                if (iShuffle === true) { appState.isShuffle = false; DOM.shuffleBtn.click(); }
                if (avatarId) { const asset = await dbHelper.get(CONSTANTS.STORE_NAMES.ASSETS, avatarId); if (asset?.file) DOM.playerAvatar.style.backgroundImage = `url(${URL.createObjectURL(asset.file)})`; }
                DOM.playerCustomText.textContent = cText || 'carpe diem';
                if (appState.playlist.length > 0) {
                    DOM.playerSongTitle.textContent = appState.playlist[appState.currentTrackIndex]?.title || '--';
                    DOM.playerSongTitle.contentEditable = 'false';
                } else { DOM.playerSongTitle.textContent = cSub || '--'; DOM.playerSongTitle.contentEditable = 'true'; }
                renderCalendar();
                renderTodos();
                renderChatList();
                await populateApiPresets();
                await restoreDesktopState();
                initializeEventListeners();
ActionEngine.start();
            } catch (error) {
                console.error("Application failed to initialize:", error);
                alert("应用启动失败，请检查控制台错误。");
            }
        }
        initializeApp();
    });
    </script>
</body>
</html>